<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/04/19/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"/>
    <url>/2025/04/19/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="一些数学公式技巧">一些数学公式技巧</h2><h3 id="1、v-v-v-5">1、v = v - v % 5</h3><p>数学意义：通过减去余数，将 v 调整到最接近 5 的倍数</p><h3 id="calMod">calMod</h3><p>数学意义：模运算，计算两个整数相除后的余数<br><code>calMod = x - y * Math.floor(x/y)</code></p><ul><li>约束范围</li></ul><h3 id="Math-log2">Math.log2()</h3><p>求 2 的指数，1 &gt; val &gt; 0 则为负数</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>视图矩阵</title>
    <link href="/2025/04/19/%E8%A7%86%E5%9B%BE%E7%9F%A9%E9%98%B5/"/>
    <url>/2025/04/19/%E8%A7%86%E5%9B%BE%E7%9F%A9%E9%98%B5/</url>
    
    <content type="html"><![CDATA[<h2 id="视图矩阵">视图矩阵</h2><h3 id="作用">作用</h3><ul><li>将物体从世界坐标系转换到以摄像机为原点到观察坐标系，也就是相机空间</li><li>在数学上是相机矩阵模型的逆矩阵</li></ul><p>我们想一下，从一个坐标系转换到另一个坐标系，我们需要做什么</p><p>其实也就是做平移和旋转</p><p>这里注意视图矩阵是给世界坐标中的图元用的，相机只是我们提出的一个概念，图元使用逆变换达到这个目的</p><p>例如：假设相机向右移动，场景中的图元向左移动</p><ul><li>平移：将相机位置移动到原点</li><li>旋转：将相机的方向对齐到标准版坐标系统，如相机朝向-z 轴，右方向对齐 x 轴，上方向对齐 y 轴</li></ul><p>那么这个变化矩阵如何求得？</p><h3 id="构造参数">构造参数</h3><ul><li><p>摄像机位置 (Eye)，相机在世界坐标中的位置</p></li><li><p>观察目标点（At），相机注视的焦点</p></li><li><p>上方向（Up），定义相机的垂直方向，通常为世界坐标系的 Y 轴（0，1，0）<br>从下面的公式我们可以看出，这里用 1 或者-1，其实影响的是右轴的结果，也就是 x 轴的结果，这样会导致左右方向反向<br>影响了右轴还会影响上轴的方向，还会上下颠倒，也就是本来有一个点（x，y），会变成（-x, -y），坐标轴会旋转 180 度</p></li></ul><p>这些其实就是为了相机坐标系的构建</p><p>我们知道坐标系是有三个方向的</p><h4 id="计算">计算</h4><p>前向轴：<br><code>F = normalize(At - Eye)</code><br>也就是从相机位置出发，指向目标点</p><p>右轴：<br><code>R = normalize(cross(F, Up))</code><br>垂直于前向和上方向</p><p>上轴：<br><code>Up = U = cross(R, F)</code></p><h4 id="构造旋转矩阵-R">构造旋转矩阵 R</h4><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center center center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>R</mi><mi>x</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>R</mi><mi>y</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>R</mi><mi>z</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>U</mi><mi>x</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>U</mi><mi>y</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>U</mi><mi>z</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mi>F</mi><mi>x</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mi>F</mi><mi>y</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mi>F</mi><mi>z</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex"> \begin{bmatrix} Rx &amp; Ry &amp; Rz &amp; 0 \\ Ux &amp; Uy &amp; Uz  &amp; 0 \\ -Fx &amp; -Fy &amp; -Fz &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.8em;vertical-align:-2.15em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.65em;"><span class="pstrut" style="height:6.8em;"></span><span style="width:0.667em;height:4.800em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="4.800em" viewbox="0 0 667 4800"><path d="M403 1759 V84 H666 V0 H319 V1759 v1200 v1759 h347 v-84H403z M403 1759 V0 H319 V1759 v1200 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">x</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">Ux</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">x</span></span></span><span style="top:-1.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span><span style="top:-1.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span><span style="top:-1.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.65em;"><span class="pstrut" style="height:6.8em;"></span><span style="width:0.667em;height:4.800em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="4.800em" viewbox="0 0 667 4800"><path d="M347 1759 V0 H0 V84 H263 V1759 v1200 v1759 H0 v84 H347zM347 1759 V0 H263 V1759 v1200 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><h4 id="构造平移矩阵-T">构造平移矩阵 T</h4><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center center center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mi>E</mi><mi>y</mi><mi>e</mi><mi>X</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mi>E</mi><mi>y</mi><mi>e</mi><mi>Y</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mi>E</mi><mi>y</mi><mi>e</mi><mi>Z</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex"> \begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; -EyeX \\ 0 &amp; 1 &amp; 0 &amp; -EyeY \\ 0 &amp; 1 &amp; 0 &amp; -EyeZ \\ 0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.8em;vertical-align:-2.15em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.65em;"><span class="pstrut" style="height:6.8em;"></span><span style="width:0.667em;height:4.800em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="4.800em" viewbox="0 0 667 4800"><path d="M403 1759 V84 H666 V0 H319 V1759 v1200 v1759 h347 v-84H403z M403 1759 V0 H319 V1759 v1200 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-1.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal">ye</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal">ye</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal">ye</span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span></span></span><span style="top:-1.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.65em;"><span class="pstrut" style="height:6.8em;"></span><span style="width:0.667em;height:4.800em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="4.800em" viewbox="0 0 667 4800"><path d="M347 1759 V0 H0 V84 H263 V1759 v1200 v1759 H0 v84 H347zM347 1759 V0 H263 V1759 v1200 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><p>v = R * T</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>光照</title>
    <link href="/2025/03/01/%E5%85%89%E7%85%A7/"/>
    <url>/2025/03/01/%E5%85%89%E7%85%A7/</url>
    
    <content type="html"><![CDATA[<h3 id="webgpu-光照">webgpu 光照</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>webgpu数学知识</title>
    <link href="/2025/01/27/webgpu%E5%A4%8D%E4%B9%A0/"/>
    <url>/2025/01/27/webgpu%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">private resetFillStyle;<br>private fillStyle;<br><span class="hljs-title function_">save</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">resetFillStyle</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">fillStyle</span>;<br>&#125;<br><br><span class="hljs-title function_">setFillStyle</span>(<span class="hljs-params">val</span>) &#123;<br>    <span class="hljs-keyword">if</span> (val === <span class="hljs-variable language_">this</span>.<span class="hljs-property">fillStyle</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastState</span>.<span class="hljs-property">fillStyle</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">resetFillStyle</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">fillStyle</span> = val;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">context</span>.<span class="hljs-property">fillStyle</span> = val;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>相机</title>
    <link href="/2024/11/11/%E7%9B%B8%E6%9C%BA/"/>
    <url>/2024/11/11/%E7%9B%B8%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机图形学中的相机"><a href="#计算机图形学中的相机" class="headerlink" title="计算机图形学中的相机"></a>计算机图形学中的相机</h1><h2 id="基础参数"><a href="#基础参数" class="headerlink" title="基础参数"></a>基础参数</h2><ul><li><p>位置<br>相机在三维空间中的坐标位置 （眼睛的位置）</p></li><li><p>方向参数</p><ul><li><p>相机的观察方向 （视线）<br>目标点：target<br>观察方向：target - position<br>从相机位置出发，指向目标点的方向</p><p>相机的观察方向是相机 z 轴的负方向<br>可以从视觉角度理解，假设相机在向后移动，实际上是沿着 z 轴的正方向在移动</p></li><li><p>上方向（up）</p></li></ul><p>这里为什么我们需要上方向，相机也是一个坐标系，我们现在只有一个 z 轴，至少两个方向才能确定一个坐标系，第三个我们可以求出来</p></li></ul><h2 id="相机坐标系如何求得"><a href="#相机坐标系如何求得" class="headerlink" title="相机坐标系如何求得"></a>相机坐标系如何求得</h2><ul><li>z 轴我们已经知道了，（观察方向的反方向）</li><li>假定一个上方向（0，1，0）</li><li>up 叉乘得到 z 轴单位向量得到指向 x 轴正方向的向量（交换叉乘顺序，会得到指向 x 轴负方向的向量）</li><li>z 轴叉乘 x 轴得到 y 方向</li></ul><h2 id="lookAt-矩阵"><a href="#lookAt-矩阵" class="headerlink" title="lookAt 矩阵"></a>lookAt 矩阵</h2><p><img src="/2024/11/11/%E7%9B%B8%E6%9C%BA/2024-11-18-23-32-10.png"></p><ul><li>R x</li><li>U y</li><li>D z</li><li>P 摄像机的位置，位置向量是反向的<br>想象一下拖动画布，相机向右移动，我们的目标对象看起来是向左运动，观察矩阵是给观察对象用的</li></ul><h2 id="视角移动"><a href="#视角移动" class="headerlink" title="视角移动"></a>视角移动</h2><p>没什么特别的，其实就是不同的角度，偏移量上的计算问题</p><h3 id="欧拉角"><a href="#欧拉角" class="headerlink" title="欧拉角"></a>欧拉角</h3><p>3D 空间中任何旋转的 3 个值</p><p><img src="/2024/11/11/%E7%9B%B8%E6%9C%BA/2024-11-18-23-40-59.png"></p><h4 id="俯仰角-Pitch"><a href="#俯仰角-Pitch" class="headerlink" title="俯仰角 Pitch"></a>俯仰角 Pitch</h4><p>往上看或者往下看的角</p><p>固定 y 轴</p><p><img src="/2024/11/11/%E7%9B%B8%E6%9C%BA/2024-12-09-23-50-29.png"></p><p>方向分量变化</p><p><code>direction.y = sin(glm::radians(pitch));  direction.x = cos(glm::radians(pitch)); direction.z = cos(glm::radians(pitch));</code></p><h4 id="偏航角-Yaw"><a href="#偏航角-Yaw" class="headerlink" title="偏航角 Yaw"></a>偏航角 Yaw</h4><p>固定 z 轴</p><p>往左往右看</p><p><img src="/2024/11/11/%E7%9B%B8%E6%9C%BA/2024-12-09-23-54-10.png"></p><p>基本和俯仰角一致</p><p>基于俯仰角和偏航角我们能得到</p><p><code>direction.x = cos(glm::radians(pitch)) * cos(glm::radians(yaw)); // 译注：direction代表摄像机的前轴(Front)，这个前轴是和本文第一幅图片的第二个摄像机的方向向量是相反的 direction.y = sin(glm::radians(pitch)); direction.z = cos(glm::radians(pitch)) * sin(glm::radians(yaw)); </code></p><h5 id="另一种解释"><a href="#另一种解释" class="headerlink" title="另一种解释"></a>另一种解释</h5><p><img src="/2024/11/11/%E7%9B%B8%E6%9C%BA/2024-12-10-00-11-47.png"></p><h4 id="滚转角-Roll"><a href="#滚转角-Roll" class="headerlink" title="滚转角 Roll"></a>滚转角 Roll</h4><p>翻滚摄像机，目前不考虑</p><p><a href="https://learnopengl-cn.github.io/01%20Getting%20started/09%20Camera/">https://learnopengl-cn.github.io/01%20Getting%20started/09%20Camera/</a></p><p><a href="https://www.cnblogs.com/rmb999/p/17817397.html">https://www.cnblogs.com/rmb999/p/17817397.html</a></p><h2 id="案例：鼠标移动"><a href="#案例：鼠标移动" class="headerlink" title="案例：鼠标移动"></a>案例：鼠标移动</h2><ul><li>计算鼠标距上一帧的偏移量</li><li>把偏移量添加到相机的俯仰角（竖直的移动）和偏航角（水平的移动）中</li><li>对偏航角和俯仰角进行最大和最小值的限制<br>这里特指的是俯仰角，用户在 90 度时候视角会发生逆转，所以我们需要限制到 89 度，负数同理</li><li>计算方向向量</li></ul><p>注意偏移量需要乘灵敏度</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>canvas2d</title>
    <link href="/2024/07/21/canvas2d/"/>
    <url>/2024/07/21/canvas2d/</url>
    
    <content type="html"><![CDATA[<h2 id="canvas2d"><a href="#canvas2d" class="headerlink" title="canvas2d"></a>canvas2d</h2><p>2D 上下文的坐标原点(0,0)是在 canvas 元素的左上角(区别于 webgpu)<br>所有的坐标值都相对于该点计算，x 坐标向右增长，y 坐标向下增长，width 和 height 表示两个方向上像素的最大值；</p><h3 id="填充和描边"><a href="#填充和描边" class="headerlink" title="填充和描边"></a>填充和描边</h3><p>fillStyle 和 strokeStyle<br>如果进行了设置，那么所有的描边和填充相关的操作都会使用这两种样式，除非再次修改</p><p>*<em>这两个属性也可以是渐变或者图案？</em></p><h3 id="绘制矩形"><a href="#绘制矩形" class="headerlink" title="绘制矩形"></a>绘制矩形</h3><ul><li>填充矩形<br><code>ctx.fillRect()</code></li><li>描边矩形<br><code>ctx.strokeRect()</code><br>线宽由 lineWidth 控制<br>lineCap 属性控制线条端点的形状</li><li><code>ctx.clearRect()</code><br>可以擦除画布中的某个区域</li></ul><h3 id="绘制路径"><a href="#绘制路径" class="headerlink" title="绘制路径"></a>绘制路径</h3><ul><li><p>首先要调用 beginPath()方法表示要开始绘制新路径，然后再用下列方法来绘制路径</p></li><li><p><code>arc()</code> 给定圆心起始角和结束角方向绘制弧线</p></li><li><p><code>arcTo()</code> 给定半径和两个点，绘制两个点之间的弧线</p></li><li><p><code>bezierCurveTo</code> 三次贝塞尔曲线，两个控制点一个结束点</p></li><li><p><code>lineTo</code> 一个点，从上一个点到这一个点，一般都是和 moveTo 结合着用</p></li><li><p><code>moveTo</code> 不绘制线条，只把绘制光标移动到 x，y; 这个是为了避免绘制出多余的线条</p></li><li><p><code>quadraticCurveTo</code> 一个控制点一个结束点的贝塞尔</p></li><li><p><code>rect</code> 给定宽度和高度绘制一个矩形，创建的是路径而不是独立的图形</p></li><li><p>创建完路径之后，可以使用 closePath()方法绘制一条返回起点的线，路径完成后可以指定 fillStyle，并且使用 fill 来填充路径，也可以用 stroke 来描画路径，还可以使用 clip 来创建一个剪切区域</p></li></ul><h3 id="绘制文本"><a href="#绘制文本" class="headerlink" title="绘制文本"></a>绘制文本</h3><p>fillText</p><p>用于辅助确认文本大小 mesureText</p><h3 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h3><ul><li><p>rotate<br>围绕原点把图像旋转 angle 弧度<br>旋转的是接下来需要绘制的图元</p></li><li><p>scale<br>通过在 x 轴乘以 scaleX 和在 y 轴乘以 scaleY 来缩放图像，scaleX 和 scaleY 的默认值都是 1</p></li><li><p>translate(x,y)<br>把原点（0，0）移动到 x，y</p></li><li><p>transform<br>通过矩阵乘法直接修改矩阵<br>这里的参数跟 3*3 矩阵不太一样，需要做调整</p></li><li><p>setTransform<br>把矩阵重置为默认值，再按参数调用 transform</p></li><li><p>save<br>保存当前这一时刻的设置，设置（颜色）和变换（矩阵）</p></li><li><p>restore<br>从之前保存的地方恢复</p><p>注意，这里是成对出现，可以保存恢复多套配置</p></li></ul><h3 id="绘制图像"><a href="#绘制图像" class="headerlink" title="绘制图像"></a>绘制图像</h3><p>drawImage()</p><ul><li>第一个参数<ul><li>可以是图片 <code>document.image</code></li><li>也可以是另一个 canvas 元素</li></ul></li></ul><p>操作结果可以用<code>canvas.toDataURL</code>来显示</p><h3 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h3><p>shadowOffsetX 等配置项</p><h3 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h3><p>渐变相关 api</p><h3 id="图案"><a href="#图案" class="headerlink" title="图案"></a>图案</h3><p>图案是用来填充和描画图形的重复图像</p><p><code>createPattern</code></p><p>可以是 canvas</p><p>是否可以用来做业务上的填充网格？</p><h2 id="图像数据"><a href="#图像数据" class="headerlink" title="图像数据"></a>图像数据</h2><p><code>getImageData()</code> 获取原始图像数据得到一个 imageData</p><ul><li>width</li><li>height</li><li>data<ul><li>data 里面是 rgba 值</li></ul></li></ul><p><code>putImageData</code><br>第一个参数是 imageData<br>用于修改后的数据写回到 imageData 并应用到画布显示出来</p><h2 id="合成"><a href="#合成" class="headerlink" title="合成"></a>合成</h2><p>文中绘制的所有内容都会应用两个属性</p><ul><li><p>globalAlpha<br>0-1 透明度</p></li><li><p>globalCompositionOperation<br>一种融合关系，比如只显示重叠部分</p><p>默认是新图形绘制在原有图像的上面</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>向量学习</title>
    <link href="/2024/06/03/%E5%90%91%E9%87%8F%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/06/03/%E5%90%91%E9%87%8F%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="二维场景"><a href="#二维场景" class="headerlink" title="二维场景"></a>二维场景</h1><h2 id="点积"><a href="#点积" class="headerlink" title="点积"></a>点积</h2><p>点积的几何意义是投影相乘</p><p>投影如何理解</p><p><img src="/2024/06/03/%E5%90%91%E9%87%8F%E5%AD%A6%E4%B9%A0/2024-06-03-23-46-30.png"></p><p>从数学上看向量是这样的<br><img src="/2024/06/03/%E5%90%91%E9%87%8F%E5%AD%A6%E4%B9%A0/2024-06-03-23-10-41.png"></p><p>从几何角度来看 A 点乘 B 是 B 在向量 A 方向上的投影，投影得到的长度和 A 的模进行相乘</p><p><img src="/2024/06/03/%E5%90%91%E9%87%8F%E5%AD%A6%E4%B9%A0/2024-06-03-23-26-28.png"></p><p>直观理解</p><p>向量垂直（正交）：投影为 0</p><p>投影如果为反方向（大于 90 度）：点积为负</p><h2 id="点积具有对称性"><a href="#点积具有对称性" class="headerlink" title="点积具有对称性"></a>点积具有对称性</h2><p>也就是 无论是 A 点乘 B 还是 B 点乘 A 结果都是一样的</p><p><img src="/2024/06/03/%E5%90%91%E9%87%8F%E5%AD%A6%E4%B9%A0/2024-06-03-23-53-00.png"></p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p><img src="/2024/06/03/%E5%90%91%E9%87%8F%E5%AD%A6%E4%B9%A0/2024-06-04-00-07-51.png"></p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>实用小工具：<br><a href="https://www.geogebra.org/calculator">https://www.geogebra.org/calculator</a></p><p>原文：<br><a href="https://www.cnblogs.com/RyanXing/p/dot_product.html">https://www.cnblogs.com/RyanXing/p/dot_product.html</a></p><h2 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h2><ul><li><p>通过单位向量和已知向量求已知向量在单位向量上的投影<br>这里也可以看出通过勾股定理我们也能直接求得这个高度<br><img src="/2024/06/03/%E5%90%91%E9%87%8F%E5%AD%A6%E4%B9%A0/2024-07-10-23-24-58.png"></p></li><li><p>根据正负判断方向</p></li></ul><h2 id="叉乘"><a href="#叉乘" class="headerlink" title="叉乘"></a>叉乘</h2><h2 id="业务场景-1"><a href="#业务场景-1" class="headerlink" title="业务场景"></a>业务场景</h2><p>A x B &#x3D; ｜ A ｜｜ B ｜ sin</p><ul><li><p>正值，B 向量在 A 向量的逆时针方向</p></li><li><p>负值，B 向量在 A 向量的顺时针方向</p></li><li><p>对于单位向量模长为 1<br>点乘的结果也就是直接得到了垂线的高度</p></li></ul><h2 id="单位向量"><a href="#单位向量" class="headerlink" title="单位向量"></a>单位向量</h2><p>单位向量乘以长度，得到这个方向上的值</p><h2 id="Math-sqrt"><a href="#Math-sqrt" class="headerlink" title="Math.sqrt"></a>Math.sqrt</h2><p>Math.sqrt(0.5) &#x3D; Math.sqrt(2) * 0.5</p><p>论证：</p><p>sqrt(0.5) &#x3D; sqrt(1) &#x2F; sqrt(2) &#x3D; 1 &#x2F; sqrt(2) &#x3D; sqrt(2) &#x2F; 2</p><p><img src="/2024/06/03/%E5%90%91%E9%87%8F%E5%AD%A6%E4%B9%A0/2024-07-10-23-52-30.png"></p><h1 id="三维场景"><a href="#三维场景" class="headerlink" title="三维场景"></a>三维场景</h1><p>三维向量</p><p><img src="/2024/06/03/%E5%90%91%E9%87%8F%E5%AD%A6%E4%B9%A0/2024-11-11-23-07-25.png"></p><p>本质都是向量，计算法则都是相互通的</p><h2 id="叉乘-1"><a href="#叉乘-1" class="headerlink" title="叉乘"></a>叉乘</h2><ul><li>叉乘在三维空间中的经典用处之一，是计算法向量</li></ul><p>也就是垂直于两个向量的第三个向量</p><p>两个向量的叉乘的结果就是法向量，遵循右手法则</p><p><img src="/2024/06/03/%E5%90%91%E9%87%8F%E5%AD%A6%E4%B9%A0/2024-11-11-23-15-14.png"></p><ul><li>判断向量之间的平行关系<br>点乘为 0，则可判断这两个向量平行</li></ul><h2 id="点乘"><a href="#点乘" class="headerlink" title="点乘"></a>点乘</h2><ul><li>假设我们现在有两个三位平面，想知道这两个平面的夹角是多少</li></ul><p>我们的做法应该是</p><p>1、求出两个平面的法向量</p><p>2、利用点乘计算两个法向量的夹角</p><ul><li>判断向量之间的垂直关系<br>点乘为 0，两个向量垂直</li></ul><h1 id="向量的加减法"><a href="#向量的加减法" class="headerlink" title="向量的加减法"></a>向量的加减法</h1><p><img src="/2024/06/03/%E5%90%91%E9%87%8F%E5%AD%A6%E4%B9%A0/2024-11-12-00-06-28.png"></p><p><img src="/2024/06/03/%E5%90%91%E9%87%8F%E5%AD%A6%E4%B9%A0/2024-11-12-00-06-46.png"></p><p>注意这里向量的减法是 A - B，指向的是 A 向量</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MSAA</title>
    <link href="/2024/05/06/MSAA/"/>
    <url>/2024/05/06/MSAA/</url>
    
    <content type="html"><![CDATA[<h2 id="MSAA-多重采样抗锯齿">MSAA 多重采样抗锯齿</h2><p>分辨率：</p><ul><li>分辨率影响什么？<br>分辨率影响的其实是屏幕上像素的多少</li><li>浏览器缩放影响什么<br>影响的是显示尺寸<ul><li>显示尺寸 也就是 css 控制的</li><li>物理像素尺寸 实际像素 也就是不管显示尺寸是多大，实际可用的像素就只有这么多<br>当显示尺寸和物理像素尺寸不一致的时候就会对 canvas 的内容进行缩放以适应显示尺寸<br>这里也就用上了 window.devicePixelRatio 获取设备的像素比率，这里其实修改的是物理像素</li></ul></li><li>缩放相机<ul><li>单位像素长度，屏幕中的一像素能够表示对象的长度，描述的其实是用像素表示物体</li><li>假设我们有一个对象，它的尺寸是 100x100 像素。当您观看这个对象时，您实际上是在看 100x100 的像素网格。单位像素长度是指在屏幕上实际代表对象的单个像素的大小。</li><li>放大效果：当您放大时，您实际上是在增加对象的尺寸，在屏幕上占用更多像素。例如，如果将上述对象放大两倍，它现在将占据 200x200 像素的空间。尽管每个像素的物理尺寸（如屏幕的像素尺寸）实际上并未变化，但是现在它们代表的物体相对于初始尺寸的物理长度减少了。在屏幕上，单个像素现在表示对象更小的一部分，因为需要更多像素来显示相同的对象。</li><li>单位像素长度的变化：因此，放大实际上增加了表示同一对象的像素数量。单位像素长度 - 用来度量场景中对象的屏幕单位 - 实际上减少了，因为现在对象的每个单位被更多的像素所代表。</li></ul></li></ul><h3 id="锯齿化是怎么来的">锯齿化是怎么来的</h3><p>只要覆盖像素的中心，该像素就会被填充</p><p>比如我们要绘制的图形的点不是刚好在像素网格上</p><h3 id="抗锯齿处理">抗锯齿处理</h3><ul><li><p>用更高的分辨率，可用理解为本来只需要 4 个像素，现在我使用八个像素，然后用双线性插值处理得到最终结果<br>这个是有效的但是在性能上是会有浪费的，因为每个像素都需要*2 处理，着色器需要调用多次，但是其实只有边缘像素需要这样处理<br>多次调用着色器也是会浪费性能的</p></li><li><p>使用 MSAA<br>目前看上去就是减少调用着色器的次数，片元着色器的调用次数不变<br>其实就是再创建一个与要渲染画布同等大小的特殊纹理，渲染到这个纹理上，然后再渲染到我们想要的纹理上，也就是多处理一遍，注意这里有一个 resolveTarget</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>webgpu透明与混合</title>
    <link href="/2024/05/06/webgpu%E9%80%8F%E6%98%8E%E4%B8%8E%E6%B7%B7%E5%90%88/"/>
    <url>/2024/05/06/webgpu%E9%80%8F%E6%98%8E%E4%B8%8E%E6%B7%B7%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h2 id="预乘"><a href="#预乘" class="headerlink" title="预乘"></a>预乘</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">context.<span class="hljs-title function_">configure</span>(&#123;<br>device,<br><span class="hljs-attr">format</span>: presentationFormat,<br><span class="hljs-attr">alphaMode</span>: <span class="hljs-string">&#x27;premultiplied&#x27;</span>,<br>&#125;);<br></code></pre></td></tr></table></figure><p>前提：使用这个配置是为了让 webgpu 画布具有透明度，比如我们的画布可能有背景图片</p><p>使用上：<br>放入画布的值已经预乘过 alpha<br>也就是在着色器中的 color，rgb 需要预先乘 alpha</p><h2 id="discard"><a href="#discard" class="headerlink" title="discard"></a>discard</h2><p>不绘制像素</p><p>为什么要将透明度为 0 的元素进行不绘制像素， 因为如果绘制了这时候深度信息还是会写入，这时候就即使是透明的还是会挡住了</p><h2 id="混合方程"><a href="#混合方程" class="headerlink" title="混合方程"></a>混合方程</h2><p>这里像素颜色要区分为两种</p><ul><li>src 着色器当前返回的值 也就是我现在要绘制的颜色</li><li>dst 当前画布上这个位置目前已有的值，也就是当前画布上的颜色值</li></ul><p>混合方程的公式<br><code>result = operation((src * srcF),(dst * dstF))</code></p><h3 id="默认情况"><a href="#默认情况" class="headerlink" title="默认情况"></a>默认情况</h3><ul><li>operation:add</li><li>srcFactor:one</li><li>dstFactor:zero</li></ul><p>套用公式之后能明显看到其实也就是一个替换操作，新的替换旧的</p><h3 id="常数情况"><a href="#常数情况" class="headerlink" title="常数情况"></a>常数情况</h3><p>constant<br>one-minus-constant<br>是可以设置常量的，就象是设置模版缓冲值那样，在准备渲染管线编码器的时候使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> color = &#123; <span class="hljs-attr">r</span>: <span class="hljs-number">0.0</span>, <span class="hljs-attr">g</span>: <span class="hljs-number">0.5</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">1.0</span>, <span class="hljs-attr">a</span>: <span class="hljs-number">0.5</span> &#125;; <span class="hljs-comment">// 示例颜色和alpha值</span><br>encoder.<span class="hljs-title function_">setBlendConstant</span>(color);<br></code></pre></td></tr></table></figure><p>其实也就是一个固定值，套上公式的话也就是预乘一个固定颜色，看起来可以做颜色混合</p><h3 id="最常见的混合方式"><a href="#最常见的混合方式" class="headerlink" title="最常见的混合方式"></a>最常见的混合方式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> pipeline = device.<span class="hljs-title function_">createRenderPipeline</span>(&#123;<br><span class="hljs-comment">// 省略其他配置...</span><br><span class="hljs-attr">fragment</span>: &#123;<br><span class="hljs-comment">// 省略其他配置...</span><br><span class="hljs-attr">targets</span>: [<br>&#123;<br><span class="hljs-attr">format</span>: <span class="hljs-string">&#x27;bgra8unorm&#x27;</span>,<br><span class="hljs-attr">blend</span>: &#123;<br><span class="hljs-attr">color</span>: &#123;<br><span class="hljs-attr">srcFactor</span>: <span class="hljs-string">&#x27;src-alpha&#x27;</span>, <span class="hljs-comment">// 在这里可以配置预乘alpha</span><br><span class="hljs-attr">dstFactor</span>: <span class="hljs-string">&#x27;one-minus-src-alpha&#x27;</span>,<br><span class="hljs-attr">operation</span>: <span class="hljs-string">&#x27;add&#x27;</span>,<br>&#125;,<br><span class="hljs-attr">alpha</span>: &#123;<br><span class="hljs-attr">srcFactor</span>: <span class="hljs-string">&#x27;one&#x27;</span>,<br><span class="hljs-attr">dstFactor</span>: <span class="hljs-string">&#x27;one-minus-src-alpha&#x27;</span>,<br><span class="hljs-attr">operation</span>: <span class="hljs-string">&#x27;add&#x27;</span>,<br>&#125;,<br>&#125;,<br>&#125;,<br>],<br>&#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><p>举例：</p><ul><li>源颜色（Src）: { r: 0.2, g: 0.3, b: 0.4, a: 0.5 }</li><li>目标颜色（Dst）: { r: 0.5, g: 0.5, b: 0.5, a: 0.5 }</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">finalColor.<span class="hljs-property">rgb</span> = (<span class="hljs-number">0.2</span>, <span class="hljs-number">0.3</span>, <span class="hljs-number">0.4</span>) * <span class="hljs-number">0.5</span> + (<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>) * (<span class="hljs-number">1</span> - <span class="hljs-number">0.5</span>)<br>           = (<span class="hljs-number">0.1</span>, <span class="hljs-number">0.15</span>, <span class="hljs-number">0.2</span>) + (<span class="hljs-number">0.25</span>, <span class="hljs-number">0.25</span>, <span class="hljs-number">0.25</span>)<br>           = (<span class="hljs-number">0.35</span>, <span class="hljs-number">0.4</span>, <span class="hljs-number">0.45</span>)<br><br>finalColor.<span class="hljs-property">a</span> = <span class="hljs-number">0.5</span> * <span class="hljs-number">1</span> + <span class="hljs-number">0.5</span> * (<span class="hljs-number">1</span> - <span class="hljs-number">0.5</span>)<br>         = <span class="hljs-number">0.5</span> + <span class="hljs-number">0.25</span><br>         = <span class="hljs-number">0.75</span><br></code></pre></td></tr></table></figure><p>混合其实就是新的像素颜色和已有的像素颜色的一个关系问题</p><p>目前默认的业务场景就是源颜色覆盖目标颜色,也就是下面这种配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">blend</span>: &#123;<br>  <span class="hljs-attr">color</span>: &#123;<br>    <span class="hljs-attr">operation</span>: <span class="hljs-string">&#x27;add&#x27;</span>,<br>    <span class="hljs-attr">srcFactor</span>: <span class="hljs-string">&#x27;one&#x27;</span>, <span class="hljs-comment">// 这里是one还是src-alpha完全取决于是否需要预乘以及着色器的颜色输出是什么</span><br>    <span class="hljs-attr">dstFactor</span>: <span class="hljs-string">&#x27;one-minus-src-alpha&#x27;</span>,<br>  &#125;,<br>  <span class="hljs-attr">alpha</span>: &#123;<br>    <span class="hljs-attr">operation</span>: <span class="hljs-string">&#x27;add&#x27;</span>,<br>    <span class="hljs-attr">srcFactor</span>: <span class="hljs-string">&#x27;one&#x27;</span>,<br>    <span class="hljs-attr">dstFactor</span>: <span class="hljs-string">&#x27;one-minus-src-alpha&#x27;</span>,<br>  &#125;,<br>&#125;,<br></code></pre></td></tr></table></figure><p>这里我们需要知道的是混合是在片元着色器执行完毕并输出颜色之后，将颜色写入到画布之前执行的，也就是这是两个步骤</p>]]></content>
    
    
    
    <tags>
      
      <tag>webgpu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webgpu文档知识点</title>
    <link href="/2024/04/06/webgpu%E6%96%87%E6%A1%A3%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2024/04/06/webgpu%E6%96%87%E6%A1%A3%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="webgpu"><a href="#webgpu" class="headerlink" title="webgpu"></a>webgpu</h1><h2 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h2><p>三个顶点 绘制出一个三角形</p><h2 id="片元着色器"><a href="#片元着色器" class="headerlink" title="片元着色器"></a>片元着色器</h2><p>顶点之间的颜色处理</p><h2 id="计算着色器"><a href="#计算着色器" class="headerlink" title="计算着色器"></a>计算着色器</h2><p>就只是一个函数 我们来确认执行多少次</p><h2 id="inter-stage-变量"><a href="#inter-stage-变量" class="headerlink" title="inter-stage 变量"></a>inter-stage 变量</h2><p>也就是 wgsl 中的<br>location 可以理解为自己加上的变量 可以根据索引进行传递</p><p>builtin 内置变量</p><p>这里注意 position 顶点着色器输出的内置变量 position 和 片元着色器输入的 position 不是一个东西<br>输出一致 这样写只是方便</p><p>position 片元着色器的输入需要注意不是整数 这个像素点是中点是小数</p><h2 id="uniforms"><a href="#uniforms" class="headerlink" title="uniforms"></a>uniforms</h2><p>这里讲的 uniformsBuffer 的使用<br>需要注意一点的是<br>比如：当我 writeBuffer 完，这时候命令只会放到命令缓冲区中<br>遍历中会遇到这种情况</p><p>只有当我 finish 然后 submit 的时候才会真正执行</p><p>如果一个个创建命令缓冲区，然后再执行会很慢</p><p>最佳实践是在一个缓冲区内完成更多的工作</p><p>我们知道 buffer 是通过绑定组来进行使用的</p><p>我们只要把绑定关系处理对 然后再统一进行绘制就可以了</p><p>代码案例对应的就是我们业务代码中的动态绑定组</p><p>可以自由引用多个 uniform 缓冲区</p><p>我们把 uniforms 可以分为一次需要设置一次的 uniforms<br>和每次绘制都要更新的 uniforms 可以节约时间</p><h2 id="存储缓冲区"><a href="#存储缓冲区" class="headerlink" title="存储缓冲区"></a>存储缓冲区</h2><p>与 uniform 的区别<br>1、uniform 速度上可能更快<br>2、uniform 缓冲区很小，最大大小至少为 64kb，存储缓冲区最大大小至少为 128M<br>3、uniform 缓冲区只能读，存储缓冲区可读写</p><p>tips：通过存储缓冲区传递顶点的方式很受欢迎，不过听说在一些较老的设备上，这种方式比传统方式要慢</p><p>注意：颜色附件我们也可以有多个，location(1),location(2)</p><h2 id="顶点缓冲区"><a href="#顶点缓冲区" class="headerlink" title="顶点缓冲区"></a>顶点缓冲区</h2><p>也就是我们会有一个 buffer 来储存顶点信息<br>我们在创建渲染管道的时候就告诉 webgpu 如何从顶点 buffer 中获取顶点数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">vertex</span>:&#123;<br>  <span class="hljs-attr">buffers</span>:[&#123;<br>      <span class="hljs-attr">arrayStride</span>: <span class="hljs-number">2</span> * <span class="hljs-number">4</span>, <span class="hljs-comment">// 一个顶点所需要的数据字节长度</span><br>      <span class="hljs-attr">stepMode</span>:<span class="hljs-string">&#x27;instance&#x27;</span>, <span class="hljs-comment">// 属性在每个实例中只会前进一次到下一个值，默认是vertex</span><br>      <span class="hljs-comment">// 这里就是描述的每一个顶点数据是如何进行拆分</span><br>      <span class="hljs-attr">attributes</span>:[<br>          <span class="hljs-attr">shaderLoaction</span>: <span class="hljs-number">0</span>, <span class="hljs-comment">// 对应的是顶点着色器中输入的loction0</span><br>          <span class="hljs-attr">offset</span>:<span class="hljs-number">0</span>, <span class="hljs-comment">// 数据的偏移</span><br>          <span class="hljs-attr">format</span>:<span class="hljs-string">&#x27;float32x2&#x27;</span>, <span class="hljs-comment">// 数据的格式</span><br>      ]<br>  &#125;]<br>&#125;<br></code></pre></td></tr></table></figure><p>这里 wgsl 中的 stuct 中的格式和我们配置的格式是可以不一致的，但还是一致比较好，因为属性在着色器中始终有 4 个值<br>0，0，0，1；</p><p>tips：归一化可以节约空间</p><h2 id="索引缓冲区"><a href="#索引缓冲区" class="headerlink" title="索引缓冲区"></a>索引缓冲区</h2><p>也是可以用来节约内存空间，用于处理顶点数据的顺序<br>@builtin(vertex_index)跟索引缓冲区的索引一致</p><h2 id="constant"><a href="#constant" class="headerlink" title="constant"></a>constant</h2><p>常量<br>wgsl 中可以用 override 来描述</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs wgsl">override red = 0.0;<br>override green = 0.0;<br></code></pre></td></tr></table></figure><p>在创建渲染管线的时候我们能够直接进行覆盖<br>注意这里是区分着色器的 每个着色器需要的话都要添加常量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">fragment</span>: &#123;<br>    <span class="hljs-attr">constants</span>: &#123;<br>        <span class="hljs-attr">red</span>:<span class="hljs-number">1</span>,<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>常量只能用标量值，也就是布尔，整数，浮点数，不能是向量或者矩阵</p><p>如果不指定值，还可以使用数字 id</p><p>@id(123) override green &#x3D; 0.0</p><p>跟我直接用 const 定义常量的区别是？</p><p>就是可以定义好着色器模块之后再通过管道来重新覆盖，这样会更快</p><p><a href="https://webgpufundamentals.org/webgpu/lessons/webgpu-constants.html">https://webgpufundamentals.org/webgpu/lessons/webgpu-constants.html</a></p><h2 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h2><p>纹理就是一个二维数组，值为颜色值</p><p>纹理跟存储缓冲区的区别在于，纹理可以被采样器采样，这个采样器是内置的</p><p>uv 坐标 也就是 webgpu 中的纹理坐标系统，我们可以看到 0，0 对应的是左下角的坐标<br><img src="/2024/04/06/webgpu%E6%96%87%E6%A1%A3%E7%9F%A5%E8%AF%86%E7%82%B9/2024-04-06-23-52-11.png"></p><p>而对于我们常见的图片格式，（0，0）点的坐标实际上是位于左上角，所以才会需要进行翻转处理</p><p>两种方式</p><ul><li>一种是在着色器中改变纹理的坐标 拿 1 减一下 y 坐标</li><li>二是直接反转一下纹理数据</li></ul><p>纹理还没看完 后面还有</p><h2 id="透明度和混合"><a href="#透明度和混合" class="headerlink" title="透明度和混合"></a>透明度和混合</h2><p>webgpu canvas 画布是可以选择是否开启透明度</p><p>默认是 <code>opaque</code> 也就是不透明</p><p>设置 alphaMode 为’premultiplied’ 则是开启这个配置</p><p>这个配置意味着</p><p>绘制到画布上的颜色已经乘了 alpha 值</p><p><img src="/2024/04/06/webgpu%E6%96%87%E6%A1%A3%E7%9F%A5%E8%AF%86%E7%82%B9/2024-04-08-23-40-47.png"></p><p>在 webgpu 中，当使用 premultiplied 模式渲染时，你需要确保在着色器中输出的颜色是预乘透明度值后的颜色</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 假设我们有一个vec3类型的颜色变量，表示不透明的颜色值</span><br>vec3 color = <span class="hljs-title function_">vec3</span>(<span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>); <span class="hljs-comment">// 纯红色</span><br><span class="hljs-comment">// 现在我们定义一个固定透明度值</span><br>float alpha = <span class="hljs-number">0.5</span>;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 输出预乘后的颜色</span><br>    gl_FragColor = <span class="hljs-title function_">vec4</span>(color * alpha, alpha);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>坐标系之间的转换</title>
    <link href="/2024/03/17/%E5%9D%90%E6%A0%87%E7%B3%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/"/>
    <url>/2024/03/17/%E5%9D%90%E6%A0%87%E7%B3%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<p><img src="/2024/03/17/%E5%9D%90%E6%A0%87%E7%B3%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/2024-03-17-23-32-23.png"></p><p>注意转换的方式，我们可以以 0 来作为参考</p><p>业务中也就是把 canvas 的坐标转换到 webgl 坐标</p><p><img src="/2024/03/17/%E5%9D%90%E6%A0%87%E7%B3%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/2024-03-17-23-37-50.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>向量的计算</title>
    <link href="/2024/03/03/%E5%90%91%E9%87%8F%E7%9A%84%E8%AE%A1%E7%AE%97/"/>
    <url>/2024/03/03/%E5%90%91%E9%87%8F%E7%9A%84%E8%AE%A1%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<p><a href="https://aodazhang.com/glsl/#%E7%9F%A9%E9%98%B5%E7%B1%BB%E5%9E%8B">https://aodazhang.com/glsl/#矩阵类型</a></p><h2 id="wgsl-中矩阵是列主序的">wgsl 中矩阵是列主序的</h2><p><img src="/2024/03/03/%E5%90%91%E9%87%8F%E7%9A%84%E8%AE%A1%E7%AE%97/2024-03-02-22-27-27.png" alt></p><h2 id="计算呈现">计算呈现</h2><p><img src="/2024/03/03/%E5%90%91%E9%87%8F%E7%9A%84%E8%AE%A1%E7%AE%97/2024-03-02-22-28-12.png" alt></p><p>首先我们要知道在 opengl 中矩阵我们采用的都是列主序</p><p><img src="/2024/03/03/%E5%90%91%E9%87%8F%E7%9A%84%E8%AE%A1%E7%AE%97/2024-03-03-11-07-22.png" alt></p><p>所以上面的例子我们会得到这样的数据<br>同时在 opengl 中矩阵的运算顺序是从右向左读</p><p>对于矩阵的乘法</p><p><a href="https://www.ruanyifeng.com/blog/2015/09/matrix-multiplication.html">https://www.ruanyifeng.com/blog/2015/09/matrix-multiplication.html</a></p><p><img src="/2024/03/03/%E5%90%91%E9%87%8F%E7%9A%84%E8%AE%A1%E7%AE%97/2024-03-03-11-14-05.png" alt></p><p>仅仅从计算的角度</p><p>我们能得到 也就是列乘行</p><p>1*[1,3] + 2*[2*4]<br>= [1,3] + [4,8]<br>= [5,11]</p><h2 id="列主序的运算">列主序的运算</h2><p><a href="https://www.stubbornhuang.com/771/">https://www.stubbornhuang.com/771/</a></p><p><a href="https://learnopengl-cn.readthedocs.io/zh/latest/01%20Getting%20started/07%20Transformations/#_10">https://learnopengl-cn.readthedocs.io/zh/latest/01 Getting started/07 Transformations/#_10</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>渲染管道</title>
    <link href="/2024/02/28/%E6%B8%B2%E6%9F%93%E7%AE%A1%E9%81%93/"/>
    <url>/2024/02/28/%E6%B8%B2%E6%9F%93%E7%AE%A1%E9%81%93/</url>
    
    <content type="html"><![CDATA[<h1 id="webGpu-渲染管道"><a href="#webGpu-渲染管道" class="headerlink" title="webGpu 渲染管道"></a>webGpu 渲染管道</h1><p>主要是记录一些里面的配置项</p><h2 id="混合"><a href="#混合" class="headerlink" title="混合"></a>混合</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 注意 我们的着色器和layout都是写在渲染管道里面的</span><br><span class="hljs-keyword">const</span> pipeline = device.<span class="hljs-title function_">createRenderPipeline</span>(&#123;<br><span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;hardcoded textured quad pipeline&#x27;</span>,<br><span class="hljs-attr">layout</span>: pipelineLayout,<br><span class="hljs-attr">vertex</span>: &#123;<br><span class="hljs-variable language_">module</span>,<br><span class="hljs-attr">entryPoint</span>: <span class="hljs-string">&#x27;vs&#x27;</span>,<br>&#125;,<br><span class="hljs-comment">// 注意混合是在片元着色器里面的</span><br><span class="hljs-attr">fragment</span>: &#123;<br><span class="hljs-variable language_">module</span>,<br><span class="hljs-attr">entryPoint</span>: <span class="hljs-string">&#x27;fs&#x27;</span>,<br><span class="hljs-comment">// targets实际上可以理解为绘制区域的画布</span><br><span class="hljs-comment">// 混合的结果公式如下，src上片元着色器返回的值，dst还不太清楚，翻译写的是正在绘制的纹理的已有值</span><br><span class="hljs-comment">// result = operation((src * srcFactor),  (dst * dstFactor))</span><br><span class="hljs-comment">// 例如：operation is &#x27;add&#x27;, srcFactor is &#x27;one&#x27; and dstFactor is &#x27;zero&#x27;</span><br><span class="hljs-comment">// result = add((src * 1), (dst * 0))</span><br><span class="hljs-attr">targets</span>: [<br>&#123;<br><span class="hljs-attr">format</span>: presentationFormat,<br><span class="hljs-attr">blend</span>: &#123;<br><span class="hljs-comment">// rgb部分的设置</span><br><span class="hljs-attr">color</span>: &#123;<br><span class="hljs-attr">operation</span>: <span class="hljs-string">&#x27;add&#x27;</span>,<br><span class="hljs-attr">srcFactor</span>: <span class="hljs-string">&#x27;one&#x27;</span>,<br><span class="hljs-attr">dstFactor</span>: <span class="hljs-string">&#x27;one-minus-src-alpha&#x27;</span>,<br>&#125;,<br><span class="hljs-comment">// alpha部分的设置</span><br><span class="hljs-attr">alpha</span>: &#123;<br><span class="hljs-attr">operation</span>: <span class="hljs-string">&#x27;add&#x27;</span>,<br><span class="hljs-attr">srcFactor</span>: <span class="hljs-string">&#x27;one&#x27;</span>,<br><span class="hljs-attr">dstFactor</span>: <span class="hljs-string">&#x27;one-minus-src-aplha&#x27;</span>,<br>&#125;,<br>&#125;,<br>&#125;,<br>],<br>&#125;,<br>&#125;);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>模版测试/深度测试</title>
    <link href="/2024/02/25/%E6%A8%A1%E7%89%88%E6%B5%8B%E8%AF%95-%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/"/>
    <url>/2024/02/25/%E6%A8%A1%E7%89%88%E6%B5%8B%E8%AF%95-%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h2 id="模版测试"><a href="#模版测试" class="headerlink" title="模版测试"></a>模版测试</h2><p>指定区域渲染</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 清除着色器与深度缓冲</span><br><span class="hljs-title function_">clear</span>(gl.<span class="hljs-property">COLOR_BUFFER_BIT</span> | gl.<span class="hljs-property">DEPTH_BUFFER_BIT</span>);<br><span class="hljs-comment">// 清除模板缓冲</span><br><span class="hljs-title function_">clear</span>(gl.<span class="hljs-property">STENCIL_BUFFER_BIT</span>);<br><span class="hljs-comment">// 关闭深度测试</span><br><span class="hljs-title function_">disable</span>(gl.<span class="hljs-property">DEPTH_TEST</span>);<br><span class="hljs-comment">// 允许模板测试</span><br><span class="hljs-title function_">enable</span>(gl.<span class="hljs-property">STENCIL_TEST</span>);<br><span class="hljs-comment">// 设置模版测试参数</span><br><span class="hljs-title function_">stencilFunc</span>(gl.<span class="hljs-property">ALWAYS</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br><span class="hljs-comment">// 设置模版测试后的操作</span><br>gl.<span class="hljs-title function_">stencilOp</span>(gl.<span class="hljs-property">KEEP</span>, gl.<span class="hljs-property">KEEP</span>, gl.<span class="hljs-property">REPLACE</span>);<br></code></pre></td></tr></table></figure><p>模版缓冲区是一个 buffer</p><p>这个 buffer 为每个 fragment 提供 8 位的存储空间，</p><p>可以理解为每个像素块里面能存一个字节的数字，最多可以存储 256 个不同的数值</p><p>对于简单的模型裁剪效果，1 跟 0 就足够了</p><h2 id="gl-stencilFunc"><a href="#gl-stencilFunc" class="headerlink" title="gl.stencilFunc"></a>gl.stencilFunc</h2><p>控制模版测试的方法，也就是怎么样才能通过测试</p><p>三个参数</p><ul><li><p>第一个参数设置比较条件</p><ul><li>always</li><li>less</li></ul></li><li><p>第二个参数用于测试的参考值</p></li><li><p>第三个参数是指定操作的掩码<br>会先将第二个参数和当前参数进行与运算，最后将两个结果进行比较，比较的方式就是第一个参数指定的</p></li></ul><h2 id="gl-stencilOp"><a href="#gl-stencilOp" class="headerlink" title="gl.stencilOp"></a>gl.stencilOp</h2><p>指定通过测试和未通过测试时要怎么处理</p><p>stencilOp(fail, zfail, zpass)</p><p>三个参数</p><ul><li>模版测试未通过时的行为</li><li>模版测试通过但是深度测试未通过时的行为</li><li>模版测试通过且深度测试也通过时的行为，或者当模版测试通过且深度测试并没有开启的行为</li></ul><h2 id="glStencilMask"><a href="#glStencilMask" class="headerlink" title="glStencilMask"></a>glStencilMask</h2><p>模板掩码</p><ul><li>0xFF 每一位写入模版缓冲时都保持原样</li><li>0x00 每一位在写入模版缓冲的时候都会变成 0（禁用写入）</li></ul><p><a href="https://www.bilibili.com/read/cv23430911/">https://www.bilibili.com/read/cv23430911/</a></p><p>对于模版缓冲的使用大致步骤：</p><ul><li>启用模板缓冲的写入</li><li>渲染物体，更新模板缓冲的内容</li><li>禁用模板缓冲的写入</li><li>渲染（其它）物体，这次根据模板缓冲的内容丢弃特定的片段。</li></ul><p>也就是我需要创建一个模版缓冲 buffer，然后我需要往这个 buffer 里面写入内容，但是我不进行绘制，然后渲染其他物体根据我已有的模版缓冲内容丢弃特定的片段</p><h2 id="三角形的正面和反面"><a href="#三角形的正面和反面" class="headerlink" title="三角形的正面和反面"></a>三角形的正面和反面</h2><p>wegl 的图元就只有点&#x2F;线&#x2F;三角形</p><ul><li>三角形<br>复杂图形都是有三角形组成的</li><li>直线</li><li>点<br><a href="https://zhuanlan.zhihu.com/p/535433259">https://zhuanlan.zhihu.com/p/535433259</a></li></ul><h2 id="深度测试"><a href="#深度测试" class="headerlink" title="深度测试"></a>深度测试</h2><p>先进行模版测试，再进行深度测试</p><p>深度测试也是一样的，存在深度缓冲区</p><p><a href="https://zhuanlan.zhihu.com/p/529965155">https://zhuanlan.zhihu.com/p/529965155</a></p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p><a href="http://bingqx.cn/post/WebGPU%E5%AD%A6%E4%B9%A0%EF%BC%885%EF%BC%89---%E4%BD%BF%E7%94%A8%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95%E5%92%8C%E7%BA%B9%E7%90%86">http://bingqx.cn/post/WebGPU%E5%AD%A6%E4%B9%A0%EF%BC%885%EF%BC%89---%E4%BD%BF%E7%94%A8%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95%E5%92%8C%E7%BA%B9%E7%90%86</a></p><p><a href="https://zhuanlan.zhihu.com/p/438468463">https://zhuanlan.zhihu.com/p/438468463</a></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>简单来说就是进行两次渲染</p><ul><li><p>第一次就专门用来写入模版值，关闭颜色的写入<br>这里比较重点需要理解的地方</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//将三角区域模板值写入1</span><br>passEncoder.<span class="hljs-title function_">setStencilReference</span>(<span class="hljs-number">1</span>);<br><span class="hljs-comment">// createRenderPipeline 渲染管道的设置</span><br><span class="hljs-keyword">const</span> pipelineWriteMask = device.<span class="hljs-title function_">createRenderPipeline</span>(&#123;<br><span class="hljs-attr">layout</span>: device.<span class="hljs-title function_">createPipelineLayout</span>(&#123;<br><span class="hljs-attr">bindGroupLayouts</span>: [uniformsBindGroupLayout],<br>&#125;),<br>...<br><span class="hljs-attr">fragment</span>: &#123;<br><span class="hljs-attr">module</span>: device.<span class="hljs-title function_">createShaderModule</span>(&#123;<br><span class="hljs-attr">code</span>: basicFragWGSL,<br>&#125;),<br><span class="hljs-attr">entryPoint</span>: <span class="hljs-string">&#x27;main&#x27;</span>,<br><span class="hljs-attr">targets</span>: [<br>&#123;<br><span class="hljs-attr">format</span>: presentationFormat,<br><span class="hljs-attr">writeMask</span>: <span class="hljs-number">0x00</span>, <span class="hljs-comment">//关闭color写入</span><br>&#125;,<br>],<br>&#125;,<br>  ...<br><span class="hljs-attr">depthStencil</span>: &#123;<br><span class="hljs-attr">depthWriteEnabled</span>: <span class="hljs-literal">true</span>,<br><span class="hljs-attr">depthCompare</span>: <span class="hljs-string">&#x27;always&#x27;</span>,<br><span class="hljs-attr">format</span>: <span class="hljs-string">&#x27;depth24plus-stencil8&#x27;</span>,<br><span class="hljs-attr">stencilFront</span>: &#123;<br><span class="hljs-attr">compare</span>: <span class="hljs-string">&#x27;always&#x27;</span>,<br><span class="hljs-attr">failOp</span>: <span class="hljs-string">&#x27;keep&#x27;</span>,<br><span class="hljs-attr">depthFailOp</span>: <span class="hljs-string">&#x27;keep&#x27;</span>,<br><span class="hljs-attr">passOp</span>: <span class="hljs-string">&#x27;replace&#x27;</span>,<br>&#125;,<br><span class="hljs-attr">stencilBack</span>: &#123;<br><span class="hljs-attr">compare</span>: <span class="hljs-string">&#x27;always&#x27;</span>,<br><span class="hljs-attr">failOp</span>: <span class="hljs-string">&#x27;keep&#x27;</span>,<br><span class="hljs-attr">depthFailOp</span>: <span class="hljs-string">&#x27;keep&#x27;</span>,<br><span class="hljs-attr">passOp</span>: <span class="hljs-string">&#x27;replace&#x27;</span>,<br>&#125;,<br>&#125;,<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p>第二次渲染就根据模版值来进行比较判断</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 待确认</span><br>passEncoder.<span class="hljs-title function_">setStencilReference</span>(<span class="hljs-number">0</span>);<br><span class="hljs-comment">// 渲染管道</span><br><span class="hljs-keyword">const</span> pipelineUseMask = device.<span class="hljs-title function_">createRenderPipeline</span>(&#123;<br><span class="hljs-attr">layout</span>: device.<span class="hljs-title function_">createPipelineLayout</span>(&#123;<br><span class="hljs-attr">bindGroupLayouts</span>: [uniformsBindGroupLayout1],<br>&#125;),<br>  ...<br><span class="hljs-attr">fragment</span>: &#123;<br><span class="hljs-attr">module</span>: device.<span class="hljs-title function_">createShaderModule</span>(&#123;<br><span class="hljs-attr">code</span>: basicFragWGSL,<br>&#125;),<br><span class="hljs-attr">entryPoint</span>: <span class="hljs-string">&#x27;main&#x27;</span>,<br><span class="hljs-attr">targets</span>: [<br>&#123;<br><span class="hljs-attr">format</span>: presentationFormat,<br>&#125;,<br>],<br>&#125;,<br>...<br><span class="hljs-attr">depthStencil</span>: &#123;<br><span class="hljs-attr">depthWriteEnabled</span>: <span class="hljs-literal">false</span>,<br><span class="hljs-attr">depthCompare</span>: <span class="hljs-string">&#x27;always&#x27;</span>,<br><span class="hljs-attr">format</span>: <span class="hljs-string">&#x27;depth24plus-stencil8&#x27;</span>,<br><span class="hljs-attr">stencilFront</span>: &#123;<br><span class="hljs-attr">compare</span>: <span class="hljs-string">&#x27;equal&#x27;</span>,<br>&#125;,<br><span class="hljs-attr">stencilBack</span>: &#123;<br><span class="hljs-attr">compare</span>: <span class="hljs-string">&#x27;equal&#x27;</span>,<br>&#125;,<br>&#125;,<br>&#125;);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>webgpu绘制流程</title>
    <link href="/2024/02/20/webgpu%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/"/>
    <url>/2024/02/20/webgpu%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="webgpu-绘制流程"><a href="#webgpu-绘制流程" class="headerlink" title="webgpu 绘制流程"></a>webgpu 绘制流程</h1><p>首先我们需要<code>canvas</code>需要一块画布</p><p>我们使用 webgpu 的 api，需要请求一个适配器(adapter),然后从适配器中请求一个设备（device）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> adapter = <span class="hljs-keyword">await</span> navigator?.<span class="hljs-property">gpu</span>?.<span class="hljs-title function_">requestAdapter</span>();<br><span class="hljs-keyword">const</span> device = <span class="hljs-keyword">await</span> adapter?.<span class="hljs-title function_">requestDevice</span>();<br><span class="hljs-keyword">if</span> (!device) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们需要找到我们的画布，创建 webgpu 上下文</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> canvas = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;canvas&#x27;</span>);<br><span class="hljs-comment">// 获取webgpu上下文</span><br><span class="hljs-keyword">const</span> context = canvas.<span class="hljs-title function_">getContext</span>(<span class="hljs-string">&#x27;webgpu&#x27;</span>);<br><span class="hljs-comment">// 询问系统的首选画布格式是什么 可能是rgba8unorm</span><br><span class="hljs-keyword">const</span> persentationFormat = navigator.<span class="hljs-property">gpu</span>.<span class="hljs-title function_">getPreferredCanvasFormat</span>();<br><span class="hljs-comment">// 配置到webgpu上下文，把device也传入画布，将device与画布关联起来</span><br>context.<span class="hljs-title function_">configure</span>(&#123;<br>device,<br><span class="hljs-attr">format</span>: persentationFormat,<br>&#125;);<br></code></pre></td></tr></table></figure><p>创建一个着色器模块，包括定点着色器和片段着色器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-variable language_">module</span> = device.<span class="hljs-title function_">createShaderModule</span>(&#123;<br><span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;our module&#x27;</span>,<br><span class="hljs-attr">code</span>: <span class="hljs-string">``</span>,<br>&#125;);<br></code></pre></td></tr></table></figure><p>创建一个渲染管道</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> pipeline = device.<span class="hljs-title function_">createRenderPipeline</span>(&#123;<br><span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;our pipeline&#x27;</span>,<br><span class="hljs-attr">layout</span>: <span class="hljs-string">&#x27;auto&#x27;</span>, <span class="hljs-comment">// 要求webgpu从着色器中推断出数据布局</span><br><span class="hljs-comment">// 使用的顶点着色器</span><br><span class="hljs-attr">vertex</span>: &#123;<br><span class="hljs-variable language_">module</span>,<br><span class="hljs-attr">entryPoint</span>: <span class="hljs-string">&#x27;vs&#x27;</span>, <span class="hljs-comment">// 使用的是哪个函数</span><br>&#125;,<br><span class="hljs-attr">fragment</span>: &#123;<br><span class="hljs-variable language_">module</span>,<br><span class="hljs-attr">entryPoint</span>: <span class="hljs-string">&#x27;fs&#x27;</span>,<br><span class="hljs-comment">// 渲染目标的格式</span><br><span class="hljs-attr">targets</span>: [&#123; <span class="hljs-attr">format</span>: presentationFormat &#125;],<br>&#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><p>准备一个渲染通道描述，描述我们要绘制的纹理和如何使用（我们往 canvas 画布上绘制其实就可以理解为在往画布上绘制纹理）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> renderPassDescriptor = &#123;<br><span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;our basic canvas renderpass&#x27;</span>,<br>    <span class="hljs-comment">// 用于存储（或者临时存储图像信息）我们通常只会把渲染通道的结果存成一份，也就是只渲染到一个目标中，但是在某些高级渲染技巧中，我们需要把渲染结果储存成多份，也就是渲染到多个目标上，因此类型是一个数组。</span><br><span class="hljs-attr">colorAttachments</span>: [<br>&#123;<br><span class="hljs-comment">// view:绘制时填充</span><br>            clearValue：[<span class="hljs-number">0.3</span>,<span class="hljs-number">0.3</span>,<span class="hljs-number">0.3</span>,<span class="hljs-number">1</span>];<br>            <span class="hljs-attr">loadOp</span>:<span class="hljs-string">&#x27;clear&#x27;</span> | <span class="hljs-string">&#x27;load&#x27;</span>, <span class="hljs-comment">// 在绘制前清除｜在已有内容上绘图</span><br>            <span class="hljs-attr">storeOp</span>:<span class="hljs-string">&#x27;store&#x27;</span> | <span class="hljs-string">&#x27;discard&#x27;</span>, <span class="hljs-comment">// 存储结果/丢弃结果</span><br>&#125;,<br>],<br>&#125;;<br><br><span class="hljs-comment">// https://www.51cto.com/article/698100.html</span><br></code></pre></td></tr></table></figure><p>准备就绪进入渲染流程</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-comment">// 从画布上下文中获取纹理，并将其设置为需要渲染的纹理，也就是指定需要渲染的目标，</span><br>renderPassDescriptor.<span class="hljs-property">colorAttachments</span>[<span class="hljs-number">0</span>].<span class="hljs-property">view</span> = context.<span class="hljs-title function_">getCurrentTexture</span>();<br><br><span class="hljs-comment">// 创建一个编码器</span><br><span class="hljs-keyword">const</span> encoder = device.<span class="hljs-title function_">createCommandEncoder</span>(&#123; <span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;our encoder&#x27;</span> &#125;);<br><span class="hljs-comment">// 进行编码</span><br><span class="hljs-comment">// 开启一个渲染通道，告诉它我们要渲染到哪个纹理</span><br><span class="hljs-keyword">const</span> pass = encoder.<span class="hljs-title function_">beginRenderPass</span>(renderPassDescriptor);<br><span class="hljs-comment">// 配置渲染管道</span><br>pass.<span class="hljs-title function_">setPipeline</span>(pipeline);<br><span class="hljs-comment">// 执行顶点着色器三次，默认情况下每执行三次就会通过连接顶点着色器返回到3个值来绘制一个三角形</span><br><span class="hljs-comment">// 这里我们每次</span><br>pass.<span class="hljs-title function_">draw</span>(<span class="hljs-number">3</span>);<br>pass.<span class="hljs-title function_">end</span>();<br><br><span class="hljs-keyword">const</span> commandBuffer = encoder.<span class="hljs-title function_">finish</span>();<br>device.<span class="hljs-property">queue</span>.<span class="hljs-title function_">submit</span>([commandBuffer]);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>位运算的使用</title>
    <link href="/2024/02/14/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/02/14/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="位运算的使用"><a href="#位运算的使用" class="headerlink" title="位运算的使用"></a>位运算的使用</h1><h2 id="按位非（-）"><a href="#按位非（-）" class="headerlink" title="按位非（~）"></a>按位非（~）</h2><p>这个就是 0 变 1，1 变 0<br>得到的结果就是 <code>-val -1</code></p><p><img src="/2024/02/14/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E4%BD%BF%E7%94%A8/2024-02-14-12-53-07.png"></p><p>使用场景：</p><ul><li>求相反数 ~a+1<br><img src="/2024/02/14/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E4%BD%BF%E7%94%A8/2024-02-14-13-00-47.png"></li><li>双非位取整<br>原理：js 在进行位运算的时候会将 64 位转换为 32 位整数在进行处理，这个过程会忽略掉小数部分，只关注整数<br><code>~~3.14 == 3</code></li></ul><h2 id="左移"><a href="#左移" class="headerlink" title="&lt;&lt; 左移"></a>&lt;&lt; 左移</h2><p>整体左移<br><code>6 &lt;&lt; 2 = 24</code><br>这里其实就是<code>val * 2^n</code><br>使用场景: 就是做*2^n 的运算，位运算的效率更高<br><img src="/2024/02/14/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E4%BD%BF%E7%94%A8/2024-02-14-15-25-00.png"></p><h2 id="右移"><a href="#右移" class="headerlink" title="&gt;&gt; 右移"></a>&gt;&gt; 右移</h2><p>这里是有符号的右移</p><p>和左移相反，这里是整体向右边移动<br>这里需要注意的</p><p>如果是正数，右移之后补 0<br>如果是负数，右移之后是补一<br>这里还有需要注意的 低位是在右边，和基础数值一致</p><p><img src="/2024/02/14/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E4%BD%BF%E7%94%A8/2024-02-14-15-28-41.png"></p><p><img src="/2024/02/14/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E4%BD%BF%E7%94%A8/2024-02-14-15-29-05.png"></p><p>使用场景：这里就是做 &#x2F;2^n 的运算,注意这里会向下取整<br><img src="/2024/02/14/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E4%BD%BF%E7%94%A8/2024-02-14-17-28-31.png"></p><p>左移动和右移需要注意长度限制，实际的位移只能在 0-31 之间，第 31 位是符号位</p><h2 id="按位与（-）"><a href="#按位与（-）" class="headerlink" title="按位与（&amp;）"></a>按位与（&amp;）</h2><p>11 为 1 , 其他都为 0</p><p>使用场景：</p><ul><li>清零 与 0 进行位运算结果为 0</li><li>判断整数的奇偶性，对于二进制数而言，偶数的末尾一定是 0，奇数的末尾一定是 1，与 1 进行按位与运算就能判断奇偶性</li><li>取一个二进制数的指定位，比如<br><img src="/2024/02/14/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E4%BD%BF%E7%94%A8/2024-02-14-18-40-55.png"></li><li>与右移混合使用获取二进制数的某一位,获取 a 的第 b 位<br><code>(a &gt;&gt; b) &amp; 1</code></li></ul><h2 id="按位或（｜）"><a href="#按位或（｜）" class="headerlink" title="按位或（｜）"></a>按位或（｜）</h2><p>有 1 则为 1<br>使用场景：</p><ul><li>将指定位值设置为 1，与上面的与运算类似，只是改为或运算</li><li>取整, 这里需要注意，这里其实是向 0 取整，对于正数是向下取整，对于负数是取绝对值再做向下取整<br>简单理解我们可以理解为就是不要小数部分了<br><img src="/2024-02-15-15-36-08.png"></li></ul><h2 id="按位异或（-）"><a href="#按位异或（-）" class="headerlink" title="按位异或（^）"></a>按位异或（^）</h2><p>相同为 0，不同为 1</p><p>使用场景：</p><ul><li>进行变量交换</li><li>最后一位取反：X^1</li><li>判断两个整数是否相等</li></ul><p>牢记位操作操作的实际上是整数</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://juejin.cn/post/6900710763657166855">https://juejin.cn/post/6900710763657166855</a></p><p><a href="https://algo.itcharge.cn/09.Algorithm-Base/06.Bit-Operation/01.Bit-Operation/#_3-2-%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93">https://algo.itcharge.cn/09.Algorithm-Base/06.Bit-Operation/01.Bit-Operation/#_3-2-%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93</a></p><p><a href="https://www.cnblogs.com/tinys-top/p/11648535.html">https://www.cnblogs.com/tinys-top/p/11648535.html</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>redbook</title>
    <link href="/2024/02/05/redbook/"/>
    <url>/2024/02/05/redbook/</url>
    
    <content type="html"><![CDATA[<h1 id="阅读红宝石书"><a href="#阅读红宝石书" class="headerlink" title="阅读红宝石书"></a>阅读红宝石书</h1><h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h2 id="脚本语言（script）"><a href="#脚本语言（script）" class="headerlink" title="脚本语言（script）"></a>脚本语言（script）</h2><p>就是解释性语言</p><ul><li>脚本语言 读一行，执行一行，运行到报错的地方才会报错</li><li>非脚本语言 需要读取所有代码进行编译（检查代码中的错误）通过后再进行执行</li></ul><h2 id="Javascript-实现"><a href="#Javascript-实现" class="headerlink" title="Javascript 实现"></a>Javascript 实现</h2><ul><li><p>核心（ECMAScript）</p><ul><li>由 ECMA-262 定义并提供核心功能<ul><li>语法</li><li>类型</li><li>语句</li><li>关键字</li><li>保留字</li><li>操作符</li><li>全局对象<br>举例：ES6 ECAMA-262 第 6 版</li></ul></li></ul></li><li><p>文档对象模型（DOM）<br>提供与网页内容交互的方法和接口</p><ul><li>DOM 将页面抽象成分层节点</li><li>使用 DOM API 可以轻松的删除、添加、替换、修改节点</li><li>有些语言发布了自己的 DOM 标准，增加了该语言独有的 DOM 方法和接口，比如 SVG；</li><li>鼠标事件等</li></ul></li><li><p>浏览器对象模型（BOM）<br>提供与浏览器交互的方法和接口</p><ul><li>用于访问和操作浏览器的窗口和子窗口（frame）<ul><li>弹出新浏览器窗口，window 对象</li><li>移动、缩放和关闭浏览器窗口</li><li>navigator 对象，提供关于浏览器的详尽信息</li><li>location 对象，提供浏览器加载页面的详尽信息</li></ul></li><li>javascript 版本 9<ul><li>screen 对象，提供关于用户屏幕分辨率的详尽信息；</li><li>performance 对象，提供浏览器内存占用、导航行为和时间统计的详尽信息</li><li>对 cookie 的支持</li></ul></li></ul></li></ul><h1 id="第二章-HTML-中的-JavaScript"><a href="#第二章-HTML-中的-JavaScript" class="headerlink" title="第二章 HTML 中的 JavaScript"></a>第二章 HTML 中的 JavaScript</h1><h2 id="元素"><a href="#元素" class="headerlink" title="&lt;script&gt;元素"></a><code>&lt;script&gt;</code>元素</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li>async 可选 只适用于外部文本，立即开始下载脚本，但不能阻止其他页面动作，比如下载资源</li><li>charset，代码字符集，基本上不是用，浏览器不在乎</li><li>crossorigin 跨域设置 默认不使用</li><li>defer 只对外部文件有效，脚本可延迟到文档解析和显示之后再执行</li><li>intergrity 对比接收到的资源和指定的加密签名，不匹配页面报错，脚本不会执行</li><li>language 废弃 例如：javascript 1.2</li><li>src 要执行代码的外部文件 url</li><li>type 代替 language，代表代码块中脚本语言的内容类型（MIME 类型），依照惯例：<code>text/javascript</code>,type 属性的值有可能导致脚本会忽略。比如 module，会被作为是 ES6 模块，最佳做法是不指定 type 属性，因为浏览器对 MIME 类型并么有标准化，可能会无法识别导致不执行脚本</li></ul><h4 id="async-和-defer-的区别"><a href="#async-和-defer-的区别" class="headerlink" title="async 和 defer 的区别"></a>async 和 defer 的区别</h4><p>defer 后的脚本也是顺序执行的，所以可能存在依赖关系<br>async 脚本它们直接没有依赖关系，目的是告诉浏览器，不必等待脚本下载和执行完成后再加载页面，也不用等待该异步脚本下载和执行完成后在加载其他脚本，异步脚本不应该在加载期间修改 DOM</p><h3 id="使用外部-javascript-代码的优点"><a href="#使用外部-javascript-代码的优点" class="headerlink" title="使用外部 javascript 代码的优点"></a>使用外部 javascript 代码的优点</h3><ul><li>可维护性 独立开发互不相扰</li><li>缓存 如果两个页面使用同一个 js 文件，该文件只需要下载一次，这里请求外部文件需要考虑的它们会占多少带宽，最佳实践是将功能划分得更轻量更独立；</li><li>适应未来，对兼容性的考虑，比如 XHTML 对于&lt;的处理</li></ul><h2 id="文档模式"><a href="#文档模式" class="headerlink" title="文档模式"></a>文档模式</h2><h3 id="元素-1"><a href="#元素-1" class="headerlink" title="&lt;noscript&gt;元素"></a><code>&lt;noscript&gt;</code>元素</h3><ul><li>浏览器不支持脚本</li><li>浏览器对脚本的支持被关闭</li></ul><h1 id="第三章-语言基础"><a href="#第三章-语言基础" class="headerlink" title="第三章 语言基础"></a>第三章 语言基础</h1><ul><li>语法</li><li>数据类型</li><li>流控制语句</li><li>理解函数</li></ul><h3 id="var"><a href="#var" class="headerlink" title="var"></a>var</h3><p>变量提升</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age);<br><span class="hljs-keyword">var</span> age = <span class="hljs-number">26</span>;<br>&#125;<br><span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><h3 id="let-声明"><a href="#let-声明" class="headerlink" title="let 声明"></a>let 声明</h3><h4 id="let-和-var-区别"><a href="#let-和-var-区别" class="headerlink" title="let 和 var 区别"></a>let 和 var 区别</h4><ul><li>let 声明范围是块作用域，var 声明的范围是函数作用域 , 也就是 let 的声明范围更小</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;aa&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name); <span class="hljs-comment">// aa</span><br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name); <span class="hljs-comment">// aa</span><br></code></pre></td></tr></table></figure><ul><li><p>let 不允许重复声明</p></li><li><p>let 声明的变量没有变量提升</p></li><li><p>全局声明与 var 关键字不同，使用 let 在全局声明中的变量不会变成 window 对象的属性</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;aa&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">name</span>);<br></code></pre></td></tr></table></figure><ul><li>for 循环中，var 声明的变量，保存的是循环退出之后的值，let 声明的变量，javascript 引擎在后台会为每个迭代循环声明一个新的迭代变量</li></ul><h3 id="const-声明"><a href="#const-声明" class="headerlink" title="const 声明"></a>const 声明</h3><p>声明变量时必须同时初始化变量</p><ul><li>不允许重复声明</li><li>声明的作用域也是块</li><li>注意，const 声明的限制只适用于它指向的变量的引用，也就是修改这个对象内部的属性并不违反 const 的限制</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> person = &#123;&#125;;<br>person.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;ma&#x27;</span>;<br></code></pre></td></tr></table></figure><ul><li>前面说到 let 声明的迭代变量是会递增的，所以不能用 const 来声明会被修改的迭代的变量，如果是不会被修改的变量那是可以的比如 for-of 和 for-in</li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="简单数据类型"><a href="#简单数据类型" class="headerlink" title="简单数据类型"></a>简单数据类型</h3><p><code>undefined、null、String、number、boolean、Symbol</code></p><p>现在还有 BigInt，表示任意大小的整数</p><h3 id="复杂数据类型"><a href="#复杂数据类型" class="headerlink" title="复杂数据类型"></a>复杂数据类型</h3><p><code>Object</code></p><h3 id="typeof-操作符"><a href="#typeof-操作符" class="headerlink" title="typeof 操作符"></a>typeof 操作符</h3><p>注意 typeof null 返回 object，因为特殊值 null 可以被认为是一个空对象的引用</p><h3 id="Null"><a href="#Null" class="headerlink" title="Null"></a>Null</h3><p>逻辑上讲，null 值表示一个空指针对象</p><p>undefined 值是由 null 派生出来的，所以 ECMA-262 将它们定义为表面上相等<br><code>null == undefined // true</code></p><h3 id="Boolean-类型"><a href="#Boolean-类型" class="headerlink" title="Boolean 类型"></a>Boolean 类型</h3><p>布尔值不同于数值，因此 true 不等于 1 false 不等于 0</p><p>注意：if 等流控制语句会自动执行其他类型值到布尔值的转换</p><ul><li>String 类型 “” 空字符串会被转换为 false</li><li>Number 类型 0、NaN 会被转换为 fasle</li><li>Object 类型 null 会被转换为 fasle</li><li>Undefined 类型 false</li></ul><h3 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h3><p>基本的数值字面量是十进制的证书，整数也可以用八进制（以 8 为基数）或者十六进制字面量表示</p><ul><li>070 八进制的 56</li><li>0xA 10 十六进制的 10</li></ul><p>无效处理</p><p>079 &#x2F;&#x2F;无效的八进制数（0-7）会被认为是十进制</p><h4 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h4><p>存储浮点值使用的内存空间是存储整数值的两倍，所以 ECMAScript 会想方设法的把值转换为整数</p><ul><li><code>let floatNum1 = 1.</code> 小数点后面没有数字,当作整数 1 处理</li><li><code>let floatNum2 = 10.0</code> 小数点后面是零，当成整数 10 处理</li></ul><h5 id="浮点数的-IEEE764-标准"><a href="#浮点数的-IEEE764-标准" class="headerlink" title="浮点数的 IEEE764 标准"></a>浮点数的 IEEE764 标准</h5><p>0.1+0.2 !&#x3D;&#x3D; 0.3</p><p>对于 ECMAScript 中所有的数值都使用了 IEEE754 64 位格式进行存储</p><p>IEEE754 定义了在计算机中浮点数应采用科学计数法法的形式，存储于固定长度的存储单元</p><p>转换过程：</p><ul><li>1、将十进制数转换为二进制数，整数部分直接转为二进制数，小数部分在转换无法收敛的时候选取适当长度进行截断（精度丢失）</li><li>2、确定符号位，确定有效小数，确定指数（2*n 次幂）</li></ul><p><a href="https://fasionchan.com/posts/ieee754-traps/">https://fasionchan.com/posts/ieee754-traps/</a></p><h4 id="值的范围"><a href="#值的范围" class="headerlink" title="值的范围"></a>值的范围</h4><p>由于内存限制<br>将最大值和最小值存在<code>Number.MIN_VALUE/Number.MAX_VALUE</code>,</p><p>最大安全整数：Number.MAX_SAFE_INTEGER（2^53 - 1）<br>最小安全整数：Number.MIN_SAFE_INTEGER (-(2^53 - 1))</p><p>如果超出了 Javascript 可以表示的范围，这个数值会被自动转换为一个特殊的 Infinity，正负号分别表示正无穷和负无穷</p><p>注意，正无穷和负无穷不能再进一步用于计算</p><p>isFinite() 用于确定一个值是不是有限大,计算非常大或非常小的数值时，有必要检测一下计算结果是否超范围</p><p>在溢出时返回该值</p><ul><li><code>Number.NAGATIVE_INFINITY</code> 特殊的负无穷大值</li><li><code>Number.POSITIVE_INFINITY</code> 特殊的正无穷大值</li></ul><h4 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h4><p>Not a Number<br>用来表示本来要返回数值的操作失败了</p><p>注意 0&#x2F;0 -0 返回的是 NaN，0 作为分母是 infinity&#x2F;-infinity<br><img src="/2024/02/05/redbook/2024-02-08-00-20-30.png"></p><p>设计到 NaN 的操作始终返回 NaN<br>注意 NaN 不等于 NaN 在内的任何值</p><p><code>NaN == NaN</code> false</p><p>不能直接这样进行比较，所以提供了 isNaN()函数</p><p>接受任意参数，先尝试转换为数字，<br>注意 boolean true 可以转换为 0</p><p><img src="/2024/02/05/redbook/2024-02-08-00-42-58.png"></p><h4 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h4><ul><li><code>Number()</code><ul><li>布尔值 0 1</li><li>number 类型 直接返回</li><li>null 0</li><li>undefined 返回 NaN</li><li>字符串<ul><li><img src="/2024/02/05/redbook/2024-02-08-22-31-35.png"></li></ul></li><li>对象先调用 valueof()方法，以上述规则返回值，如果是 NaN，则调用 toString()方法<br>注意：一元加操作符与 Number()函数遵循相同的转换规则</li></ul></li><li><code>parseInt()</code><br>需要得到整数时使用<br><strong>从非空格字符串开始检测，直到检测到末尾或者碰到非数字字符</strong><br>parseInt 更关注于字符串是否包含数值模式<br><img src="/2024/02/05/redbook/2024-02-08-22-59-02.png"><br>有两个参数，第二个参数指定解析的进制数<br><img src="/2024/02/05/redbook/2024-02-08-23-20-41.png"><br>为了避免解析出错，建议始终传给它第二个参数</li><li><code>parseFloat()</code><br>工作方式和 parseInt 类似，注意只能解析十进制值，不能指定底数，也就是没有二个参数可以传递<br>区别：<ul><li>只有第一次出现的小数点是有效的</li><li>会忽略开头的 0,只能解析十进制数，所以传 0x 开头的数值只会返回 0</li></ul></li></ul><p><img src="/2024/02/05/redbook/2024-02-08-23-35-28.png"></p><h3 id="BigInt"><a href="#BigInt" class="headerlink" title="BigInt"></a>BigInt</h3><p>新增加的 BigInt<br>是一个内置对象，提供一种方法来表示任意大小的整数<br>注意：某些方面类似于 Number，不能使用 Math 对象中的方法，不能和任何 Number()实例混合运算，两者必须转换成同一类型，BigInt 变量转换成 Number 变量时可能会丢失精度</p><p>使用方法<br><img src="/2024/02/05/redbook/2024-02-15-15-07-59.png"></p><p>bigInt 是有符号的，所以不能用无符号右移，除法是向零取整</p><p>tips：向零取整也称为“截断取整”</p><ul><li>正数：取整数部分</li><li>负数：取其绝对值的整数部分添加负号</li></ul><p><img src="/2024/02/05/redbook/2024-02-15-15-16-04.png"></p><h3 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a>String 类型</h3><p>先要科普一下 Unicode</p><p>它为每种语言周末的字符设定了统一且唯一的二进制编码</p><p>简单来说就是把普通字符标准化了，这样就不会显示为乱码</p><p><a href="https://www.ruanyifeng.com/blog/2014/12/unicode.html">https://www.ruanyifeng.com/blog/2014/12/unicode.html</a></p><p><img src="/2024/02/05/redbook/2024-02-09-11-27-47.png"></p><p>注意：转义序列表示一个字符<br><code>&#39;\u03a3&#39;.length  // 1</code></p><p>双字节字符暂时还未讨论到，后面再看看</p><h4 id="字符串的特点"><a href="#字符串的特点" class="headerlink" title="字符串的特点"></a>字符串的特点</h4><p>不可变性，如果要更新字符串实际上是一个销毁之前的再重填的一个过程，当然这些处理是在后台发生的，所以早期浏览器在拼接字符串的时候非常慢，现在已经针对性的解决了这个问题</p><h4 id="转换为字符串"><a href="#转换为字符串" class="headerlink" title="转换为字符串"></a>转换为字符串</h4><ul><li>toString()<ul><li>字符串会返回自身的一个副本</li><li>null 和 undefined 没有 toString()方法，会产生报错<br>注意：如果 toString()的对象是 number 类型，我们可以使用传入参数（底数）来返回对应的进制数，其他对象不会有变化</li><li>Object 就直接返回’[object Object]’</li><li>数组会进行连接，相当于 Array.join（’,’）</li><li>NaN.toString() NaN</li></ul></li><li>String()<br>如果一个值不确定是不是 null 或 undefined 的时候，就是用 String()转型函数<br>区别:<ul><li>如果值存在 toString()方法，则直接调用，注意这里不会传参，所以做数值进制转换的时候还是应该用 toString()</li><li>像 null 和 undefined 没有 toString()方法的就直接返回字面量文本,’undefined’,’null’,</li></ul></li></ul><h6 id="模版字面量（模版字符串）"><a href="#模版字面量（模版字符串）" class="headerlink" title="模版字面量（模版字符串）"></a>模版字面量（模版字符串）</h6><p><img src="/2024/02/05/redbook/2024-02-09-15-36-21.png"></p><p>注意模版字符串的换行符是会保留的</p><p>字符串插值<code>$&#123;value&#125;11</code></p><p>所有被插入的值都会使用 toString()强制转型为字符串</p><p>也可以调用函数和方法</p><ul><li>标签函数<br>通过标签函数自定义插值行为<br>可以理解为你自己写一个函数来自定义插值行为<br><img src="/2024/02/05/redbook/2024-02-09-17-01-03.png"></li><li>String.raw<br>这就是一个内部定义好的标签函数，用于返回字符串的原始内容，比如有换行符啊，或者就是 Unicode 字符<br><img src="/2024/02/05/redbook/2024-02-09-17-08-15.png"></li></ul><h3 id="Symbol-类型"><a href="#Symbol-类型" class="headerlink" title="Symbol 类型"></a>Symbol 类型</h3><p>符号实例是唯一的、不可变的<br>用途：确保对象属性使用唯一标识符，不会发生属性冲突的危险<br>符号就是用来创建唯一记号，进而用作非字符串形式的对象属性</p><p>注意,可以传参，但是传参只是对当前字符串的描述，只是描述跟符号的定义或标识完全无关</p><p>注意，symbol()函数不能跟 new 关键字一起作为构造函数使用</p><ul><li>Symbol.for()<br>创建全局符号,传参的是字符串健<br>tips：幂等：多次执行的结果和只执行一次相等<br>Symbol.for(‘foo’),先去全局注册表里找有没有，不存在则创建，存在则直接返回对应的符号实例</li></ul><p><img src="/2024/02/05/redbook/2024-02-10-13-14-43.png"></p><p>传递给 symbol.for()的任何值都会被转换为字符串<br><img src="/2024/02/05/redbook/2024-02-10-13-18-54.png"></p><ul><li>Symbol.keyFor()<br>查询全局注册表（也就是查 Symbol.for 创建的符号），传参是符号，返回的是字符串键，传参有误会报错，找不到就是 undefined<br><img src="/2024/02/05/redbook/2024-02-10-13-34-43.png"></li></ul><h4 id="使用符号作为属性"><a href="#使用符号作为属性" class="headerlink" title="使用符号作为属性"></a>使用符号作为属性</h4><p>前面我们提到了，symbol 的用途是保证属性的唯一性,也就是作为对象的 key<br><img src="/2024/02/05/redbook/2024-02-10-15-27-14.png"><br>对于使用 symbol 作为属性的我们可以这样获取<br><img src="/2024/02/05/redbook/2024-02-10-15-36-01.png"><br>最好还是把 symbol 属性用变量存起来，不然便利的时候不好找</p><h4 id="内置的符号"><a href="#内置的符号" class="headerlink" title="内置的符号"></a>内置的符号</h4><p>最重要的用途：重新定义它们，从而改变原生结构的行为</p><p>其实也就是我告诉你我现在有这个属性，这个属性反正不能改，但是你可以去改变这个属性所关联的方法</p><p>反正就是一个 Symbol 属性，感觉就是一个特定的代号</p><ul><li><p>Symbol.iterator &#x2F;&#x2F; @@iterator<br>举例：我们知道 for-of 循环会在相关对象上使用 Symbol.iterator 属性，那么我们就可以去重写这个属性来改变 forof 迭代对象的行为</p></li><li><p>Symbol.asyncIterator<br>这个符号表示实现异步迭代器 API 函数<br>for-await-of<br>咱们直接看这个例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Emitter</span> &#123;<br><span class="hljs-title function_">constructor</span>(<span class="hljs-params">max</span>) &#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">max</span> = max;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">asyncIdx</span> = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">async</span> *[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]() &#123;<br><span class="hljs-keyword">while</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">asyncIdx</span> &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">max</span>) &#123;<br><span class="hljs-keyword">yield</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> <span class="hljs-title function_">resolve</span>((<span class="hljs-variable language_">this</span>.<span class="hljs-property">asyncIdx</span> += <span class="hljs-number">2</span>)));<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncCount</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">let</span> emitter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Emitter</span>(<span class="hljs-number">5</span>);<br><span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> emitter) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x);<br>&#125;<br>&#125;<br><span class="hljs-keyword">await</span> <span class="hljs-title function_">asyncCount</span>();<br><span class="hljs-comment">// 2 4 6</span><br></code></pre></td></tr></table></figure></li><li><p>Symbol.hasInstance<br>表示一个方法，这个方法决定一个构造器对象是否认可一个对象是它的实例<br>这个就是 instabceof 操作符使用<br>就是看这个对象是不是某个对象类的实例<br>专业点就是一个对象实例的原型链上是否有原型<br><code>instanceof</code>的使用场景<br><img src="/2024/02/05/redbook/2024-02-10-16-37-09.png"></p></li><li><p>Symbol.isConcatSpreadable<br>影响的就是这个方法的行为 Array.prototype.concat()</p><ul><li>对于类数组对象，默认会被打平（即使是这时候是 undefined），为 false 或者假值就会被追加到数组末尾</li><li>对于非类数组对象，为 true 时会被直接忽略掉<br><img src="/2024/02/05/redbook/2024-02-10-18-41-37.png"><br><img src="/2024/02/05/redbook/2024-02-10-18-54-24.png"></li></ul></li><li><p>Symbol.iterator<br>该属性名对应的一个方法，该方法返回对象默认的迭代器，for-of 函数使用</p></li><li><p>Symbol.match<br>该属性名表示：一个正则表达式方法，该方法用正则表达式去匹配字符串</p><p>String.prototype.match()方法使用<br><img src="/2024/02/05/redbook/2024-02-10-21-10-50.png"></p><p>如果一个对象有一个名为 Symbol.match 的方法，那么它可以被用作自定义匹配器。Symbol.match 的返回值将成为 match() 方法的返回值。<br><img src="/2024/02/05/redbook/2024-02-10-21-11-08.png"></p></li><li><p>Symbol.replace<br>该属性名表示：一个正则表达式，该方法替换一个字符串中匹配的子串</p><p>和 match 也是一样，传入的非正则表达式，会被自动转换为 RegExp 对象</p><p>要想改变这个行为就重写这个属性方法</p><p>String.prototype.replace()</p><p>tips：<br>String.split() 字符串分割<br>可以这么理解，以传入的参数作为分割条件进行分割，第二个参数指定分割数组长度<br>Array.join() 数组聚合<br><img src="/2024/02/05/redbook/2024-02-10-22-42-48.png"></p></li><li><p>Symbol.search<br>String.prototype.search()<br>和 match 也是一样的，传入的非正则表达式，会被自动转换为 RegExp 对象，有需要可以自己改写<br>那么问题就来了，search 和 match 有什么区别呢？</p><ul><li>search 返回的是索引&#x2F;match 返回的数组<br><img src="/2024/02/05/redbook/2024-02-10-23-27-32.png"></li><li>未找到时返回的结果不一样<br><img src="/2024/02/05/redbook/2024-02-10-23-30-19.png"></li></ul></li><li><p>Symbol.species<br>该属性表示用于对内置类型实例方法的返回值暴露实例化派生对象的方法<br>举例用的 getter 方法，没有太理解<br><img src="/2024/02/05/redbook/2024-02-11-10-19-35.png"></p></li><li><p>Symbol.split<br>该属性表示一个正则表达式方法，该方法在匹配正则表达式的索引位置拆分字符串，也就是上面我们提到的拆分字符串，与上面 match，search 那些相同，传入的非正则表达式会被转换为 RegExp 对象</p></li><li><p>Symbol.toPrimitive<br>该属性表示一个方法，该方法将对象转换为相应的原始值<br>ToPrimetive 使用<br>注意这里是对象，比如<br><img src="/2024/02/05/redbook/2024-02-11-11-12-25.png"></p></li><li><p>Symbol.toStringTag<br>该属性表示：一个字符串，该字符串用于创建对象的默认字符串描述。由内置方法<br>Object.prototype.toString()使用<br>注意这里是 Object<br><img src="/2024/02/05/redbook/2024-02-11-11-31-20.png"></p></li><li><p>Symbol.unscopables<br>with 废弃，简单来说就是一种绑定关系，可以指定一个变量，将所有的引用都指向这个变量</p></li></ul><p>总结：symbol 主要就是用来确保对象属性的唯一性，一些内置属性以字符串属性的形式存在，就是已经暴露给你了，你通过直接修改这些属性方法就能自定义内置方法</p><h3 id="Object-类型"><a href="#Object-类型" class="headerlink" title="Object 类型"></a>Object 类型</h3><p>对象，其实就是一组数据和功能的集合<br><code>let o = new Object()</code>;<br>每个 Object 实例都有如下属性和方法</p><ul><li>construct</li><li>hasOwnProperty(propertyName):用于判断当前对象实例是否存在给定的属性,检查的属性名必须是字符串或者符号</li><li>isPrototypeOf</li><li>propertyIsEnmerable(propertyName):用于判断给定的属性是否可以使用</li><li>toLocaleString(),根据机器的本地执行化环境来返回字符串</li><li>toString()，返回对象的字符串表示<br>具体如何理解？用 new Date 就很好理解了<br><img src="/2024/02/05/redbook/2024-02-11-13-24-22.png"></li><li>valueOf(),返回对象对应的字符串、数值或者布尔值表示，通常与 toString()返回的值相同</li></ul><p>Object 所有对象的基类</p><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p>操作符一般会调用 valueOf()和 toString()方法来取得可以计算的值</p><h3 id="一元操作符"><a href="#一元操作符" class="headerlink" title="一元操作符"></a>一元操作符</h3><p>只操作一个值的操作叫一元操作符</p><h4 id="递增-递减操作符"><a href="#递增-递减操作符" class="headerlink" title="递增&#x2F;递减操作符"></a>递增&#x2F;递减操作符</h4><ul><li>前缀版<br>变量的值在语句被求值之前改变<br><code>--age + 2</code><br>从左到右依次求值，也就是先完成减法操作，进行+2 处理</li><li>后缀版<br>如果只是唯一操作，比如 <code>++a, a++</code>,这时候的差异是没影响的,只是因为没其他操作，看不出来影响<br>与其他操作混合，就会有差异<br>后缀是先执行操作然后变量再+1 或者-1<br><img src="/2024/02/05/redbook/2024-02-11-16-48-10.png"></li></ul><p>++&#x2F;– 可以作用于任何值</p><p>注意：这里转换是先执行的，也就是先转换在做++&#x2F;–或者其他操作</p><ul><li>字符串</li><li>数值形式的字符串<br>变换为数值</li><li>非有效数值字符串<br>NaN</li><li>布尔值</li><li>false 0</li><li>true 1</li><li>浮点数<br>数值操作</li><li>对象<br>valueOf 方法可以获得操作的值（具体到第五章了）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s1 = <span class="hljs-string">&#x27;2&#x27;</span>;<br><span class="hljs-keyword">let</span> s2 = <span class="hljs-string">&#x27;z&#x27;</span>;<br><span class="hljs-keyword">let</span> b = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">let</span> f = <span class="hljs-number">1.1</span>;<br><span class="hljs-keyword">let</span> o = &#123;<br><span class="hljs-title function_">valueOf</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;,<br>&#125;;<br><span class="hljs-comment">// 这里只讨论最终值的变化</span><br>s1++; <span class="hljs-comment">// 3</span><br>s2++; <span class="hljs-comment">// NaN</span><br>b++; <span class="hljs-comment">// 1</span><br>f++; <span class="hljs-comment">// 0.10000000000000009 (浮点数的精度不准确)</span><br>o--; <span class="hljs-comment">// -2</span><br></code></pre></td></tr></table></figure><h4 id="一元的加和减"><a href="#一元的加和减" class="headerlink" title="一元的加和减"></a>一元的加和减</h4><p>就是数值前面加上+&#x2F;-</p><ul><li>加号应用到数值，没有任何影响，减号取复值</li><li>应用到非数值，会执行类似的 Number()类型转换，减号一样的就是取负值</li></ul><h4 id="位操作符"><a href="#位操作符" class="headerlink" title="位操作符"></a>位操作符</h4><p>位操作不直接应用到 64 位表示，而是先把值转换为 32 位整数，再进行位操作<br>（还不太理解）</p><ul><li><p>1bit 符号位为正值<br>剩下的是以二进制格式存储<br>例图：<br><img src="/2024/02/05/redbook/2024-02-11-22-39-28.png"></p></li><li><p>符号为负值<br>以补码的二进制编码存储</p><ul><li>先求当前数值的绝对值的二进制值</li><li>反转二进制值 0 变 1 1 变 0 反码</li><li>最后+1<br><img src="/2024/02/05/redbook/2024-02-11-22-52-42.png"></li></ul></li></ul><p>不过直接负值 toString(2),拿到的会是正值的二进制+负号</p><p><img src="/2024/02/05/redbook/2024-02-11-23-17-12.png"></p><p>ECMAScript 中所有的整数都表示为有符号数，无符号数不存符号，所以自然会比有符号数能存的数据范围更大</p><p>接上面的，位操作符应用的时候，后台会发生转换，也就是会有一个 64 位转换到 32 为数值再转回 64 位的过程</p><p>这个转换会有一个负作用<br>特殊值：NaN 和 infinity 在位操作中会被当成 0 处理</p><p>位操作符应用到非数值，首先会使用 Number()函数将该值转换为数值（自动执行），再应用位操作</p><p>注意这里的位操作符是从右往左读的，也就是第一位是最右边的，对于有符号整数，第三十二位表示数值的符号，0 表示正，1 表示负</p><h5 id="按位非（-）"><a href="#按位非（-）" class="headerlink" title="按位非（~）"></a>按位非（~）</h5><p>对数值取反（取负数）再进行减-操作<br>位操作会快很多 因为位操作是直接操作数值底层表示上完成的</p><h5 id="按位与（-）"><a href="#按位与（-）" class="headerlink" title="按位与（&amp;）"></a>按位与（&amp;）</h5><p>只有都为 1 的时候才为 1<br>有 0 则是 0</p><h5 id="按位或（｜）"><a href="#按位或（｜）" class="headerlink" title="按位或（｜）"></a>按位或（｜）</h5><p>有 1 则为 1</p><h5 id="按位异或（-）"><a href="#按位异或（-）" class="headerlink" title="按位异或（^）"></a>按位异或（^）</h5><p>相同为 0 不同为 1</p><h5 id="左移（"><a href="#左移（" class="headerlink" title="左移（&lt;&lt;）"></a>左移（&lt;&lt;）</h5><p>注意这里是整体向左移动 5 位<br>例如：2 &lt;&lt; 5<br>2 换成二进制就是 10，然后整体向左移动 5 位 1000000 &#x3D; 64</p><p>这里会保留操作符的正负号</p><h5 id="有符号右移（-）"><a href="#有符号右移（-）" class="headerlink" title="有符号右移（&gt;&gt;）"></a>有符号右移（&gt;&gt;）</h5><p>注意这里第一个 bit 位固定是符号位，有符号的右移是整体向右移动，左边的空位补 0</p><p>也就是符号位是固定的</p><h5 id="无符号右移（-）"><a href="#无符号右移（-）" class="headerlink" title="无符号右移（&gt;&gt;&gt;）"></a>无符号右移（&gt;&gt;&gt;）</h5><p>无符号就不会去固定符号位，而是直接 32 位整体移动，对于负数符号位为 1，整体右移之后数据就会有很大的差异<br>例子：<br><img src="/2024/02/05/redbook/2024-02-12-22-49-28.png"></p><h4 id="布尔操作符"><a href="#布尔操作符" class="headerlink" title="布尔操作符"></a>布尔操作符</h4><ul><li><p>逻辑非<br>可应用给任何值，始终返回布尔值<br>先将操作数转换为布尔值，再进行取反</p><ul><li>! 一个感叹号<ul><li>对象 false</li><li>‘’ 空字符串 true</li><li>非空字符串 false</li><li>数值 0 true</li><li>非零数值（包括 infinity），返回 false 注意</li><li>null true</li><li>NaN true 注意</li><li>undefined true</li></ul></li><li>!! 两个感叹号<br>相当于调用了转型函数 Boolean()，第一个！总会返回布尔值，第二个叹号取反</li></ul></li><li><p>逻辑与（&amp;&amp;）<br>可以用于任何类型的操作数<br>逻辑与并不一定返回布尔值<br>注意：</p><ul><li>只要第一个操作数是假值，就直接返回对应的假值</li><li>第一个值为 true 才考虑第二个操作数<br><img src="/2024/02/05/redbook/2024-02-12-23-46-59.png"><br>我们可以看到逻辑与是短路操作符，如果第一个操作数决定了操作结果 false，就不会去看第二个操作数，即使这个第二份操作数可能不存在<br><img src="/2024/02/05/redbook/2024-02-12-23-52-36.png"></li></ul></li><li><p>逻辑或（||）</p><p>基本和逻辑或的类似，也存在短路特性，只是这里是或运算，如果第一个操作数为 true 就不管第二个了<br>在实际开发中使用场景可以是备选值<code>let res = a || b</code></p></li></ul><h4 id="乘性操作符"><a href="#乘性操作符" class="headerlink" title="乘性操作符"></a>乘性操作符</h4><p>就是乘法运算符啦，用于两个数值的运算</p><ul><li>超出范围的（无法表示乘积的）就返回 Infinit 或者-Infinit</li><li>有 NaN 的就返回 NaN</li><li>注意 Infinity * Infiniy 返回 Infinity</li><li>不是数值的操作数，先在后台用 Number()将其转换为数值</li></ul><h4 id="除法操作符"><a href="#除法操作符" class="headerlink" title="除法操作符"></a>除法操作符</h4><p>就是除法运算啦<br>基本上跟乘法运算差不多的</p><p>注意几个区别</p><ul><li>0 &#x2F; 0 NaN</li><li>非 0 &#x2F; 0 根据第一个操作符返回 Infinity 或 -Infinit</li><li>Infinity &#x2F; Infinity NaN</li></ul><h4 id="取模操作符-（-）"><a href="#取模操作符-（-）" class="headerlink" title="取模操作符 （%）"></a>取模操作符 （%）</h4><p>取模就是取余，跟除法操作符类似<br>首先得知道除数和被除数<br><img src="/2024/02/05/redbook/2024-02-13-11-57-59.png"><br>以下是一些特殊规则</p><ul><li>被除数无限值，除数有限值，NaN</li><li>被除数有限值，除数 0，NaN</li><li>Infinity % Infinity NaN</li><li>被除数有限值，除数无限值，返回被除数<br>10 % Infinity &#x3D; 10</li><li>被除数是 0，除数不是 0，返回 0</li></ul><h4 id="指数操作符"><a href="#指数操作符" class="headerlink" title="指数操作符"></a>指数操作符</h4><p>Math.pow(); ‘**‘</p><p>还可以**&#x3D;&#x3D;直接这样负值</p><h4 id="加性操作符"><a href="#加性操作符" class="headerlink" title="加性操作符"></a>加性操作符</h4><p>注意<br><img src="/2024/02/05/redbook/2024-02-13-13-21-39.png"></p><h5 id="操作数是字符串"><a href="#操作数是字符串" class="headerlink" title="操作数是字符串"></a>操作数是字符串</h5><ul><li>两个都是字符串，进行拼接</li><li>一个是字符串，另一个操作数转换为字符串，实际上就是用 String()函数</li></ul><p>注意这里其实都会从左到右顺序执行<br>如果想优先执行，可以使用一对括号</p><h4 id="减法操作符"><a href="#减法操作符" class="headerlink" title="减法操作符"></a>减法操作符</h4><p>注意</p><ul><li>Infinity - Infinity &#x3D; 0</li></ul><p>tips：NaN 做任何操作都是返回 NaN</p><h4 id="关系操作符"><a href="#关系操作符" class="headerlink" title="关系操作符"></a>关系操作符</h4><p>就是&lt;、&gt;、&lt;&#x3D;、&gt;&#x3D;</p><p>注意，任一操作符是数值，不是数值的一端就会被转换为数值</p><p>比较字符串的时候比较的是对应字符的编码</p><p>任何关系操作符涉及比较 NaN 时都返回 false</p><h4 id="相等操作符"><a href="#相等操作符" class="headerlink" title="相等操作符"></a>相等操作符</h4><h5 id="等于和不等于"><a href="#等于和不等于" class="headerlink" title="等于和不等于"></a>等于和不等于</h5><p>会在比较前进行类型转换<br>这里其实可以看作是转换为数值<br>比如布尔值，会转换为 0 和 1<br>字符串会转换为数值再进行比较</p><p>注意 null 和 undefined 相等<br>任意一个数是 NaN，&#x3D;&#x3D; 就返回 false，即使两个数都数 NaN 也是 false</p><ul><li>&#x3D;&#x3D;</li><li>!&#x3D;</li></ul><h6 id="全等和不全等"><a href="#全等和不全等" class="headerlink" title="全等和不全等"></a>全等和不全等</h6><p>全等操作符和不全等操作符主要区别是，全等操作符不会对操作数进行类型转换</p><h4 id="条件操作符"><a href="#条件操作符" class="headerlink" title="条件操作符"></a>条件操作符</h4><p><code>let a = true ? 1:2</code></p><h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><p>就是 🟰<br><code>*= /= %= += &lt;&lt;=...</code><br>只是简写而已<br>没什么特别之处</p><h4 id="逗号操作符"><a href="#逗号操作符" class="headerlink" title="逗号操作符"></a>逗号操作符</h4><p><code>let num1 = 1, num2 = 2, num3 = 3;</code><br><code>let num = (5,1,4,8,0)</code></p><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><h3 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h3><p>被包裹的条件会用 Boolean 进行转换</p><h3 id="do-while-语句"><a href="#do-while-语句" class="headerlink" title="do-while 语句"></a>do-while 语句</h3><p>后测试循环体,代码执行后（do 部分）才会对退出条件进行求值（while 部分）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">do</span> &#123;<br>i += <span class="hljs-number">2</span>;<br>&#125; <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">10</span>);<br><span class="hljs-comment">// 2 4 6 8 10</span><br></code></pre></td></tr></table></figure><h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><p>先测试循环语句</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">10</span>) &#123;<br>i += <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p>先测试后循环语句<br>while 实现不了的，for 也无法实现，for 只是将循环封装了一些</p><p>for 的初始化代码不一定都要写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (;;) &#123;<br><span class="hljs-comment">// 无穷循环</span><br><span class="hljs-title function_">doSomething</span>();<br>&#125;<br><span class="hljs-keyword">let</span> count = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (; i &lt; count; ) &#123;<br>i++;<br><span class="hljs-title function_">doSomething</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="for-in"><a href="#for-in" class="headerlink" title="for-in"></a>for-in</h3><p>用于进行枚举对象中的非符号键属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> propName <span class="hljs-keyword">in</span> <span class="hljs-variable language_">window</span>) &#123;<br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(propName);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里推荐使用 const 这里的变量不会被改变</p><h3 id="for-of"><a href="#for-of" class="headerlink" title="for-of"></a>for-of</h3><p>这里是用于遍历可迭代的对象，比如数组，属性之类的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> el <span class="hljs-keyword">of</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]) &#123;<br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(el);<br>&#125;<br></code></pre></td></tr></table></figure><p>for-await-of,支持 promise 异步可迭代对象</p><h3 id="标签语句"><a href="#标签语句" class="headerlink" title="标签语句"></a>标签语句</h3><p>用于给语句加标签，在后面可以通过 break 或者 continue 语句引用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">start</span>: <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>使用场景是多嵌套循环，也就多个 for 循环中，跳出外层循环</p><h3 id="break-和-continue-语句"><a href="#break-和-continue-语句" class="headerlink" title="break 和 continue 语句"></a>break 和 continue 语句</h3><p>这里主要注意一下标签语句的应用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num = <span class="hljs-number">0</span>;<br><span class="hljs-attr">outer</span>: <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++) &#123;<br><span class="hljs-keyword">if</span> (i == <span class="hljs-number">5</span> &amp;&amp; j == <span class="hljs-number">5</span>) &#123;<br><span class="hljs-comment">// 这里直接跳到最外层循环继续执行</span><br><span class="hljs-keyword">continue</span> outer;<br>&#125;<br>num++;<br>&#125;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num); <span class="hljs-comment">//95</span><br></code></pre></td></tr></table></figure><h3 id="with-语句"><a href="#with-语句" class="headerlink" title="with 语句"></a>with 语句</h3><p>已经废弃，不推荐使用<br>将代码作用域设定为指定对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> qs = location.<span class="hljs-property">search</span>.<span class="hljs-title function_">substring</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">with</span> (location) &#123;<br><span class="hljs-keyword">let</span> qs = search.<span class="hljs-title function_">substring</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h3><p>switch 语句在进行条件比较的时候使用的是全等操作符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">switch</span> (num) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: &#123;<br><span class="hljs-comment">// 如果需要使用块级作用域</span><br><span class="hljs-keyword">let</span> message = <span class="hljs-string">&#x27;hi&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message);<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-attr">default</span>:<br><span class="hljs-comment">// 位置可以变动，不满足任何条件的时候进这里</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;default&#x27;</span>);<br><span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>这里简单介绍了函数，只讲了 函数的 return；return 不赋值的时候默认是返回 undefined</p><h1 id="第四章-变量、作用域与内存"><a href="#第四章-变量、作用域与内存" class="headerlink" title="第四章 变量、作用域与内存"></a>第四章 变量、作用域与内存</h1><h2 id="原始值与引用值"><a href="#原始值与引用值" class="headerlink" title="原始值与引用值"></a>原始值与引用值</h2><p>js 可以包含两种不同类型的数据</p><ul><li>原始值 最简单的数据类型<br>Undefined Null Boolean Number String Symbol BigInt<br>对于原始值，按值访问，操作的就是实际值</li><li>引用值<br>由多个值构成的对象 Object<br>保存引用值的变量是按引用访问的</li></ul><h3 id="动态属性"><a href="#动态属性" class="headerlink" title="动态属性"></a>动态属性</h3><p>定义原始值或者引用值都是创建变量来赋值，区别在于这个变量保存了这个值以后能做什么大有不同</p><ul><li>引用值可以随时添加和删除属性方法等</li><li>原始值没有属性，即使强制加上属性不报错但是是找不到这个属性的</li></ul><p>注意，原始类型的初始化就只是用原始值字面量形式，如果使用 new 关键字，则会创建一个 Object 实例，会被认为是 object</p><h3 id="复制值"><a href="#复制值" class="headerlink" title="复制值"></a>复制值</h3><p>复制值也就是一个变量赋值给另一个变量</p><ul><li>原始值的复制是把旧变量的值直接复制到新变量的位置，变成两个独立变量</li></ul><p><img src="/2024/02/05/redbook/2024-02-18-22-09-05.png"></p><ul><li>引用值的复制<br>复制的其实只是一个指针，指向存储在堆内存中的对象，所以一个对象的变化会在另一个对象上反映出来<br><img src="/2024/02/05/redbook/2024-02-18-22-11-03.png"></li></ul><h3 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h3><p>这里指的就是函数的传参，传参意味着值会被复制到一个局部变量（即一个命名空间，就是 arguments 中一个槽位）可以理解为就是创建了一个新的变量</p><p>函数的传参都是按值传递的，这里的值传递我们可以理解为栈值传递，对于原始值对于引用值，这里传的是指针地址</p><p>tips：</p><ul><li>形参 函数定义时的参数</li><li>实参 函数调用时传递的参数</li></ul><p>所以会表现为</p><ul><li>对于原始值，直接进行值的复制操作，函数内对本地变量的影响不会反应到外部</li><li>对于引用值，复制的是指针地址，所以函数内对本地变量的操作会反应到外部，因为指针地址是一致的，如果一旦重新给本地变量分配新的堆内存地址，本地变量与外部变量的关系就断掉了就会出现不会影响外部变量</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj1 = &#123; <span class="hljs-attr">a</span>: <span class="hljs-string">&#x27;1&#x27;</span> &#125;;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">obj</span>) &#123;<br>obj.<span class="hljs-property">time</span> = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-title function_">test</span>(obj1);<br><span class="hljs-comment">// obj &#123;a:&#x27;1&#x27;, time:1&#125;</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">test1</span>(<span class="hljs-params">obj</span>) &#123;<br>obj = &#123;&#125;;<br>obj.<span class="hljs-property">time</span> = <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-title function_">test1</span>(obj1);<br><span class="hljs-comment">// 无变化 obj &#123;a:&#x27;1&#x27;, time:1&#125;</span><br></code></pre></td></tr></table></figure><h3 id="确定类型"><a href="#确定类型" class="headerlink" title="确定类型"></a>确定类型</h3><p>typeof 最适合判断一个变量是否是原始类型 具体来说就是：number boolean undefined，string，不太适合用于判断 object，因为我们通常更想知道它是什么类型的对象</p><p>tips：typeof 操作符在检测函数时会返回’function’, 在部分浏览器中对于正则表达式 RegExp 也会返回 function，IE 和火狐可能回返回 ‘object’</p><h3 id="instanceof-操作符"><a href="#instanceof-操作符" class="headerlink" title="instanceof 操作符"></a>instanceof 操作符</h3><p>如果变量是给定引用类型的实例，instanceof 操作符返回 true</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">colors instansof <span class="hljs-title class_">Array</span>;<br><span class="hljs-comment">// 变量color是Array吗</span><br></code></pre></td></tr></table></figure><h2 id="执行上下文与作用域"><a href="#执行上下文与作用域" class="headerlink" title="执行上下文与作用域"></a>执行上下文与作用域</h2><p>简称上下文，变量或函数的上下文决定了它们可以访问哪些数据，以及行为</p><p>每个上下文都有一个关联的变量对象（无法通过代码访问变量对象，但后台处理数据会用到）,在上下文中定义的所有的变量和函数都存在于这个对象上</p><p>全局上下文是最外层的上下文，ECMAScript 实现的宿主环境不同，表示全局上下文的对象可能不一样</p><p>在浏览器中，全局上下文就是我们说的 window 对象，var 定义的全局变量都会成为 window 对象的属性和方法，let 和 const 不会</p><p><img src="/2024/02/05/redbook/2024-02-18-22-42-57.png"></p><p>上下文的所有代码都会在执行完毕后被销毁，包括定义在它上面的所有变量和函数<br>注意，全局上下文只有在应用程序退出前才会被销毁，比如关闭网页或退出浏览器</p><p>每个函数都有自己的上下文，当代码执行流进入函数时，函数的上下文被推到一个上下文栈上，函数执行完毕后，上下文栈回弹出该函数的上下文，将控制权返还给之前的执行上下文，ECMAScript 程序执行流就是通过这个上下文栈进行控制的</p><p>上下文代码在执行的时候，会创建变量对象的一个作用域链，这个作用域链决定了各级上下文中代码访问变量和函数时的顺序，正在执行的上下文变量对象始终位于作用域链的最前端</p><p>如果上下文是函数，其活动对象用作变量对象，活动对象最初只有一个定义变量 arguments（全局上下文没有这个对象）</p><p>全局上下文变量对象始终是作用域链的最后一个变量对象</p><p>代码执行时的标识符解析是通过沿作用域链逐级搜索标识符名称完成的，搜索过程始终从作用域链的最前端开始，逐级向后，直到找到，没找到会报错</p><p>简单来说，就是我们能访问到函数外部的变量是因为我们在作用域链找到了该变量</p><p>例子：<br><img src="/2024/02/05/redbook/2024-02-18-22-57-30.png"></p><p>图中每个矩形框表示不同的上下文</p><p>再简单点说，先在自己的上下文变量对象中找，找不到就逐级取上一级上下文变量对象中找</p><p>内部上下文可以通过作用域链访问外部上下文中的一切，但外部上下文无法访问内部的上下文</p><p>注意：函数参数也被认为是当前上下文中的变量，也就是函数变量是属于函数局部的上下文，也同样的上级上下文无法访问</p><h3 id="作用域链增强"><a href="#作用域链增强" class="headerlink" title="作用域链增强"></a>作用域链增强</h3><p>这里提到了</p><ul><li>try&#x2F;catch 语句中的 catch 语句</li><li>with 语句</li></ul><p>仅做了解，这里的作用域链增强其实就是回将特有变量增加到当前作用域链的前端，从而能达到在外部访问内部作用域的情况，不会这么使用</p><p>catch 的 看起来是这么个情况<br><img src="/2024/02/05/redbook/2024-02-18-23-13-55.png"></p><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><h4 id="var-函数作用域声明"><a href="#var-函数作用域声明" class="headerlink" title="var 函数作用域声明"></a>var 函数作用域声明</h4><p>变量会被自动添加到最接近的上下文，如果是在函数中，最接近的上下文就是函数局部上下文</p><p>注意这里，如果未声明变量会被添加到全局上下文，在严格模式下会报错</p><p><img src="/2024/02/05/redbook/2024-02-19-21-36-34.png"></p><p>var 声明会被拿到函数或全局作用域的顶部，位于作用域中所有代码之前，这个现象叫“提升”，也就是变量提升</p><p>会产生什么现象呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name); <span class="hljs-comment">// 不会报错;</span><br>name = <span class="hljs-string">&#x27;Jake&#x27;</span>;<br><span class="hljs-keyword">var</span> name;<br><span class="hljs-comment">// 等价于</span><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;Jake&#x27;</span>;<br><span class="hljs-comment">// var 声明的变量会被提升到最顶端</span><br></code></pre></td></tr></table></figure><h4 id="let-块级作用域声明"><a href="#let-块级作用域声明" class="headerlink" title="let 块级作用域声明"></a>let 块级作用域声明</h4><p>块级作用域：由最近的一对包含花括号{}界定</p><p>let 与 var 除了变量提升的区别还有一个区别是同一个作用域内不能声明两次，重复的 var 声明会被忽略；重复的 let 声明会抛出错误</p><h4 id="使用-const-的常量声明"><a href="#使用-const-的常量声明" class="headerlink" title="使用 const 的常量声明"></a>使用 const 的常量声明</h4><p>使用 const 声明的变量必须同时初始化为某个值，一经声明，在其生命周期的任何时候都不能在重新赋值</p><p>其他和 let 一样</p><p>对于对象来说，赋值为对象的 const 变量不能再被重新赋值为其他引用值，但对象的健不受影响</p><p>怎么理解呢，也就是只要对象的引用地址不发生变化就可以</p><p><img src="/2024/02/05/redbook/2024-02-19-22-00-34.png"></p><p>如果想让整个对象都不能修改可以使用<code>Object.freeze(&#123;&#125;)</code></p><p><img src="/2024/02/05/redbook/2024-02-19-22-03-38.png"></p><p>const 声明暗示变量的值是单一类型且不可修改</p><h3 id="标识符的查找（变量的查找）"><a href="#标识符的查找（变量的查找）" class="headerlink" title="标识符的查找（变量的查找）"></a>标识符的查找（变量的查找）</h3><p>先在局部作用域中查找，到找了搜索结束；没找到继续沿作用域链搜索，一直持续到搜索到全局上下文的变量对象</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>js内存相关</title>
    <link href="/2023/12/03/js%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3/"/>
    <url>/2023/12/03/js%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="字节"><a href="#字节" class="headerlink" title="字节"></a>字节</h1><p>1B(字节) &#x3D; 8 bit</p><p>1KB &#x3D; 1024B</p><p>1M &#x3D; 1024KB (2^10B)</p><p>128 * 128 &#x3D; 16384 &#x2F; 1024 &#x3D; 16K</p><h1 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h1><p>不再用到的内存 没有及时释放 就叫做内存泄漏</p><h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><p>程序提供的自动内存管理 减轻程序员的负担</p><h3 id="垃圾回收机制如何知道哪些内存不再需要？"><a href="#垃圾回收机制如何知道哪些内存不再需要？" class="headerlink" title="垃圾回收机制如何知道哪些内存不再需要？"></a>垃圾回收机制如何知道哪些内存不再需要？</h3><h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><ul><li><p>垃圾回收机制会处理的场景<br>如果一个值的引用次数数是 0 就表示这个值不会再用到了 因此可以将这块的内存释放</p></li><li><p>需要主动检查是否存在引用进行解除引用</p></li></ul><p>如果一个值不再需要了 引用值却不为 0 垃圾回收机制就无法释放这块的内存 导致内存泄漏</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 占用内存</span><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-comment">// 解除引用 释放内存</span><br>arr = <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><h3 id="如何定位到是否存在内存泄漏"><a href="#如何定位到是否存在内存泄漏" class="headerlink" title="如何定位到是否存在内存泄漏"></a>如何定位到是否存在内存泄漏</h3><p>经验法则是，如果连续五次垃圾回收之后，内存占用一次比一次大，那就存在内存泄漏</p><ul><li>可以使用 Chrome 浏览器查看内存占用的情况</li></ul><p><img src="/2023/12/03/js%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3/2023-12-03-23-35-56.png"></p><ul><li>node.js 命令行 (目前还不知道怎么用)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(process.<span class="hljs-title function_">memoryUsage</span>());<br><span class="hljs-comment">// &#123; rss: 27709440,  所有的内存占用，包括指令区和堆栈</span><br><span class="hljs-comment">//  heapTotal: 5685248, “堆”占用部分的内存 包括用到的和没用到的</span><br><span class="hljs-comment">//  heapUsed: 3449392, 用到的堆的部分 从这里就能知道了</span><br><span class="hljs-comment">//  external: 8772 &#125; v8引擎内部的C++对象占用的内存</span><br></code></pre></td></tr></table></figure><h2 id="防止泄漏方案"><a href="#防止泄漏方案" class="headerlink" title="防止泄漏方案"></a>防止泄漏方案</h2><p>在新建引用的时候就声明，哪些引用必须手动清除，哪些值忽略不计</p><p>ES6 的新的数据结构 WeakSet WeakMap</p><p><strong>这种数据结构的值不计入垃圾回收机制</strong></p><p>也就是垃圾回收机制会忽略这部分的引用关系 只要再没有其他引用就可以直接进行垃圾回收机制 释放内存</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> wm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>();<br><span class="hljs-keyword">const</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;example&#x27;</span>);<br>wm.<span class="hljs-title function_">set</span>(element, <span class="hljs-string">&#x27;some information&#x27;</span>);<br>wm.<span class="hljs-title function_">get</span>(element);<br></code></pre></td></tr></table></figure><p>该案例看上去对 dom 节点的引用计数是 2 其实应该是 1</p><p>一旦消除 element 这个引用 它占用的内存就会被垃圾回收机制释放</p><p>Weakmap 保存的这个键值对也会自动消失</p><p><strong>使用场景</strong><br>如果你要往对象上增加数据，又不想干扰垃圾回收机制，就可以使用 Weakmap</p><h2 id="如何验证-Weakmap-是否生效"><a href="#如何验证-Weakmap-是否生效" class="headerlink" title="如何验证 Weakmap 是否生效"></a>如何验证 Weakmap 是否生效</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 执行垃圾回收</span><br><span class="hljs-variable language_">global</span>.<span class="hljs-title function_">gc</span>();<br><span class="hljs-comment">// 看看内存情况</span><br>process.<span class="hljs-title function_">memoryUsage</span>();<br><span class="hljs-keyword">let</span> b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-keyword">let</span> wm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>();<br>wm.<span class="hljs-title function_">set</span>(b, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">5</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>));<br><span class="hljs-comment">// 执行垃圾回收</span><br><span class="hljs-variable language_">global</span>.<span class="hljs-title function_">gc</span>();<br><span class="hljs-comment">// 看看内存情况</span><br>process.<span class="hljs-title function_">memoryUsage</span>();<br>b = <span class="hljs-literal">null</span>;<br><span class="hljs-comment">// 执行垃圾回收</span><br><span class="hljs-variable language_">global</span>.<span class="hljs-title function_">gc</span>();<br><span class="hljs-comment">// 看看内存情况</span><br>process.<span class="hljs-title function_">memoryUsage</span>();<br><span class="hljs-comment">// 如果内存和最开始一致 就说明 WeakMap中的数据被销毁了</span><br></code></pre></td></tr></table></figure><p>学习链接：</p><p><a href="https://www.ruanyifeng.com/blog/2017/04/memory-leak.html">https://www.ruanyifeng.com/blog/2017/04/memory-leak.html</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SDF</title>
    <link href="/2023/10/24/sdf/"/>
    <url>/2023/10/24/sdf/</url>
    
    <content type="html"><![CDATA[<p>最近工作需求安排要摸一个 sdf</p><h1 id="SDF"><a href="#SDF" class="headerlink" title="SDF"></a>SDF</h1><h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><ul><li>快</li><li>需要大量的存储</li></ul><p>距离场</p><p>二维平面上我们说物体的表面就是物体的轮廓</p><p>sdf 是一个安全距离 在此期间都不会发生碰撞</p><p>sdf 考虑的是场景中的任意一个点</p><p>每个像素记录自己与距离自己最近的物体边界的距离</p><p>符号体现在像素点在物体内距离为负 刚好在物体边界上为 0 大于为正数</p><h1 id="生成算法"><a href="#生成算法" class="headerlink" title="生成算法"></a>生成算法</h1><p>目前找到的在 CPU 上能够在线性时间内（时间复杂度 O(n)）将二值图转换为 sdf 图的算法有两种</p><p>我们必须理解的一个前提</p><p>当前像素点里面是存了初始化的距离值的 0 &#x2F; 无穷大</p><p>当前像素点的 sdf &#x3D; min(当前像素点的 sdf，目标点的 sdf + distance(像素点，目标点))</p><p>这个距离就是点与点之间的距离</p><p>(x - x’)^2 + (y - y’)^2</p><h2 id="8ssedt"><a href="#8ssedt" class="headerlink" title="8ssedt"></a>8ssedt</h2><p>算法核心思路</p><h3 id="1、创建两个网格"><a href="#1、创建两个网格" class="headerlink" title="1、创建两个网格"></a>1、创建两个网格</h3><p>遍历位图</p><ul><li><p>Grid1 用于计算物体外到物体内到距离 标记白色像素距离为 0 黑色像素为一个超大数</p></li><li><p>Grid2 用于计算物体内到物体外的距离 白色像素距离为超大数 黑色像素为 0</p></li></ul><p>推导过程是一个像素分别和周边的八个像素进行比较</p><p>为每个网格都执行一遍 pass0 和 pass1</p><ul><li>pass0 按照从上到下 从左到右 从右到左</li><li>pass1 按照从下到上 从右到左 从左到右</li></ul><p>然后将 Grid1 - Grid2 就得到了最终的结果</p><p>参考链接：</p><p><a href="https://blog.csdn.net/qq_41835314/article/details/128548073">https://blog.csdn.net/qq_41835314/article/details/128548073</a><br><a href="https://zhuanlan.zhihu.com/p/518292475">https://zhuanlan.zhihu.com/p/518292475</a></p><h2 id="欧几里得距离算法"><a href="#欧几里得距离算法" class="headerlink" title="欧几里得距离算法"></a>欧几里得距离算法</h2><p>同样也是分为两个表格</p><p>二维情况下 像素(x,y)到形状的距离</p><p>可以拆分为两个一维操作</p><p>也就是</p><p><img src="/2023/10/24/sdf/2023-11-30-00-42-06.png"></p><p>这里我们可以发现这是一个二次函数 一个抛物线函数</p><p><img src="/2023/10/24/sdf/2023-11-30-00-45-30.png"></p><p>然后我们要做什么 我们可以从图中看出 蓝色区域就是我们可能的距离值</p><p><img src="/2023/10/24/sdf/2023-11-30-00-51-51.png"></p><p>参考链接：<a href="https://zhuanlan.zhihu.com/p/651108382?utm_psn=1710953023390494720">https://zhuanlan.zhihu.com/p/651108382?utm_psn=1710953023390494720</a></p><h2 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h2><h3 id="mipmap"><a href="#mipmap" class="headerlink" title="mipmap"></a>mipmap</h3><p>主图按特定比例缩小细节的复制品</p><p>也就是预先就生成了不同尺寸的小副本， 用于加快渲染</p><p><a href="https://zh.wikipedia.org/zh-sg/Mipmap">https://zh.wikipedia.org/zh-sg/Mipmap</a></p><h2 id="位图和矢量图"><a href="#位图和矢量图" class="headerlink" title="位图和矢量图"></a>位图和矢量图</h2><h3 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h3><p>像素阵列，jpe.png 之类的</p><h3 id="矢量图"><a href="#矢量图" class="headerlink" title="矢量图"></a>矢量图</h3><p>矢量图保存的是对图案内容的抽象描述，而不是具体的每个像素的颜色信息</p><p>例如：svg</p><p>我们在这里生成的 sdf 也就是矢量图</p><h2 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h2><p>也就是将矢量图数据转换为位图数据的过程</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>系统学习算法</title>
    <link href="/2023/09/12/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/"/>
    <url>/2023/09/12/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>最近懒散了很多<br>重新考虑了目前的情况<br>决定进行系统的学习算法<br>并且希望以后能够从事算法的行业<br>我希望我当下的这份决心能和我坚持减肥一样 能够长期保持下来</p><p><strong>不做依附任何人的藤蔓</strong></p><p>目前是准备看左程云老师 b 站<br><a href="https://www.bilibili.com/video/BV13g41157hK?p=3&vd_source=cce0370852a05575ac787ef99b1d8903">https://www.bilibili.com/video/BV13g41157hK?p=3&amp;vd_source=cce0370852a05575ac787ef99b1d8903</a></p><h1 id="第一节课"><a href="#第一节课" class="headerlink" title="第一节课"></a>第一节课</h1><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>首先我们知道评价一个算法的好坏程度是通过时间复杂度</p><p>时间复杂度也就是随着样本数量增加，算法所要花费的时间</p><p>只保留最高阶的项，并忽略系数</p><p>大 O 表示法是一个上限，数据量大的情况</p><p>同样时间复杂度的情况就需要考虑常数项</p><p>这样就需要实验进行对比，比如 console.time</p><h2 id="常数时间的操作"><a href="#常数时间的操作" class="headerlink" title="常数时间的操作"></a>常数时间的操作</h2><p>其实就是耗时不会随着样本数量产生变化，跟数据量无关，是一个固定时间操作</p><p>比如 我们从数组从取出某个数，我们不关心这个数组有多大，我们只关心 index 是多少，数组是一个连续的区域，做数组寻址</p><p>像加减乘除位运算这些都是常数操作</p><p>什么情况下不是常数复杂度呢</p><p>比如我们现在用的是链表，链表中我们要 get 某个数，我们就得要遍历，那这个链表的数据大小就会影响时间复杂度，链表不是一个连续的结构，你不知道 next 指针指到哪里所以需要遍历</p><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>有限几个变量就能完成这个算法流程，那就是 O(1)的</p><p>如果我要开辟一个额外数组</p><p>那就是 O(n)</p><h2 id="选择排序的时间复杂度和空间复杂度"><a href="#选择排序的时间复杂度和空间复杂度" class="headerlink" title="选择排序的时间复杂度和空间复杂度"></a>选择排序的时间复杂度和空间复杂度</h2><p>tips：</p><ul><li>首先做题的时候，我们要思考一些特殊情况，一些干扰情况</li><li>复习 array.splice(start,deklNum,startReplaceEl)</li></ul><p>选择排序这里给出的例子是 双指针 升序这么一个例子</p><p>这里补充一下选择排序是什么</p><ul><li>选择排序是一种最直观的排序</li><li>首选我们关注一下重点 这个重点是排序，也就是选择排序也是排序的一种方式<br>这个选择排序就是从数组中遍历找到最小&#x2F;最大的数，定下来，然后再遍历剩余的数据，再继续找<br>这样就是一个等差数列 时间复杂度就是 O(n^2)</li></ul><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>从目前给出的例子来看，冒泡排序就是遍历 然后前后比较交换位置 确定最后一位 再遍历 再交换位置 再确定一位<br>也就是我们先搞定 n-1 的数 然后搞定 n-2 的数 然后这么一直遍历确认 最终得到最终结果<br>所以最终还是等差数列<br>最终保留最高项，忽略系数 我们还是得到 O(n^2) 的时间复杂度<br>冒泡排序也是两次 for 循环 冒泡排序每次确定的都是最后一位 所以变量从 length-1 开始</p><p>咱们这里就得复习一下这个解构赋值处理数组的交换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>[arr[<span class="hljs-number">0</span>], arr[<span class="hljs-number">1</span>]] = [arr[<span class="hljs-number">1</span>], arr[<span class="hljs-number">2</span>]];<br><span class="hljs-comment">// arr [2, 3, 3]</span><br></code></pre></td></tr></table></figure><h2 id="异或运算"><a href="#异或运算" class="headerlink" title="异或运算 ^"></a>异或运算 ^</h2><p>这里补充讲解了异或运算</p><p>咱们就是说之前对这部分完全是 0 接触</p><p>js 其实完全也是能做这些二进制的运算的</p><p>异或运算 相同为 0 不同为 1</p><p><img src="/2023/09/12/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/2023-09-12-23-07-02.png"></p><h3 id="特质"><a href="#特质" class="headerlink" title="特质"></a>特质</h3><p>0 ^ N &#x3D; N</p><p>N ^ N &#x3D; 0</p><p>满足交换律和结合律</p><ul><li><p>交换律 a ^ b &#x3D; b ^ a</p></li><li><p>结合律 (a ^ b) ^ c &#x3D; a ^ (b ^ c)</p></li></ul><h3 id="运算场景"><a href="#运算场景" class="headerlink" title="运算场景"></a>运算场景</h3><p>当前这里用于交换两个数的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-number">17</span>;<br><span class="hljs-keyword">let</span> b = <span class="hljs-number">23</span>;<br>a = a ^ b;<br>b = a ^ b;<br>a = a ^ b;<br><span class="hljs-comment">//  完成交换 好牛 抖机灵的写法 别这么干</span><br><span class="hljs-comment">// 这样就没有中间值这一处理了 就不用申请额外的空间了 前提 a，b指向的是两个不同的内存 如果相同就会触发N^N变成0了</span><br></code></pre></td></tr></table></figure><p>为什么？？</p><p>这里其实就是特质的运用</p><p><img src="/2023/09/12/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/2023-09-12-23-56-54.png"></p><p>插播：今天解决了图片上传失效问题 使用方法为最后一项 <a href="https://hexo.io/zh-cn/docs/asset-folders.html">https://hexo.io/zh-cn/docs/asset-folders.html</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>一个数组</p><ul><li>只有一种数出现了奇数次 其他的所有数都是偶数次，怎么找到奇数次的数</li><li>两种数出现了奇数次 其他的数为偶数次，怎么样找到这两种数</li></ul><p>要求时间复杂度 O(n) 空间复杂度 O(1)</p><p>（js 的话就 indexOf 加一个数组对象{‘num’:次数}来处理）</p><p>哈哈哈 让我们看看神奇的异或操作怎么写</p><h2 id="第一题解答"><a href="#第一题解答" class="headerlink" title="第一题解答"></a>第一题解答</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> test = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>];<br><span class="hljs-keyword">let</span> eor = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; test.<span class="hljs-property">length</span>; i += <span class="hljs-number">1</span>) &#123;<br><span class="hljs-comment">// eor = eor ^ test[i];</span><br>eor ^= test[i];<br>&#125;<br><span class="hljs-comment">// eor = 3</span><br></code></pre></td></tr></table></figure><p>为什么是这样<br>首先我们知道异或运算是不考虑位置关系的<br>所以这个数组在我们眼里可以看为 <code>[1,1,2,2,3,3,3]</code><br>再想想上面的性质 n^n &#x3D; 0 0 ^n &#x3D; n</p><h2 id="为什么异或满足交换律和结合律"><a href="#为什么异或满足交换律和结合律" class="headerlink" title="为什么异或满足交换律和结合律"></a>为什么异或满足交换律和结合律</h2><p>用无进位相加来看（？？）</p><p>最终的结果和 1 的位置有关，和顺序无关</p><p>这里其实就是异或运算的原理 反正就是 <strong>相同为 0 不同为 1</strong> 跟顺序其实没有什么关系</p><h2 id="第二道题解法"><a href="#第二道题解法" class="headerlink" title="第二道题解法"></a>第二道题解法</h2><p>前置知识：</p><ul><li><p>js 进制之间的转换 又忘记了<br>这里首先我们得知道进制之间的转换是发生在数字之间的 所以一定是 Number 下的方法</p><ul><li><code>Number.parseInt(string,radix)</code><ul><li>需要注意 parseInt 只能低进制转高进制，也就是二进制转八进制，八进制不能转二进制</li></ul></li><li><code>Number.toString(radix)</code><ul><li>需要注意 toString 是只能把十进制数字转换为其他进制的数字 radix 取值 2 ～ 36</li></ul></li></ul><p>另外我们还需要的知道的是 js 要么只能把其他进制转换为十进制，要么就是将十进制转换为其他进制，也可以理解为十进制是一个中间媒介</p><p>比如我们看下面这个例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">0xa</span>; <span class="hljs-comment">// 16进制 会被转换为十进制数字 为10 bcdef+1</span><br><span class="hljs-keyword">var</span> b = <span class="hljs-number">010</span>; <span class="hljs-comment">// 8进制 会被转换为十进制 为8</span><br></code></pre></td></tr></table></figure></li><li><p>取反 <code>~</code> 1011 取反 0100</p><ul><li>js 里面是取反得到的结果就是-(x+1)</li></ul></li><li><p>取反+1 <code>~+1</code> 这里的 ➕1 是进位的意思</p></li><li><p>按位与 <code>&amp;</code> 都为 1 结果位才为 1，任何数字与 0 进行安位与都是 0</p></li></ul><p>这个第二题也比较巧妙</p><p>这个里面有一串神奇的代码<br>提取出最右边一个 1 来</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> eor = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i += <span class="hljs-number">1</span>) &#123;<br>eor ^= arr[i];<br>&#125;<br><span class="hljs-comment">// 此时我们的eor = a^b</span><br><span class="hljs-comment">// a != b 所以 eor != 0 根据相同为0 不同为1 所以eor 必然在某一位上的位置上1</span><br><span class="hljs-keyword">const</span> rightone = eor &amp; (~eor + <span class="hljs-number">1</span>);<br><span class="hljs-comment">// 我们找到这个1 然后按照这个1 将数组数据再次分堆</span><br><span class="hljs-keyword">let</span> onlyone = <span class="hljs-number">0</span>; <span class="hljs-comment">//也就是eor‘</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; arr.<span class="hljs-property">length</span>; j += <span class="hljs-number">1</span>) &#123;<br><span class="hljs-comment">// 拿到这一位为0的 进行异或操作</span><br><span class="hljs-keyword">if</span> ((arr[j] &amp; rightone) === <span class="hljs-number">0</span>) &#123;<br>onlyone ^= arr[kj];<br>&#125;<br>&#125;<br><span class="hljs-comment">// 这里也就是 onlyone^otherone^onlyone = 0 ^ otherone = otherone</span><br><span class="hljs-keyword">let</span> otherone = eor ^ onlyone;<br></code></pre></td></tr></table></figure><p><strong>位运算效率非常高</strong></p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序的效率比选择排序和冒泡排序的效率都要更高一些</p><p>因为选择排序和冒泡排序都是严格的 O(n^2)，插入排序跟数据的初始排序还有些关系</p><p>这个老师用拿牌模拟了一下场景 确实很像<br>也就是拿到一张牌后 遍历去找对应的位置</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ul><li>默认第一个元素已经是排好序的</li><li>取下一个元素 与以排好序的元素数组进行遍历比较 根据条件交换位置，并且插入</li><li>重复以上步骤</li></ul><p>所以插入排序最差的情况的时间复杂度是 O(n^2), 算法的时间复杂度一律按最差的情况来估计</p><p>补充知识</p><ul><li>还有平均和最好的表示方式， 大 O 是最差的情况</li></ul><p>这里其实就是初始是 0-0 然后 0-i 要进行排序</p><h2 id="补充二分查找"><a href="#补充二分查找" class="headerlink" title="补充二分查找"></a>补充二分查找</h2><p>首先使用二分法有一个明显条件，<strong>当前这个列表有序</strong><br>不过即使无序也可以使用二分-&gt;题目二 大部分都是有序情况<br>找到这个中间的数 跟目标数进行对比 如果根据大小判断是往左边找还是往右边找<br>然后再次进行二分重复当前步骤<br>时间复杂度 O(log2N) 对数 求幂的逆运算 不写底数的话默认底数为 2</p><p>只要是有序一定考虑二分</p><ul><li><p>题目一<br>在一个有序数组中，找&gt;&#x3D;某个数最左侧的位置</p></li><li><p>题目二<br>局部最小值 其实还是二分 找这个局部最小<br>数组无效 相邻数不相等 局部最小 小于两边的数 时间复杂度最小 O(n)</p></li><li><p>优化方向<br>1、数据状况优化<br>2、根据当前的特殊问题优化 比如上题 跟左右范围有关所以考虑二分</p></li></ul><h2 id="对数器的概念和使用"><a href="#对数器的概念和使用" class="headerlink" title="对数器的概念和使用"></a>对数器的概念和使用</h2><p>方法 a （想测的）<br>方法 b （好实现，时间复杂度不行）</p><p>随机样本产生器</p><p>在方法 a 中跑一遍再到方法 b 中跑一遍</p><p>这里介绍了生成随机数组的一个方法，主要就是 math.random</p><p><code>Math.random()</code> 返回[0,1) 等概率返回一个小数<br>衍生一下<br><code>Math.random() * N</code> 返回[0,N)<br><code>parseInt(Math.randow() * N)</code> 返回 [0,N-1] parseInt 会向下取整</p><h1 id="第二课"><a href="#第二课" class="headerlink" title="第二课"></a>第二课</h1><p>老师讲得真的很好 还是得静下心来啊</p><h2 id="递归行为"><a href="#递归行为" class="headerlink" title="递归行为"></a>递归行为</h2><ul><li>题目 求数组 Arr 上的最大值</li></ul><p>防止溢出的做法</p><ul><li>本来我们应该是这样写 <code>mid = (l+r)/2</code></li><li>防止溢出所以我们应该是这样写 <code>mid = l + (r - l)/2</code></li><li>然后再优化一下 右移一位 <code>(r-l) &gt;&gt; 1</code> 就是&#x2F;2 比直接&#x2F;2 要快</li></ul><p>这里给了一个递归求最大值的案例<br>贴一个伪代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getMax</span>(<span class="hljs-params">arr</span>) &#123;<br><span class="hljs-keyword">const</span> max = <span class="hljs-title function_">process</span>(arr, <span class="hljs-number">0</span>, arr.<span class="hljs-property">lenghth</span> - <span class="hljs-number">1</span>);<br><span class="hljs-keyword">return</span> max;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">process</span>(<span class="hljs-params">arr, l, r</span>) &#123;<br><span class="hljs-keyword">if</span> (l === r) &#123;<br><span class="hljs-keyword">return</span> arr[l];<br>&#125;<br><span class="hljs-keyword">let</span> mid = arr[(l + (r - l)) &gt;&gt; <span class="hljs-number">1</span>];<br><span class="hljs-keyword">let</span> leftMax = <span class="hljs-title function_">process</span>(arr, l, mid);<br><span class="hljs-keyword">let</span> rightMax = <span class="hljs-title function_">process</span>(arr, mid + <span class="hljs-number">1</span>, r);<br><span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(leftMax, rightMax);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们再来去分解这个递归 我们把递归做一个分解 同时递归 &#x3D; 数学归纳法<br>发现其实就是一种进栈出栈（难怪说递归基本上都能改写为栈模式）<br>在一个高度上进行压栈</p><h2 id="master-公式的使用"><a href="#master-公式的使用" class="headerlink" title="master 公式的使用"></a>master 公式的使用</h2><h3 id="master-公式用来干嘛的"><a href="#master-公式用来干嘛的" class="headerlink" title="master 公式用来干嘛的"></a>master 公式用来干嘛的</h3><p>用来求解时间复杂度的</p><p><code>T(n) = a * T(n/b) + O(n^d)</code></p><p>母问题 n 个 数据 &#x3D; a 调用次数 * n&#x2F;b 子问题的规模 + 除子问题外剩下的过程</p><p>这个子问题的规模也就是我们把母问题的数据如何拆分 比如上述题目 我们是拆分为 1&#x2F;2 * n 调用两次</p><p><strong>要满足 master 公式的重要条件是 子问题的规模数量要相同</strong></p><p>logb^a &lt; d &#x3D;&#x3D;&#x3D; O(N^d)</p><p>logb^a &gt; d &#x3D;&#x3D;&#x3D; O(N^logb^a)</p><p>logb^a &#x3D; d &#x3D;&#x3D;&#x3D; O(N^d * logN)</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><ul><li>1、左边排好序</li><li>2、右边排好序</li><li>3、整合<br>这个整合 我们准备一个辅助空间 准备两个指针 把左右两边进行比较 拷贝小的 如果相等就拿左边的 也就是移动左边的指针</li></ul><p>先递归二分，再 merge，merge 的时候考虑边界，也就是哪个指针先走完</p><p><img src="/2023/09/12/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/2023-10-07-22-52-54.png"></p><p>为什么说 O(n^2)的不好，是因为大量的比较只能确定一个数，太浪费了</p><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><ul><li>小和问题</li></ul><p>这个题目也就是给你一个数组 [3,2,1] 找到数组中每个值前面比它小的值，然后累加起来</p><p>这个题目 up 主给出的思路</p><p>转换一下想法 找当前这个数 右侧比它大的数据</p><p><code>[1,3,4,2,5]</code></p><p>以当前数组作为例子<br>依次看<br>1 后面有四个数都比它大 1<em>4<br>3 后面有两个数比它大 2</em>3<br>…</p><p>使用归并排序 然后在 merge 的时候 记录小和数据</p><p>注意点 左组数与右组数指针指向的值数量相等的时候，要保证右组先拷贝，其实也就是两边都排好序了，然后我以左侧作为基准，在右边去找，这样才是准确的</p><p><strong>唯一区别 上述的是找左边的</strong></p><p><img src="/2023/09/12/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/2023-10-07-23-52-04.png"></p><ul><li>逆序对问题<br>在一个数组中，左边的数如果比右边的数大，这两个数据构成一个逆序对，同样的问题</li></ul><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><ul><li><p>荷兰国旗问题（问题 2，因为为什么叫这个名字，因为荷兰国旗有三种）</p></li><li><p>&lt;1&gt; 给定一个数组 arr，和一个数 num，请把小于等于 num 的数放在数组的左边，大于 num 的数放在数组的右边</p></li><li><p>&lt;2&gt; 给定一个数组 arr，和一个数 num，请把小于 num 的数放在数组的左边，等于 num 的放中间，大于 num 的数放在数组右边</p></li></ul><p><strong>重点：没有说要有序</strong></p><p>这两个问题的不同点在于区间的设置</p><ul><li><p>问题 1 中我们只需要一个区间，小于区间</p><p><img src="/2023/09/12/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/2023-10-08-23-52-56.png"></p></li><li><p>问题 2 中我们需要两个区间，小于区间和大于区间，所以中间必定是小于等于 num 的<br><img src="/2023/09/12/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/2023-10-08-23-53-31.png"></p></li></ul><h2 id="快排-1-0"><a href="#快排-1-0" class="headerlink" title="快排 1.0"></a>快排 1.0</h2><p>在一个范围内 拿最后一个数做划分然后交换这个数和第一个大于这个数的位置，递归重复处理这个过程<br><img src="/2023/09/12/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/2023-10-08-23-57-00.png"></p><h2 id="快排-2-0"><a href="#快排-2-0" class="headerlink" title="快排 2.0"></a>快排 2.0</h2><p><img src="/2023/09/12/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/2023-10-08-23-59-20.png"></p><p>和荷兰国旗一致，2.0 版本会更快</p><p>快排的时间复杂度 logO(n^2) 因为存在最差的情况</p><p>快排 1.0 和快排 2.0 的时间复杂度都是 O(n^2)<br>最差的情况就是 123456789 这样</p><p>快排 1.0 和 2.0 都是拿最后一个值做划分值<br>所以最坏的情况就是 123456 这种 那每次只有左边的区域有效，右边都没用</p><p><img src="/2023/09/12/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/2023-10-23-23-21-08.png"></p><h2 id="快排-3-0-O-n-logn"><a href="#快排-3-0-O-n-logn" class="headerlink" title="快排 3.0 O(n*logn)"></a>快排 3.0 O(n*logn)</h2><p>使用 master 公式我们可以得到</p><p>当我们的选取的这个点 打到中间的情况是最好的</p><p><img src="/2023/09/12/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/2023-10-23-23-23-12.png"></p><p>这个情况 n &#x3D; 2 * (n&#x2F;2) + O(n^1) (分区需要排序一次，分区就是上面荷兰的问题)</p><p>这个时候是最好的 也就是 O(n*logn)</p><p>选取的这个值偏左或者偏右都不好</p><p>快排 3.0 随机选一个数 把它跟最右边的数做交换</p><p>快排的空间复杂度 logN 级别</p><p>最差是 O(n)</p><p>递归 递归帮你压栈<br>迭代 迭代要自己压栈</p><h1 id="第三课"><a href="#第三课" class="headerlink" title="第三课"></a>第三课</h1><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆结构<br>完全二叉树</p><p>满的 或者是从左往右是在变满的，就是完全二叉树，也就是不能跳过左边的<br>考虑一个数组 我们把它作为一个完全二叉树，将索引记录为二叉树的值<br>那么位置关系是怎样的</p><p><img src="/2023/09/12/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/2023-10-23-23-24-15.png"></p><p>我们目前说的位置关系也是索引的</p><p>已知索引位置 i<br>左边：2<em>i+1<br>右边：2</em>i+2<br>父：Math.floor（i-1 &#x2F; 2）</p><h3 id="堆是什么"><a href="#堆是什么" class="headerlink" title="堆是什么"></a>堆是什么</h3><p>堆是一个完全二叉树，是一个特殊的完全二叉树</p><h3 id="大根堆"><a href="#大根堆" class="headerlink" title="大根堆"></a>大根堆</h3><p>完全二叉树 子树 -&gt; 从根节点出发 下面的都要，每一颗子节点的最大值就是根节点的值，也就是根节点都是最大的</p><h3 id="小根堆"><a href="#小根堆" class="headerlink" title="小根堆"></a>小根堆</h3><p>每一个子树的最小值都是根节点的值</p><p>将数组生成一个大根堆的数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 已知某个数正处在index的位置 向上继续移动</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">heapInsert</span>(<span class="hljs-params">arr: [], index: string</span>) &#123;<br><span class="hljs-comment">// 循环 如果当前的数大于当前父节点的数</span><br><span class="hljs-keyword">while</span> (arr[index] &gt; arr[(index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>]) &#123;<br><span class="hljs-comment">// 交换数据的值</span><br><span class="hljs-title function_">swap</span>(arr, index, (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);<br><span class="hljs-comment">// 索引往上穿透</span><br>index = (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>题目 1：找到找到大根堆中的最大值，并且删掉该最大值</li></ul><p>解答：</p><ul><li>大根堆中的最大值肯定是第一个，让数组中的第一个和最后一个交换</li><li>然后从上往下去找子节点 比较最大的子节点与根结点的值 进行 index 的向下穿透</li><li>直到没有可比较的节点</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 某个数在index位置 能否往下移动</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">heapify</span>(<span class="hljs-params">arr: [], index: number, heapsize: number</span>) &#123;<br><span class="hljs-keyword">let</span> left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 结束点是最后一个数 已知堆的总长度 那么最后一个数</span><br><span class="hljs-comment">// 左子节点一定比右子节点小 这里其实就在判断我是否有子节点</span><br><span class="hljs-keyword">while</span> (left &lt; heapsize) &#123;<br><span class="hljs-comment">// 继续进行迭代 获取左右孩子的最大值时 首先要考虑不能越界 也就是有没有右子节点</span><br><span class="hljs-keyword">const</span> lasterst =<br>left + <span class="hljs-number">1</span> &lt; heapsize &amp;&amp; arr[left] &gt; arr[left + <span class="hljs-number">1</span>] ? left : left + <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 比较值的大小</span><br>largest = arr[largest] &gt; arr[index] ? largest : index;<br><span class="hljs-comment">// 如果当前这个最大的就是index所在的值，那就不用往下找了</span><br><span class="hljs-keyword">if</span> (lasterst === index) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-comment">// 进行交换 值交换 索引位置交换 往下走</span><br><span class="hljs-title function_">swap</span>(arr, lasterst, index);<br>index = lasters;<br><span class="hljs-comment">// 重新获取left 新的左子节点</span><br>left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 补充一个swap</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">swap</span>(<span class="hljs-params">arr: [], index1, index2</span>) &#123;<br><span class="hljs-keyword">const</span> tmp = arr[index1];<br>arr[index1] = arr[index2];<br>arr[index2] = tmp;<br>&#125;<br></code></pre></td></tr></table></figure><p>进度：47:53</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>控制反转和依赖注入</title>
    <link href="/2023/09/07/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/"/>
    <url>/2023/09/07/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/</url>
    
    <content type="html"><![CDATA[<h2 id="Ioc-是什么"><a href="#Ioc-是什么" class="headerlink" title="Ioc 是什么"></a>Ioc 是什么</h2><p><code>inversion of control</code> 控制反转</p><p>一种设计 用于降低代码间的耦合</p><p>提供一个容器进行依赖对象的创建和查找</p><p>例：<br>A 类在构造方法中使用了 B 类的实例<br>此时我们突然需要在 B 类的构造方法中增加方法<br>那么我们就需要在 AB 类中都增加参数</p><ul><li>这里有一个常用的简单解耦做法就是把 B 的实例直接作为参数传给 A 的构造函数</li></ul><p>如何基于 TypeScript 实现控制反转</p><p>在本篇文章中介绍了容器这个概念</p><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><p>为什么叫控制反转？<br>更多</p><p>zhihu.com</p><p>如何基于 TypeScript 实现控制反转<br>图片来源：<a href="https://bz.zzzmh.cn/">https://bz.zzzmh.cn/</a> 本文作者：陈光通一. 前言最近接到任务，需要给团队封装一个基于 EggJS 的上层 NodeJS 框架，在这个过程中参考了 NestJS 、Midway 等开源项目，发现它们都引入了一项重要特性 ——…<br>18:05</p><p>18:05</p><h1 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h1><p>如何基于 TypeScript 实现控制反转</p><h2 id="Ioc-是什么-1"><a href="#Ioc-是什么-1" class="headerlink" title="Ioc 是什么"></a>Ioc 是什么</h2><p><code>inversion of control</code> 控制反转</p><p>一种设计 用于降低代码间的耦合</p><p>提供一个容器进行依赖对象的创建和查找</p><p>例：<br>A 类在构造方法中使用了 B 类的实例<br>此时我们突然需要在 B 类的构造方法中增加方法<br>那么我们就需要在 AB 类中都增加参数</p><ul><li>这里有一个常用的简单解耦做法就是把 B 的实例直接作为参数传给 A 的构造函数</li></ul><p>在本篇文章中介绍了容器这个概念</p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>对依赖对象进行创建和查找</p><p>这个简单来说就像一个固定功能的盒子</p><p>方便你放相同的东西进去，和拿东西</p><p>当前文章下我们这里的东西就是 ‘类’</p><p>所以我们容器要能够去获取’类’，和注册类</p><h3 id="容器的数据结构"><a href="#容器的数据结构" class="headerlink" title="容器的数据结构"></a>容器的数据结构</h3><p>这里我们认为容器是一个 map 结构</p><p>那我们的注册就是 set</p><p>获取就是 get</p><p>这里会看起来更麻烦就是我们 set 的时候还得写个别名</p><p>但是如果代码很多的话还是没什么问题</p><p>控制反转 &#x3D; 设置一个容器 提供一个空间 能够进行 get 和 set</p><h2 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h2><p>依赖注入</p><p>Ioc 是一种设计规则</p><p>DI 依赖注入是具体实现的方法</p><p><strong>将依赖注入给调用方 而不需要调用方主动获取</strong></p><p>还是以目前文章中的例子来看</p><p>我们需要解决的是两个问题</p><ul><li>需要 set 的类能够自动进行 set</li><li>在 IOC 容器中的类实例化时可以直接拿到依赖对象的实例</li></ul><p>在前端我们可以使用 TS 的装饰器来实现</p><p>在此之前我们先了解一下什么是装饰器</p><h2 id="装饰器类别"><a href="#装饰器类别" class="headerlink" title="装饰器类别"></a>装饰器类别</h2><p>咱们这个装饰器还分好多种</p><ul><li><p>类装饰器</p><p>顾名思义啊 这个就是用来装饰类的<br>这里什么是装饰？ 这里其实就是用于额外的修改类</p><ul><li>比如增加静态属性</li></ul><p>这里也就是说 类装饰器就是一个对类进行处理的函数，只是写法有些不同，默认参数就是目标类</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">@decorator<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;&#125;<br><span class="hljs-comment">// 等同于</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;&#125;<br>A = <span class="hljs-title function_">decorator</span>(A) || A;<br></code></pre></td></tr></table></figure><p>一个参数如果不够用，我们需要加一些额外的参数，就再拿函数包一层</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">testable</span>(<span class="hljs-params">isTestable</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">target</span>) &#123;<br>target.<span class="hljs-property">isTestable</span> = isTestable;<br>target.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">isTestable1</span> = isTestable;<br>&#125;;<br>&#125;<br><br>@<span class="hljs-title function_">testable</span>(ture)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;&#125;<br><span class="hljs-comment">// A.isTestable = true</span><br><span class="hljs-comment">// 如果想增加实例属性</span><br><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title function_">A</span>();<br><span class="hljs-comment">// a.isTestable1 = true</span><br></code></pre></td></tr></table></figure><p>实际上很好理解,把装饰理解为修改就行，装饰器就是一个函数，一定要有的参数就是当前我们想操作的目标</p><p>也可以直接返回一个新类做替换</p><ul><li>方法装饰器<br>基本上和类装饰器一致</li></ul><p>还有几个其他的装饰器</p><p>装饰器只能用于类和类的方法，不能用于函数，因为函数存在函数提升</p><p>这里函数提升不要忘记了 函数声明 <code>function aa()&#123;&#125;</code> 是存在函数提升的，但是函数表达式是没有提升的 <code>const aa = function()&#123;&#125;</code></p><p>暂时我们了解到这里又可以回到我们的文章中，咱又能看了</p><p>到这里就懂了，这个依赖注入其实就是字面意思 依赖的注入 使用装饰器</p><p>实际上这样在开发中感觉并不太直观</p><p>我们以大佬的举例来看，实际用闭包做，功能性和性能都可以等价</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript">@<span class="hljs-title function_">logging</span>(debug)<br>@<span class="hljs-title function_">auth</span>(admin)<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getUserInfo</span>(<span class="hljs-params"></span>)&#123;&#125;<br><br><span class="hljs-comment">// 等价于</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getUserInfo</span>(<span class="hljs-params"></span>) &#123;<br>   <span class="hljs-title function_">logging</span>(debug, <span class="hljs-function">() =&gt;</span> &#123;<br>       <span class="hljs-title function_">auth</span>(admin, <span class="hljs-function">() =&gt;</span> &#123;<br>           <span class="hljs-comment">// getUserInfo本来的业务逻辑</span><br>       &#125;)<br>   &#125;)<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>那就到这里，容器还是一个很好的概念 集中化处理<br>简单做法，直接将类作为参数进行传参<br>高效学习意味着对学习的集中性，信息的有效筛选，以及知识的吸收和运用</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>js-leecode</title>
    <link href="/2023/07/19/js-leecode/"/>
    <url>/2023/07/19/js-leecode/</url>
    
    <content type="html"><![CDATA[<h1 id="记录力扣上刷的-js-题的知识点"><a href="#记录力扣上刷的-js-题的知识点" class="headerlink" title="记录力扣上刷的 js 题的知识点"></a>记录力扣上刷的 js 题的知识点</h1><blockquote><p>无知并不可怕 可怕的是一直无知</p></blockquote><h2 id="for-in-和-for-of-的区别"><a href="#for-in-和-for-of-的区别" class="headerlink" title="for.. in.. 和 for .. of 的区别"></a>for.. in.. 和 for .. of 的区别</h2><p>简单来说</p><ul><li>for .. in 用于遍历对象属性，主要用于对象</li><li>除 symbol 以外的可枚举属性 也就是 Object.keys 能获取到的</li></ul><h2 id="可枚举属性是什么"><a href="#可枚举属性是什么" class="headerlink" title="可枚举属性是什么"></a>可枚举属性是什么</h2><p><a href="https://zhuanlan.zhihu.com/p/47291013">https://zhuanlan.zhihu.com/p/47291013</a></p><ul><li>for .. of 用于可迭代对象，像 Array、Map、Set、String、TypeArray</li><li>区别</li><li>for in 迭代的是可枚举的属性 也就是说如果是数组 这里得到的是索引而不是数组内的值，同时这里如果不做是否是自己的属性，会遍历包括继承得到的属性</li><li>for of 是遍历可迭代对象</li></ul><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...of">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...of</a></p><h2 id="可迭代对象是什么"><a href="#可迭代对象是什么" class="headerlink" title="可迭代对象是什么"></a>可迭代对象是什么</h2><p>现在比较模糊的理解就是像数组那样的数据结构</p><h1 id="2695-包装数组"><a href="#2695-包装数组" class="headerlink" title="2695.包装数组"></a>2695.包装数组</h1><p>这里涉及到 Js 的隐式类型转换，<br>对象进行运算的时候会先尝试用调用对象的 valueof 方法，获取到值然后再进行 Number()的转换处理<br>字符串操作的时候会尝试调用对象的 toString 方法</p><ul><li>隐式类型转换<br><a href="https://juejin.cn/post/7053055316899921934#heading-7">https://juejin.cn/post/7053055316899921934#heading-7</a></li></ul><p>数组的 toString 其实是覆盖 Object.toString()方法，实际上是调用的数组的 join()方法，如果没有 join 方法还是会调用 object 的</p><h1 id="2649-嵌套数组生成器"><a href="#2649-嵌套数组生成器" class="headerlink" title="2649. 嵌套数组生成器"></a>2649. 嵌套数组生成器</h1><h2 id="生成器函数"><a href="#生成器函数" class="headerlink" title="生成器函数"></a>生成器函数</h2><p><code>function*</code> 生成器函数</p><p>调用一个生成器函数 不会执行生成器函数里面的代码 会返回生成器的迭代器对象</p><p>也就是只有 next().value 这样才能拿到值</p><p>yield 也就是相当于生成器函数中的 retrun 只不过调用 next()就会往下走一个</p><p>yield* 将执行权交给另一个生成器 暂停该生成器</p><p>这里也就是相当于跳到另一个生成器里面去 用另一个生成器 yield 返回的值<br>等那个生成器的 yield 用完之后 再继续执行我们这个 把执行权拿回来</p><p>迭代器 next()中如果传参，是传给上一个 yiled 左边的值</p><p>如果用了 return 那就是正常的 return 返回 return 的值 然后 next().done &#x3D; true</p><p>这个生成器函数也叫迭代器函数 所以返回的是一个迭代器对象 就是名字这么叫而已</p><p>这个迭代器对象还能再展开：(没看)<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#iterator">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#iterator</a></p><p>这个题目我还得到了一个 flag 的小技巧<br><code>arr.flat(Infinity)</code> 这样不管是几维数组都可以被扁平化拍成一个数组了<br>不过这个目前看来在某些 ts 版本下是会报类型错误的，大概就是 ts 不认识 Infinity，所以他会给你尝试用各种组合，导致这个报错</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ts</title>
    <link href="/2023/07/19/ts/"/>
    <url>/2023/07/19/ts/</url>
    
    <content type="html"><![CDATA[<h1 id="Ts-相关的知识点"><a href="#Ts-相关的知识点" class="headerlink" title="Ts 相关的知识点"></a>Ts 相关的知识点</h1><h2 id="Record"><a href="#Record" class="headerlink" title="Record"></a>Record</h2><p>这个其实是用来约束 key 和 value 怎么写的<br>那在我们平时开发中可能就直接写一个 interface 了，也是可以的</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">PageInfo</span> &#123;<br>    <span class="hljs-attr">title</span>:<span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Page</span> = <span class="hljs-string">&quot;home&quot;</span> | <span class="hljs-string">&quot;about&quot;</span> | <span class="hljs-string">&quot;contact&quot;</span><br><span class="hljs-keyword">const</span> nav = <span class="hljs-title class_">Record</span>&lt;<span class="hljs-title class_">Page</span>, <span class="hljs-title class_">PageInfo</span>&gt; = &#123;<br>    <span class="hljs-attr">about</span>:&#123;<span class="hljs-attr">title</span>:<span class="hljs-string">&#x27;aa&#x27;</span>&#125;<br>    <span class="hljs-attr">home</span>:&#123;<span class="hljs-attr">title</span>:<span class="hljs-string">&#x27;aa&#x27;</span>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><a href="https://www.jianshu.com/p/ff5ee22b2053">https://www.jianshu.com/p/ff5ee22b2053</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>offset</title>
    <link href="/2023/06/25/offset/"/>
    <url>/2023/06/25/offset/</url>
    
    <content type="html"><![CDATA[<h1 id="折线曲线偏移算法"><a href="#折线曲线偏移算法" class="headerlink" title="折线曲线偏移算法"></a>折线曲线偏移算法</h1><p>最近在研究折线曲线偏移算法 也就是外扩内缩算法</p><p>目前的参考论文有几下几篇</p><h2 id="An-offset-algorithm-for-polyline-curves"><a href="#An-offset-algorithm-for-polyline-curves" class="headerlink" title="An offset algorithm for polyline curves"></a>An offset algorithm for polyline curves</h2><ul><li><p>文档地址 <a href="https://sci-hub.se/10.1016/j.compind.2006.06.002">https://sci-hub.se/10.1016/j.compind.2006.06.002</a></p></li><li><p>代码实现 <a href="https://github.com/jbuckmccready/CavalierContours">https://github.com/jbuckmccready/CavalierContours</a></p></li></ul><h2 id="A-new-offset-algorithm-for-closed-2D-lines-with-Islands"><a href="#A-new-offset-algorithm-for-closed-2D-lines-with-Islands" class="headerlink" title="A new offset algorithm for closed 2D lines with Islands"></a>A new offset algorithm for closed 2D lines with Islands</h2><ul><li><p>文档地址 <a href="https://www.docin.com/p-1356454361.html">https://www.docin.com/p-1356454361.html</a></p></li><li><p>代码实现 <a href="https://blog.csdn.net/qq_41261251/article/details/114462696">https://blog.csdn.net/qq_41261251/article/details/114462696</a></p></li></ul><p>本篇论文提出了两种算法</p><ul><li>1、使用平分线的新偏移算法</li><li>2、一种无效偏移边缘处理算法</li></ul><h2 id="具体算法"><a href="#具体算法" class="headerlink" title="具体算法"></a>具体算法</h2><ul><li><p>1、判断顶点是凸点还是凹点，利用角平分线得到偏移角</p></li><li><p>2、偏移边的有效性，如果偏移边的方向与原始边的方向相反，则为无效边</p><ul><li>原始偏移曲线由偏移点按顺序连接起来，但是无效边不应该在其中<br>无效偏移边的处理算法有分两种情况<ul><li>不存在连续的无效偏移边<br>找到无效偏移边的前向边和后向边，前向边顺着偏移边的方向往后找到的第一个有效偏移边，后向边，偏移边的逆方向找到的第一个有效边<br>延长前向边和后向边得到交点，将这个交点作为前向边的起点，后向边的终点</li><li>存在连续的无效偏移边<br>还是找到这个前向边和后向边<br>找到无效偏移边的原始边，检查所选边是否与有效偏移边是否存在交点，存在交点，偏移该所选边，得到与前向边和后向边的交点，连接成一条新的线</li></ul></li></ul></li><li><p>3、无效环的处理<br>这里不是很明白 需要问一下<br>大致就是会定义一个路径方向，比如为顺时针，如果我们得到的环的方向为逆时针哪就是无效循环，无效的循环会被移除掉</p></li></ul><h2 id="2D-Curve-Offset-Algorithm-for-Pockets-with-Islands-using-a-Vertex-Offset"><a href="#2D-Curve-Offset-Algorithm-for-Pockets-with-Islands-using-a-Vertex-Offset" class="headerlink" title="2D Curve Offset Algorithm for Pockets with Islands using a Vertex Offset"></a>2D Curve Offset Algorithm for Pockets with Islands using a Vertex Offset</h2><ul><li>文档地址 <a href="https://sci-hub.se/10.1007/s12541-009-0037-9">https://sci-hub.se/10.1007/s12541-009-0037-9</a></li></ul><h2 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h2><p>我这边处理的只是轮廊 轮廊包含折线和曲线</p><h2 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h2><p>求线段交点 可使用叉积处理</p><p>求线段方向有效性 可以用点积处理（疑惑点，曲线怎么求有效方向, 曲线似乎一定是）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>力扣矩阵/几何类别的题</title>
    <link href="/2023/06/15/matrixLeetcode/"/>
    <url>/2023/06/15/matrixLeetcode/</url>
    
    <content type="html"><![CDATA[<h1 id="463-岛屿的周长"><a href="#463-岛屿的周长" class="headerlink" title="463. 岛屿的周长"></a>463. 岛屿的周长</h1><p>首先要理解该题目<br>其次要理解二维数组<br>还要考虑二维数组的偏移索引<br>常规解法：迭代 如果是岛屿 我们就去找上下左右四个块 看看是不是水域或者边界，如果是水域或者边界，就+1，（边长）<br>dfs: 深度遍历 dfs 遍历 实际上就是递归 一直往后找 该题目也是找上下左右，从岛屿 找到其他的水域或者边界，周长就+1</p><h2 id="566-重塑矩阵"><a href="#566-重塑矩阵" class="headerlink" title="566 重塑矩阵"></a>566 重塑矩阵</h2><p>这个题目有两个重要的知识点</p><ul><li>fill 的使用，这里我们使用 fill 来创建一个二维数组，fill 的参数如果不是基本数据类型，比如是数组，那么这里我们传递的是数组的引用地址，也就是改动一个，其他的数据也会一起变动，所以我们使用 map 解决</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> newArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">2</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">3</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>));<br><span class="hljs-comment">// [[0,0,0],[0,0,0]] 2行3列</span><br></code></pre></td></tr></table></figure><ul><li><p>二维数组的索引</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> array1 = [<br>[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],<br>[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],<br>];<br><span class="hljs-comment">// 当前数组中所有的数据长度 行*列</span><br><span class="hljs-keyword">const</span> data = array1.<span class="hljs-property">length</span> * array1[<span class="hljs-number">0</span>].<span class="hljs-property">length</span>;<br><span class="hljs-comment">// 第x个元素的值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; data; i += <span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">const</span> x = i;<br><span class="hljs-keyword">const</span> col = array1[<span class="hljs-number">0</span>].<span class="hljs-property">length</span>;<br><span class="hljs-keyword">let</span> val = array[<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(x / col)][x % col];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="812-最大三角形的面积"><a href="#812-最大三角形的面积" class="headerlink" title="812 最大三角形的面积"></a>812 最大三角形的面积</h2><h2 id="向量的叉乘和点乘"><a href="#向量的叉乘和点乘" class="headerlink" title="向量的叉乘和点乘"></a>向量的叉乘和点乘</h2><h3 id="叉乘"><a href="#叉乘" class="headerlink" title="叉乘"></a>叉乘</h3><p>两个向量叉乘会得到一个新的向量，该新向量的方向垂直于向量 1 和向量 2，长度为向量 1 和向量二张成空间的平行四边形的面积<br>叉乘得到的是一个向量，向量是有方向的，所以 A 叉乘 B 不满足交换律<br>A 叉乘 B 得到的向量的方向是满足右手定则</p><p>右手定则 右手指向第一个向量的方向 沿着第二个向量的方向弯曲手指，大拇指所指的方向就是叉乘的方向</p><h3 id="点乘-点积"><a href="#点乘-点积" class="headerlink" title="点乘 点积"></a>点乘 点积</h3><p>A 点乘 B &#x3D; |A| _ |B| _ cos 角度<br>这里我们从几何角度来看也就是 B 在 A 或者是 A 在 B 上的投影再与另一个向量相乘<br>点 点积得到是是一个数</p><h2 id="向量的行列式"><a href="#向量的行列式" class="headerlink" title="向量的行列式"></a>向量的行列式</h2><p>向量张成空间的面积<br>向量之间具有可加性<br><a href="https://www.bilibili.com/video/BV1MY411J72b/?spm_id_from=333.337.search-card.all.click&vd_source=cce0370852a05575ac787ef99b1d8903">https://www.bilibili.com/video/BV1MY411J72b/?spm_id_from=333.337.search-card.all.click&amp;vd_source=cce0370852a05575ac787ef99b1d8903</a></p><p>所以本题我们美美利用行列式的公式来处理,得到的是平行四边形的面积，除 2 得到的就是三角形</p><p>这里在二维空间中存在存在三个向量，行列式最后一项为 1<br>也就是 |x1 y1 1|<br>|x2 y2 1|<br>|x3 y3 1|<br>我们可以用对角线相乘来得到结果<br><code>const res = x1 * y2 + x2 * y3 + x3*y1 - x1 *y3 - x2 *y1 -x3*y2</code><br>遍历这个三个点就能得到最后的答案 这里还有一个坑 面积一定要是正整数</p></li></ul><h2 id="矩形重叠"><a href="#矩形重叠" class="headerlink" title="矩形重叠"></a>矩形重叠</h2><p>这个题目我们去考虑边界，会发现是一道很简单的题<br>从这个简单题中我们可以找到一个新的名词 交并比</p><h3 id="什么是交并比-怎么理解"><a href="#什么是交并比-怎么理解" class="headerlink" title="什么是交并比 怎么理解"></a>什么是交并比 怎么理解</h3><p>A，B 分别为两个集合<br>IOU &#x3D; A 与 B 的交集&#x2F;A 与 B 的并集<br>IOU 的交集 &#x3D; 0 完全没有重叠<br>IOU 的交集 &#x3D; 1 完全重叠<br><a href="https://paddlepedia.readthedocs.io/en/latest/tutorials/computer_vision/object_detection/IOU.html">https://paddlepedia.readthedocs.io/en/latest/tutorials/computer_vision/object_detection/IOU.html</a></p><p>这里我们假设如果两个矩形存在交点<br>那么左上的 Xa 点 &#x3D; Math.max(xm1,xn1)<br>右下的 Xb 点 &#x3D; Math.min(xm2,xn2)</p><p>那么存在交点,同理 y 轴也一样<br>Xb - Xa &gt; 0</p><h2 id="883-三维形体投影面积"><a href="#883-三维形体投影面积" class="headerlink" title="883. 三维形体投影面积"></a>883. 三维形体投影面积</h2><p>此题用的暴力解法，没有技巧，只有暴力<br>如果不理解行和列可以把二维数组写为矩阵就很清晰<br>grid.length 为行<br>grid[0].length 为列<br>遍历得到 xy 区域的面积 grid[i][j] !&#x3D;&#x3D; 0<br>遍历得到 xz 区域的面积 这里也就是求每列中的最大值<br>遍历得到 yz 区域的面积 这里求每行的最大值 先遍历列再遍历行</p><h1 id="892-三维形体的表面积"><a href="#892-三维形体的表面积" class="headerlink" title="892. 三维形体的表面积"></a>892. 三维形体的表面积</h1><p>这个题我纯暴力解法，找到当前这个块的前一行前一列的覆盖面，有就剪掉<br>这里不要忽略叠加的上下覆盖面积的就行</p><h1 id="1030-距离顺序排列矩阵单元格"><a href="#1030-距离顺序排列矩阵单元格" class="headerlink" title="1030. 距离顺序排列矩阵单元格"></a>1030. 距离顺序排列矩阵单元格</h1><p>这里我用的直接排序法，遍历求索引，计算距离然后使用 sort</p><h2 id="array-sort-的时间复杂度为什么是-O（n-log-n）"><a href="#array-sort-的时间复杂度为什么是-O（n-log-n）" class="headerlink" title="array.sort 的时间复杂度为什么是 O（n log n）"></a>array.sort 的时间复杂度为什么是 O（n log n）</h2><p><a href="https://segmentfault.com/a/1190000010648740/">https://segmentfault.com/a/1190000010648740\</a><br>emm..总之每个浏览器的算法实现不太一样</p><h2 id="哈曼顿距离是什么"><a href="#哈曼顿距离是什么" class="headerlink" title="哈曼顿距离是什么"></a>哈曼顿距离是什么</h2><p>也叫做出租车距离，标明两个点在标准坐标系上的<code>绝对轴距总和</code><br>也就是两个点之间的距离，用 x 轴和 y 轴计算的距离来确定<br><code>d(i,j)=|xi - xj| + |yi - yj|</code></p><h2 id="桶排序是什么"><a href="#桶排序是什么" class="headerlink" title="桶排序是什么"></a>桶排序是什么</h2><p>算法相关阅读<br><a href="http://data.biancheng.net/array_list/">http://data.biancheng.net/array_list/</a></p><p><a href="https://zhuanlan.zhihu.com/p/125737294">https://zhuanlan.zhihu.com/p/125737294</a><br>桶排序感觉就是把一个大数据，按照一定的范围划分，处理为一些个小数据放到桶中（小桶），然后在小桶中（非空桶）处理排序好再合并成大数据</p><p>可以做桶排序处理</p><h1 id="1232-缀点成线"><a href="#1232-缀点成线" class="headerlink" title="1232. 缀点成线"></a>1232. 缀点成线</h1><p>已知 A(x1,y1)、B(x2,y2)两点<br>向量 AB &#x3D; (x2 - x1, y2 -y1); B - A<br>这个题目是至少有一条线的 两个向量的行列式为 0 则为共线<br>这里我们只要判断行列式 行列式为 0 那就<br><a href="https://blog.csdn.net/qq_44691917/article/details/104686146">https://blog.csdn.net/qq_44691917/article/details/104686146</a><br><a href="https://zhidao.baidu.com/question/1950383038479802228.html">https://zhidao.baidu.com/question/1950383038479802228.html</a></p><p>这里关于向量的积其实是有两种的</p><ul><li>数量积 点积<br>A B &#x3D; x1<em>x2 + y1</em>y2<br>几何意义：|a|*|b|*cosθ b 在 a 或者 a 在 b 方向上的投影<br>这里就可以用来判断两个向量之间的夹角大小<br>点积描述的是 A，B 的共线程度</li><li>向量积 叉积 描述的是垂直程度</li></ul><h1 id="1266-访问所有点的最小时间"><a href="#1266-访问所有点的最小时间" class="headerlink" title="1266. 访问所有点的最小时间"></a>1266. 访问所有点的最小时间</h1><h2 id="欧式距离、曼哈顿距离、切比雪夫距离相关解释"><a href="#欧式距离、曼哈顿距离、切比雪夫距离相关解释" class="headerlink" title="欧式距离、曼哈顿距离、切比雪夫距离相关解释"></a>欧式距离、曼哈顿距离、切比雪夫距离相关解释</h2><p><a href="https://cloud.tencent.com/developer/article/1524568">https://cloud.tencent.com/developer/article/1524568</a></p><p>在这个题目中不要被这个看着很可怕的题目吓到了，这里也就是求最短移动距离，这里前后左右斜着走都是一样的为 1，显然走斜边会更快<br>所以这里我们使用切比雪夫距离 这个来做<br>假设点为<code>a:x1,y1</code>,<code>b:x2,y2</code><br>那么 a 移动到 b 的最短距离只和为<br><code>dx = |x1 - x2|</code><br><code>dy = |y1 - y2|</code><br><code>max(dx,dy)</code></p><h1 id="223-矩形面积"><a href="#223-矩形面积" class="headerlink" title="223. 矩形面积"></a>223. 矩形面积</h1><p>这个和之前矩形重叠那个差不多，重温一遍发现自己并没有弄明白<br>这个最巧妙的位置在于 将矩形变换为 x 轴上的投影和 y 轴上的投影</p><p>画图之后我们能够很直观的感受到重叠是怎么样的 不重叠是怎么样的</p><p>这里需要注意的是 对于两个矩形的位置关系 谁在前谁在后其实并不知道</p><p>所以我们使用 <code>Math.min</code> <code>Math.max</code> 来确定</p><p>以 x 轴为例 首先是对于一个矩形 从题意描述的位置关系 给的坐标 一个在左下角，一个在右上角一定是 <code>x1 &lt; x2</code> 的</p><p>所以如果<code>Math.min(ax2,bx2) &gt; Math.max(ax1,bx1)</code>这种情况下 一定是重叠，y 轴同理</p><p>如果两个矩形存在重叠区域，我们依然可以画个图</p><p>那么它重叠区域 x 的坐标 <code>Math.max(ax1,bx1)、 Math.min(ax2,bx2)</code>，y 值同理，画图非常直观</p><h1 id="593-有效的正方形"><a href="#593-有效的正方形" class="headerlink" title="593 有效的正方形"></a>593 有效的正方形</h1><p>本题有三种方法<br>1、先试用巧妙的旋转法</p><ul><li>找到中点坐标，移动到原点，记录所有点的坐标，旋转后也应该在该数组内</li><li>旋转 90 度后所有的点都还在<h3 id="2D-平面下的旋转"><a href="#2D-平面下的旋转" class="headerlink" title="2D 平面下的旋转"></a>2D 平面下的旋转</h3><a href="https://blog.csdn.net/scut_salmon/article/details/100406459">https://blog.csdn.net/scut_salmon/article/details/100406459</a></li></ul><p>2、找三个顶点，判断是否是直角三角形</p><p>3、正方形判断定理</p><ul><li>斜边的中点相同，则说明两条斜边组成的四边形为平行四边形</li><li>两条斜边的长度相同，说明为矩形</li><li>两条斜边相互垂直，为正方形<br>这题看太久已经疲了 只用了解法 1 来处理，如果有需要后面再看看</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>leetcode</title>
    <link href="/2023/05/24/leetcode/"/>
    <url>/2023/05/24/leetcode/</url>
    
    <content type="html"><![CDATA[<h2 id="大-O-表示法"><a href="#大-O-表示法" class="headerlink" title="大 O 表示法"></a>大 O 表示法</h2><p>对算法的效率进行衡量</p><p>企业规模概述：小型&#x2F;中型&#x2F;大型</p><p>在不说明具体员工数量或者占地面积的情况下，我们可以通过大概这样（上述）的概率来描述企业的规模</p><p>在计算机中也可以通过类似的快捷方式来描述计算机算法的效率 也就是大 O 表示法</p><p>首先要知道 在数据量不同的情况下，算法的效率也是会变的</p><p>算法的效率：</p><p><strong>算法的速度</strong> 与 <strong>数据量变化</strong> 之间的关系</p><p>其实也就是 我要找查找多少次才能找到我想要的数据</p><p>遍历 n 次找到 那就是 O(n)<br>使用二分查找 那就是 O(log(n))<br><a href="https://juejin.cn/post/6844903481191432206">https://juejin.cn/post/6844903481191432206</a></p><h2 id="常见的大-O-表示函数"><a href="#常见的大-O-表示函数" class="headerlink" title="常见的大 O 表示函数"></a>常见的大 O 表示函数</h2><p>O 可以理解为一个函数</p><p>O(1) 常数的<br>O(log(n)) 对数的<br>O(n) 线性增长<br>O(nlog(n)) 线性和对数成绩<br>O(n^2) 平方<br>O(2^n) 指数</p><p>用 O(1)代替所有的常量<br>在修改后的运行次数函数中，只保留最高阶<br>如果最高存在且不为 1，则去除这项相乘的常数 2n^2 + n ）O(n^2)</p><h2 id="力扣题目记录"><a href="#力扣题目记录" class="headerlink" title="力扣题目记录"></a>力扣题目记录</h2><p>最近开始刷算法题了，太菜啦，虽然焦虑，但是还是要一步步提升自己，此处记录一下相关题目</p><h2 id="双指针算法"><a href="#双指针算法" class="headerlink" title="双指针算法"></a>双指针算法</h2><p>核心思想是使用两个指针，分别指向不同的元素</p><ul><li><p>快慢指针</p></li><li><p>还有 对撞指针，从数组两头向中遍历</p></li><li><p>还有 滑动窗口，遍历相同的数组但是不会相交</p></li></ul><h2 id="26-删除数组中的重复项"><a href="#26-删除数组中的重复项" class="headerlink" title="26.删除数组中的重复项"></a>26.删除数组中的重复项</h2><ul><li>这个用的快慢指针</li></ul><h2 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a>27. 移除元素</h2><ul><li>这个用的快慢指针</li><li>这个还可以使用对撞指针，因为不需要管排序，就是只要数组中的数据等于当前条件给的值，那我们就把它替换成我们没有用过的值</li><li>这个最简单的还是 splice(移除或者替换) 一下，就地改变数组，返回删除的元素</li><li>toSpliced 和 splice 一样，但是是返回一个新数组</li><li>这里容易根 slice(片段化) 搞混， slice 是提取某一部分，返回一个新数据（数组&#x2F;字符串），包含 start 不包含 end，参数为负数则反着取，end 小于 start 就不返回，不写或者超出数据长度，最长就是数据长度</li></ul><h2 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35. 搜索插入位置"></a>35. 搜索插入位置</h2><ul><li>二分查找 前提 是一个有序序列，从中间找最重要的步骤就是指针 mid &#x3D; left + ((right - left)&gt;&gt;1)</li></ul><h2 id="27-移除元素-1"><a href="#27-移除元素-1" class="headerlink" title="27 移除元素"></a>27 移除元素</h2><p>String 的相关操作<br>split 切割为数组 什么都不传 数组没有这个方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;Hello World&#x27;</span>;<br>str.<span class="hljs-title function_">split</span>(); <span class="hljs-comment">// [&#x27;Hello World&#x27;]</span><br>str.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;&#x27;</span>); <span class="hljs-comment">// [&#x27;H&#x27;,&#x27;e&#x27;...]</span><br>str.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27; &#x27;</span>); <span class="hljs-comment">// [&#x27;Hello&#x27;, &#x27;World&#x27;]</span><br></code></pre></td></tr></table></figure><p>slice 片段化 也就是提取数据中的一部分 负数就是拿数组总长度去剪<br>Array 的操作<br>at 传参整数 找到数组中的索引 为负数则从最后一个倒着找 -1 就是最后一个</p><h2 id="66-加一"><a href="#66-加一" class="headerlink" title="66 加一"></a>66 加一</h2><p>方法一：转换为字符串再转换为数字，这个要考虑的是字符串转数字后会超出范围的情况，题目是整数，所以可以用 BigInt 来转换<br>方法二：就是纯数组操作了，需要注意的就是进位问题</p><h2 id="67-二进制求和"><a href="#67-二进制求和" class="headerlink" title="67 二进制求和"></a>67 二进制求和</h2><p>js 中的最大安全是 2^53 - 1<br>超过这个范围的整数运算结果就会不准确<br><code>2**53 === 2**53 + 1 // true</code><br>字符串转数字这里一定要考虑转数字之后的范围超出问题<br>js 已经封装的十进制与二进制的转换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 二进制转十进制</span><br><span class="hljs-comment">// parseInt这个是指 值是多少，我该以什么进制来处理当前这个数字，然后再转回十进制</span><br><span class="hljs-comment">// 也就是将100看作是二进制数，再转换为十进制</span><br> <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;100&#x27;</span>,<span class="hljs-number">2</span>);<br><span class="hljs-comment">// 十进制转二进制 toString 将十进制转换为对应进制的字符串类型</span><br>‘<span class="hljs-number">10</span>’.<span class="hljs-title function_">toString</span>(<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>所以使用了 BigInt 处理，<br>这里还需要知道的是一个前缀，0B，0b 是二进制，0 是八进制，0X，0x 是十六进制<br>这个目前为只用了这个方式处理</p><h2 id="69-x-的平方根"><a href="#69-x-的平方根" class="headerlink" title="69 x 的平方根"></a>69 x 的平方根</h2><ul><li>二分查找<br>这里有个需要注意的地方 mid 的计算<br>超过最大或者最小范围就会溢出<br>这里我们需要考虑溢出情况 所以不使用 (right + left) &gt;&gt; 1<br>使用 left + ((right - left) &gt;&gt; 1)</li></ul><p>考虑溢出 所以使用 x&#x2F;mid &gt; mid 这样处理<br>解法二：牛顿迭代 这个没有特别仔细看</p><h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70 爬楼梯"></a>70 爬楼梯</h2><p>解法一：<br>动态规划 Dynamic Programming<br>也就是把一个大问题，变成很多子问题，然后解决子问题，最终得到大问题的答案<br>这里我们首先分析题目 找找规律 然后会发现 d[i] &#x3D; d[i-1]+d[i-2]<br>动态规划最重要的就是记忆化搜索 这里是使用数组记录了数据, 还可以不用数组，直接挪动指针那样处理，但是还是使用数组更清晰，还有就是边界判断非常重要</p><p>这里还可以递归，本质上能够使用动态规划的都可以使用递归暴力推断，这里要注意的还是要记录已递归的数据，不然会超时</p><p>解法二：<br>数学规律<br>斐波那契数列 公式法<br>Math.sqrt 开方<br>Math.pow(x, y) x 的 y 次幂</p><h2 id="83-删除排序链表中的重复元素"><a href="#83-删除排序链表中的重复元素" class="headerlink" title="83 删除排序链表中的重复元素"></a>83 删除排序链表中的重复元素</h2><p>指针题，这里要注意的是链表的表头是不能跑的，所以需要再创建一个指针来指向相同的引用地址，这个指针是一直向后遍历的（向后走），遍历过程中根据条件去改变链表的数据，返回这个链表实际上还是返回这个链表的表头，链表由表头来进行表示</p><h2 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88 合并两个有序数组"></a>88 合并两个有序数组</h2><p>解法一：直接合并数组再进行排序<br>这里注意 splice 的使用 num.splice(start, delcount, replaceData1,replaceDate2)</p><p>解法二：指针 这里其实倾向是考指针<br>指针相关的方法，我觉得最主要的考虑还是一个边界问题；</p><ul><li>双指针 从头开始，把两个数组当作两个队列，创建一个新的数据，长度 m+n,依次往里面添加元素</li><li>逆向双指针 从末尾开始，该题目的前提是 num1 的长度是大于 m+nssm+nss, 这个感觉思维上不是那么好理解，再写可能还是会用正向的双指针,其实也就是正着来处理，你可能需要往原数组中添加元素，反着来不会去破坏数组结构，是一样的；</li></ul><h2 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94 二叉树的中序遍历"></a>94 二叉树的中序遍历</h2><p>首先要知道的是二叉树的遍历有哪几种<br>前序遍历：中 左 右<br>中序遍历：左 中 右<br>后序遍历：左 右 中</p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>当想要使用递归的时候，我们应该考虑什么</p><ul><li>递归的参数，递归的返回值</li><li>考虑递归终止的条件，如果不这样处理很容易出现栈溢出的情况</li><li>考虑递归我们处理的信息是什么</li></ul><h4 id="递归的特点"><a href="#递归的特点" class="headerlink" title="递归的特点"></a>递归的特点</h4><ul><li>函数要间接或者直接的调用自身</li><li>要设置终止条件，我们每一个调用这个函数都是为了更接近这个终止条件</li><li>不满足这个终止条件，我们则继续调用这个函数</li></ul><h3 id="栈-先进后出"><a href="#栈-先进后出" class="headerlink" title="栈 先进后出"></a>栈 先进后出</h3><p>这个题目的考点其实是栈 用栈 迭代</p><h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><p>迭代和递归都是循环，在循环量比较大的情况下，迭代的效率比递归更好</p><p>迭代与普通循环的区别</p><p>迭代中参与运算的变量和保存结果的变量是同一个变量，当前保存的结果是下次迭代的初始值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">let</span> sum = <span class="hljs-number">1</span>; <span class="hljs-comment">// 参与运算的变量</span><br><span class="hljs-keyword">let</span> i = <span class="hljs-number">100</span>; <span class="hljs-comment">// 参与运算的变量</span><br><span class="hljs-keyword">while</span> (i &gt; <span class="hljs-number">0</span>) &#123;<br>   sum ++; <span class="hljs-comment">// 保存结果的变量</span><br>   i --;<br>&#125;<br></code></pre></td></tr></table></figure><p>递归是函数调用自身函数<br>迭代是函数内某段代码实现循环</p><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><p>按规则访问每一项目</p><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><p>一切重复行为</p><h4 id="题外-产品中的迭代"><a href="#题外-产品中的迭代" class="headerlink" title="题外 产品中的迭代"></a>题外 产品中的迭代</h4><p>传统开发，纯线性的 开发 -&gt; 测试上线<br>迭代是把一个大的目标 分为一些小目标，来进行单独的设计-&gt;开发-&gt;测试，进行多次这周周期性的操作完成一个软件产品的最终发布，迭代式开发更灵活，更能适应突然的需求变更之类的</p><h2 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144 二叉树的前序遍历"></a>144 二叉树的前序遍历</h2><h2 id="145-二叉树的后续遍历"><a href="#145-二叉树的后续遍历" class="headerlink" title="145 二叉树的后续遍历"></a>145 二叉树的后续遍历</h2><p>这三个其实是一样的，我这边选择美美用迭代法处理<br>前序：遍历找到最后一个左子节点，在这个过程中就把根节点 push 进结果，将左节点依次入栈里面，然后弹出，每弹出一个，就把指针指向右子节点，重复再去找左子节点，套两个 while<br>中序：和上面一样，只不过 push 结果的位置放在了左子节点弹出的时候<br>后序：这里和前序放过来想，前序是中左右，我们只要改为中右左，再进行 reverse 就能拿到正确的数据，所有这里我们把右节点依次入栈，再把指针指向左节点，重复去找右节点</p><p>总之 没有那么复杂，把指针美美用起来</p><h2 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100. 相同的树"></a>100. 相同的树</h2><p>这个题一拿到，唯唯诺诺的我立刻重拳处理，这不是刚学的树的遍历吗，还热乎的，于是我马上写了一个前序遍历，打算比较一下两颗树前序遍历的结果，点击提交，测试结果对我重拳出击<br>这里对树节点的遍历是忽略了空节点的，所以拿到的结果就不准确了<br>比如两棵树，[1,2],[1,null,2]</p><p>首先了解两个基本概念：</p><ul><li>广度优先算法</li><li>深度优先算法</li><li><a href="https://cloud.tencent.com/developer/article/1930785">https://cloud.tencent.com/developer/article/1930785</a></li></ul><p>我们直接拿一个树结构来当作参照物<br>广度优先算法 就是按照每一层一层的节点来进行遍历<br>深度优先算法 就是一条路一直找到最下面的所有的都找完了又会到第一个根节点，再去找另外的</p><p>这里是直接采用深度优先的处理，直接递归去找到左&#x2F;右节点值然后进行对比</p><h2 id="101-对称的二叉树"><a href="#101-对称的二叉树" class="headerlink" title="101. 对称的二叉树"></a>101. 对称的二叉树</h2><ul><li><p>递归 将树拆开来看 对比左右，右左节点<br>递归这里用了指针思想，考虑有两个指针 p 和 q，他们的起点相同，走向的方位不同<br>p 左走 q 向右 p 右走 q 左走 对比值是否相等 相等继续往下找 不想等就直接 return false</p></li><li><p>迭代</p><ul><li>引用队列（栈）是把递归程序改写为迭代程度的常用方法<br>其实感觉差不多 该用队列也就是注意什么时候进栈 什么时候出栈 出栈之后要做什么<br>那在本题中 进栈 也就是我们把节点加进去（除去根节点&#x2F;左右节点都需要入栈 进行两两比较）<br>出栈也就是栈内存在内容 就需要继续进行 while 循环 此处我们是两两入栈进行比较 所以要两两出栈<br>出栈之后我们要进行值的比较 特殊情况是都为 null 的时候此时循环还需要继续执行 其中一方为 null 或者值不相等 就 return false<br>出栈之后 继续把剩下的节点继续进行进栈操作</li></ul></li></ul><h2 id="28-找出字符串中第一个匹配项的下标"><a href="#28-找出字符串中第一个匹配项的下标" class="headerlink" title="28. 找出字符串中第一个匹配项的下标"></a>28. 找出字符串中第一个匹配项的下标</h2><ul><li>js 偷懒法 indexOf 一把梭</li><li>暴力遍历法 找到小的那个数据 然后双重遍历 做匹配</li><li>kmp 算法 还没看</li><li><a href="https://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html">https://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html</a></li></ul><h2 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a>104. 二叉树的最大深度</h2><p>这里首先需要了解两个概念</p><ul><li>树的高度</li><li>树的深度</li><li><img src="/2023-08-09-00-03-57.png"></li></ul><p>一棵树的最大深度 &#x3D; 根节点的高度+左右子树中最大的深度<br>那这个问题就变成了求深度<br>有两种方法解决这个问题</p><ul><li><p>递归法<br>递归需要注意什么 需要注意递归的结束条件<br>脑子转不动系列：<br><a href="https://www.bilibili.com/video/BV1UD4y1Y769/?vd_source=cce0370852a05575ac787ef99b1d8903">https://www.bilibili.com/video/BV1UD4y1Y769/?vd_source=cce0370852a05575ac787ef99b1d8903</a></p></li><li><p>bfs 广度优先遍历<br>&lt; 这里再介绍一下广度优先遍历和深度优先遍历 因为我已经忘记了</p><ul><li>广度优先遍历 一层层去找</li><li>深度有限遍历 一条路走到底</li></ul></li></ul><h1 id="581-最短无序连续子数组"><a href="#581-最短无序连续子数组" class="headerlink" title="581. 最短无序连续子数组"></a>581. 最短无序连续子数组</h1><p>最近比较懈怠 这个是看 b 站左程云老师讲的<br>这个其实没什么特别的 一道双指针题<br>主要就是要想清楚 什么时候指针该动<br>以及 两个方向去遍历</p><ul><li><p>从左到右去遍历 我们找最大值 如果下一个值比当前的最大值小 指针移动</p></li><li><p>从右到左去遍历 我们找最小值 如果下个值比当前的最小值大 指针移动<br>特殊情况 注意数组为 1 的情况 不需要排序<br>其他情况 higt &gt; low ? higt - low + 1 : 0</p><p><a href="https://www.bilibili.com/video/BV1CG411Z7zH/?spm_id_from=333.999.0.0&vd_source=cce0370852a05575ac787ef99b1d8903">https://www.bilibili.com/video/BV1CG411Z7zH/?spm_id_from=333.999.0.0&amp;vd_source=cce0370852a05575ac787ef99b1d8903</a></p></li></ul><h1 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169. 多数元素"></a>169. 多数元素</h1><p>排序类的题 需要看一下摩尔投票法</p><h2 id="摩尔投票法"><a href="#摩尔投票法" class="headerlink" title="摩尔投票法"></a>摩尔投票法</h2><p>也叫多数投票法<br>这个算法很有意思</p><p>核心我们看作为是对抗消耗，也就是数组中不同的数据进行相互抵消</p><p>通俗来说可以看做是选举，根据票数来选择候选人</p><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p><strong>这个多数元素在数组中重复出现，且占据了数组元素的一半以上</strong></p><p>首先需要知道这个算法的应用场景，这个算法实际上是用来求这个多数元素的</p><p>这里其实也就是众数</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>这里其实是分两步</p><ul><li>找出多数元素</li><li>进行验证</li></ul><h2 id="补充抽屉原理"><a href="#补充抽屉原理" class="headerlink" title="补充抽屉原理"></a>补充抽屉原理</h2><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>类型化数据</title>
    <link href="/2023/04/28/ArrayBuffer/"/>
    <url>/2023/04/28/ArrayBuffer/</url>
    
    <content type="html"><![CDATA[<p>本次是第三次重新树立这部分内容</p><h2 id="类型化数据"><a href="#类型化数据" class="headerlink" title="类型化数据"></a>类型化数据</h2><p>js 用来为开发者提供一个操作二进制数的一个借口</p><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><h3 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h3><p>也就是一个提前预设了大小的内存块<br>有两种类型的缓冲</p><ul><li>&lt;1&gt; ArrayBuffer 可以当作是单向的一个 buffer 因为转移后就会失效 那么同一时刻，它只会在某一个执行上下文中，多线程同时访问一个内存块的时候，要使用 atomics</li><li>&lt;2&gt; sharedAarryBuffer 其实可以看作是一个全局缓冲 所以不存在转移<br>支持以下操作</li><li>分配 <code>new ArrayBuffer()</code> 初始值为 0</li><li>复制 <code>slice()</code></li><li>转移 <code>transfer()</code> <code>transferToFixed()</code> 可以已传参为例子 A 函数的 Abuffer 想在 B 函数中（不同的执行上下文）给另一个 Bbuffer 使用，转移后 Abuffer 就不能用了，</li><li>调整大小 resize() 可以调整内存块的大小 但是不能超过我们提前预设的内存的最大字节长度</li></ul><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>视图的类型包括，视图也就是对 arrayBuffer 的读写操作</p><ul><li>数据类型</li><li>起始偏移量</li><li>元素数量</li></ul><p>目前主要有两种视图</p><h4 id="类型化数组视图"><a href="#类型化数组视图" class="headerlink" title="类型化数组视图"></a>类型化数组视图</h4><blockquote><p>也就是 TypedArray</p></blockquote><h5 id="TypedArray"><a href="#TypedArray" class="headerlink" title="TypedArray"></a>TypedArray</h5><p>类数组对象 TypedArray 中元素值的类型都相同</p><p>共有以下十种具体的 TypedArray</p><ul><li>Int8Array</li><li>Uint8Array</li><li>Uint8ClampedArray 8 位无符号<strong>整型</strong>固定数组 如果你指定一个在 [0,255] 区间外的值，它将被替换为 0 或 255</li><li>Int16Array</li><li>Uint16Array</li><li>Int32Array</li><li>Uint32Array</li><li>Float32Array</li><li>Float64Array</li><li>BigInt64Array</li><li>BigUint64Array</li></ul><blockquote><p>前置知识</p></blockquote><ul><li>有符号数 可以区分正负值 例如 -128 - 127 最高位表示正负号，为 1 时，该值为负数</li><li>无符号数 只有正值 0-255<br>一个字节 &#x3D; 8bit</li><li><a href="https://www.cnblogs.com/lazycoding/archive/2011/03/21/unsigned-signed.html">https://www.cnblogs.com/lazycoding/archive/2011/03/21/unsigned-signed.html</a></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 分配一个16个字节的内存 创建一个缓冲</span><br><span class="hljs-keyword">let</span> buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">16</span>);<br></code></pre></td></tr></table></figure><p>视图使用上分为以下几种情况</p><h3 id="1、使用-arrayBuffer"><a href="#1、使用-arrayBuffer" class="headerlink" title="1、使用 arrayBuffer"></a>1、使用 arrayBuffer</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 将buffer视为一个32位的整数序列 打印可以看到转换为了四个为0的整数</span><br><span class="hljs-comment">// 这里可以这么理解 我现在有一个16字节的缓冲，如果我用一个Unit32Array去构建，表示的就是4个字节 那么我能够得到4个数据</span><br><span class="hljs-keyword">let</span> view = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint32Array</span>(buffer);<br><span class="hljs-comment">// 设置偏移字节为4 也就是从第四个字节开始读 也就是跳过第一个数据，读取两个数据长度，这里注意Unit32Array表示的就是4个字节一个数据</span><br><span class="hljs-comment">// 这里的偏移一定要和约束的字节长度一致 比如当前uint32Array 是以每四个字节作为一个数</span><br><span class="hljs-keyword">let</span> view2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint32Array</span>(buffer, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><h3 id="2、使用数组"><a href="#2、使用数组" class="headerlink" title="2、使用数组"></a>2、使用数组</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> view = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint32Array</span>([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br><span class="hljs-comment">// 这里是已经转换成为视图的数据 所以我们能直接看到塞了四个整数</span><br><span class="hljs-comment">// 这种情况下 存在的字节数量是4*4 这里就不存在什么偏移了 因为不是buffer</span><br><span class="hljs-comment">// 通过view[0]之类的数组操作可以直接拿到数组数据</span><br></code></pre></td></tr></table></figure><h3 id="3、使用另一个视图"><a href="#3、使用另一个视图" class="headerlink" title="3、使用另一个视图"></a>3、使用另一个视图</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> view = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint32Array</span>([<span class="hljs-number">0</span>, <span class="hljs-number">1000</span>]);<br><span class="hljs-keyword">let</span> view2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>(view);<br><span class="hljs-comment">// 相当于是一个复制操作 但是这种不同字节长度的需要注意 比如Uint8Array的字节范围是0-255 这个1000就塞不进去 会转换成别的，这里转换为的是232 原因如下</span><br></code></pre></td></tr></table></figure><p>转化的问题 存在一个越界行为的约束</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num = <span class="hljs-number">1000</span>;<br><span class="hljs-comment">// 转化为2进制</span><br><span class="hljs-keyword">let</span> num2 = num.<span class="hljs-title function_">toString</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// 1111101000</span><br><span class="hljs-comment">// uint8最多只能保存8位的二进制数所以范围为0-255</span><br><span class="hljs-comment">// 所以只保留最后8位 其他部分切掉</span><br><span class="hljs-comment">// 切掉后重新转换为转换为2进制数 232</span><br><span class="hljs-built_in">parseInt</span>(num2, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><h3 id="4、直接使用数字"><a href="#4、直接使用数字" class="headerlink" title="4、直接使用数字"></a>4、直接使用数字</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> view = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint16Array</span>(<span class="hljs-number">4</span>);<br><span class="hljs-comment">// 相当于就是创建了4个为0的整数数据 字节长度是 4*2 数据长度是4</span><br></code></pre></td></tr></table></figure><h3 id="5、不带任何参数"><a href="#5、不带任何参数" class="headerlink" title="5、不带任何参数"></a>5、不带任何参数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> view = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint32Array</span>();<br><span class="hljs-comment">// 创建一个长度 字节数都为0的类型化数组</span><br></code></pre></td></tr></table></figure><p>虽然我们可以直接创建 TypedArray，没有自己去创建 ArrayBuffer，但是视图层是离不开底层 ArrayBuffer 的，在没提供 ArrayBuffer 的场景下，都会自动创建</p><p>可以通过<code>arr.buffer</code> 查看引用的是哪个<br>可以通过<code>arr.byteLength</code> 查看引用 buffer 的长度</p><p>视图之间可以进行相互转化<br>这是什么意思呢 我们可以知道视图是服务于 ArrayBuffer,只要我们拿到一个 buffer，可以用各种不同的方式去查看她</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr8 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br><span class="hljs-comment">// [0,1,2,3]</span><br><span class="hljs-keyword">let</span> arr16 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint16Array</span>(arr8.<span class="hljs-property">buffer</span>);<br><span class="hljs-comment">// [256, 770]</span><br></code></pre></td></tr></table></figure><p><strong>至于怎么转化的现在还不知道</strong></p><p>TypedArray 具有常规的数组方法</p><p>可以进行遍历 map slice(切分 返回一个新的数组，前面的索引包含，后面的索引不包含) find ruduce 之类的</p><p>没有的</p><ul><li>splice 没有删除和替换 因为缓冲区是固定的，我们能做的只有分配</li><li>concat 没有聚合</li></ul><p>简单来说类数组的大小是固定的 改变内存大小这些方法是没有的</p><p>新增的</p><ul><li><p>arr.set(forArr, [offset]) offset 的处理不太明白</p><p>这里 offset 可以理解为下标索引 并且要考虑长度</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr16 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint16Array</span>([<span class="hljs-number">1</span>, <span class="hljs-number">1000</span>, <span class="hljs-number">1001</span>, <span class="hljs-number">1002</span>]);<br><span class="hljs-keyword">let</span> arr18 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint16Array</span>([<span class="hljs-number">2</span>, <span class="hljs-number">2000</span>]);<br>arr16.<span class="hljs-title function_">set</span>(arr18, [<span class="hljs-number">1</span>]); <span class="hljs-comment">// 从索引1的位置开始复制</span><br><span class="hljs-comment">// [1,2,200,1002]</span><br><span class="hljs-comment">// 设置一个不同视图的会进行转换 转换还是不知道为什么</span><br></code></pre></td></tr></table></figure></li><li><p>arr.subarray([begin, end]) begin 包括 end 不包括<br>?? 这个测试之后有些不对 传递不同的参数并没有什么变化</p></li></ul><h2 id="DataView"><a href="#DataView" class="headerlink" title="DataView"></a>DataView</h2><p>看上去是能够轻松获取到 buffer 中的值</p><h3 id="DataView-1"><a href="#DataView-1" class="headerlink" title="DataView"></a>DataView</h3><blockquote><p>更底层</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">16</span>);<br><span class="hljs-keyword">const</span> int32View = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Int32Array</span>(buffer);<br></code></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><h3 id="什么是执行上下文"><a href="#什么是执行上下文" class="headerlink" title="什么是执行上下文"></a>什么是执行上下文</h3><p><a href="https://juejin.cn/post/6844903682283143181">https://juejin.cn/post/6844903682283143181</a></p><h3 id="JavaScript-类型化数组"><a href="#JavaScript-类型化数组" class="headerlink" title="JavaScript 类型化数组"></a>JavaScript 类型化数组</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Typed_arrays">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Typed_arrays</a></p><h3 id="webgpu-案例"><a href="#webgpu-案例" class="headerlink" title="webgpu 案例"></a>webgpu 案例</h3><p><a href="http://www.webgl3d.cn/pages/359922/">http://www.webgl3d.cn/pages/359922/</a></p><h2 id="第三版"><a href="#第三版" class="headerlink" title="第三版"></a>第三版</h2><p>主要针对于 webgpu 中 buffer 的使用来总结处理</p><p>首先在 webgpu 中数据是通过 buffer 来绑定到着色器里面</p><p>首先我们知道一个字节是占 8 个字符的</p><p>对于 32 位的值，一个值需要 4 个字节，对于 16 位的值，一个值需要 2 个字节</p><p>wgsl 中有 4 种基本结构</p><ul><li>f32</li><li>i32</li><li>u32</li><li>f16</li></ul><p>如果我们定义类似下面这样的结构体</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs wgsl">struct OurStruct &#123;<br>  velocity: f32, // 需要4个字节<br>  acceleration: f32,<br>  frameCount: u32,<br>&#125;;<br></code></pre></td></tr></table></figure><p>它的可视化表现是这样的</p><p><img src="/2023/04/28/ArrayBuffer/2024-02-23-00-19-44.png"></p><p><strong>我们创建的 ArrayBuffer 是以字节作为单位的缓冲区域</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">8</span>);<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint32Array</span>(a);<br>![](<span class="hljs-number">2024</span>-<span class="hljs-number">02</span>-<span class="hljs-number">23</span>-<span class="hljs-number">00</span>-<span class="hljs-number">27</span>-<span class="hljs-number">37.</span>png)<br></code></pre></td></tr></table></figure><p>所以针对上图的我们需要创建一个 12 个字节的内存</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> kOurStructSizeBytes =<br><span class="hljs-number">4</span> + <span class="hljs-comment">// velocity</span><br><span class="hljs-number">4</span> + <span class="hljs-comment">// acceleration</span><br><span class="hljs-number">4</span>; <span class="hljs-comment">// frameCount</span><br><span class="hljs-keyword">const</span> ourStructData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(kOurStructSizeBytes);<br><br><span class="hljs-comment">// 我们拿不同的视图去看他</span><br><span class="hljs-keyword">const</span> ourStructValuesAsF32 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Float32Array</span>(ourStructData);<br><span class="hljs-keyword">const</span> ourStructValuesAsU32 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint32Array</span>(ourStructData);<br><br><span class="hljs-comment">// 进行数据上的设置</span><br>ourStructValuesAsF32[<span class="hljs-number">0</span>] = <span class="hljs-number">1.2</span>;<br>ourStructValuesAsF32[<span class="hljs-number">1</span>] = <span class="hljs-number">3.4</span>;<br>ourStructValuesAsU32[<span class="hljs-number">2</span>] = <span class="hljs-number">56</span>; <span class="hljs-comment">// an integer value</span><br></code></pre></td></tr></table></figure><p>有多种方法可以实现以上的场景</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Float32Array</span>(<span class="hljs-number">12</span>); <span class="hljs-comment">// 会创建一个大小为12*4的字节空间，并用Float32位的视图来看它</span><br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Float32Array</span>([<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]); <span class="hljs-comment">// 创建一个大小为3*4的字节空间，并用Float32位的视图来查看，同时设置初始值文456</span><br><br><span class="hljs-comment">// 还可以直接将TypedArray作为参数, 直接作为参数实际上会进行一个复制值的操作</span><br><br><span class="hljs-comment">// 从流程上来描述，先创建一个3*4大小的字节空间，再用Float32的视图来查看，再将原有视图中的值直接按数字复制到新的Float32Array中</span><br><br>![](![](<span class="hljs-number">2024</span>-<span class="hljs-number">02</span>-<span class="hljs-number">23</span>-<span class="hljs-number">01</span>-<span class="hljs-number">12</span>-<span class="hljs-number">34.</span>png).<span class="hljs-property">png</span>)<br><br><br><span class="hljs-comment">// webgpu 中常用方法</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Float32Array</span>(someArrayBuffer, byteOffset, length)<br><br></code></pre></td></tr></table></figure><p>每个 TypedArray 都具有以下属性</p><ul><li>length 值的数量</li><li>bytelength 字节数量</li><li>byteOffset 在 arrayBuffer 中的偏移起始位置 就是从第几个字节开始看的</li><li>buffer</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 所需内存大小</span><br><span class="hljs-keyword">const</span> uniformBufferSize =<br><span class="hljs-number">4</span> * <span class="hljs-number">4</span> + <span class="hljs-comment">// color is 4 32bit floats (4bytes each)</span><br><span class="hljs-number">2</span> * <span class="hljs-number">4</span> + <span class="hljs-comment">// scale is 2 32bit floats (4bytes each)</span><br><span class="hljs-number">2</span> * <span class="hljs-number">4</span>; <span class="hljs-comment">// offset is 2 32bit floats (4bytes each)</span><br><br><span class="hljs-keyword">const</span> uniformBuffer = device.<span class="hljs-title function_">createBuffer</span>(&#123;<br><span class="hljs-attr">size</span>: uniformBufferSize,<br><span class="hljs-attr">usage</span>: <span class="hljs-title class_">GPUBufferUsage</span>.<span class="hljs-property">UNIFORM</span> | <span class="hljs-title class_">GPUBufferUsage</span>.<span class="hljs-property">COPY_DST</span>,<br>&#125;);<br><br><span class="hljs-comment">// 创建的是单元长度</span><br><span class="hljs-keyword">const</span> uniformValues = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Float32Array</span>(uniformBufferSize / <span class="hljs-number">4</span>);<br><br><span class="hljs-keyword">const</span> kColorOffset = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">const</span> kScaleOffset = <span class="hljs-number">4</span>; <span class="hljs-comment">// set的时候偏移的也是单位长度</span><br><span class="hljs-keyword">const</span> kOffsetOffset = <span class="hljs-number">6</span>;<br><br>uniformValues.<span class="hljs-title function_">set</span>([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>], kColorOffset); <span class="hljs-comment">// set the color</span><br>uniformValues.<span class="hljs-title function_">set</span>([-<span class="hljs-number">0.5</span>, -<span class="hljs-number">0.25</span>], kOffsetOffset); <span class="hljs-comment">// set the offset</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>algorithm</title>
    <link href="/2023/04/25/algorithm/"/>
    <url>/2023/04/25/algorithm/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是数据结构"><a href="#什么是数据结构" class="headerlink" title="什么是数据结构"></a>什么是数据结构</h2><p>数据结构就是在计算机中存储和组织数据的方式</p><p>计算机中的数据量非常庞大，如何以高效的方式组织和存储？</p><p>方式 跟数据量有关</p><p>例如图书： 卧室 书店 图书馆<br>书 放哪里<br>书 怎么取</p><p>1、随便放<br>2、按字母<br>3、先按类别 再按字母顺序 二分查找？效率非常高的查找方式 查找中间 再等分等分</p><p>解决问题方法的效率，跟数据的组织方法有关</p><p>以什么样的方式来存储和组织我们的数据才能在使用数据的时候更方便，这就是数据结构需要考虑的问题</p><p>常见的的数据结构</p><p>不同的数据结构 不同的操作 性能都是不同的 根据具体的需求选择</p><p><strong>了解真相 你才能获得真正的自由</strong></p><ul><li>数组</li><li>栈</li><li>链表</li><li>图</li><li>散列表 HASH</li><li>堆</li><li>树</li><li>队列</li></ul><h2 id="什么是算法"><a href="#什么是算法" class="headerlink" title="什么是算法"></a>什么是算法</h2><p>算法感觉是怎么去操作我们的数据结构</p><p>排序算法 不同的排序算法执行效率是不一样的</p><ul><li>一个有限指令集，每条指令不依赖于语言</li><li>接受一些输入</li><li>产生输出</li><li>有限的步骤后会终止</li></ul><p>algorithm 解决问题的办法&#x2F;步骤逻辑</p><p>电灯不工作？ 解决问题的逻辑 一步步去完成</p><p>电源有没有接好 -&gt; 灯泡坏了 -&gt; 修理电灯</p><p>以上这个步骤就是算法</p><h2 id="栈结构"><a href="#栈结构" class="headerlink" title="栈结构"></a>栈结构</h2><p>栈结构</p><p>数组 可以在任意位置加入或者删除元素 会存在一些位移 效率低 使用数组是因为获取非常方便 只需要输入索引就可以拿到</p><p>栈</p><p>受限的结构 只能在栈顶一端进行添加和删除操作 栈顶元素是可以变化的</p><p>进栈 添加元素 只能在栈顶插入</p><p>出栈 删除元素</p><p>所以 后进先出 （LIFO） last in first out</p><p>生活中的栈结构 自助餐的餐盘 信箱</p><p>程序是对生活的抽象</p><p>函数调用栈<br>A 中调用了 B B 中调用的 C<br>A 入栈 B 入栈 C 入栈 D 入栈<br>然后 D-&gt;C-&gt;B-&gt;A 的方式出栈<br>A -&gt; B -&gt; C -&gt; D</p><p>递归 栈溢出 反复压入栈 无限递归</p><p>顺序进栈 可以一边进栈 一边出栈</p><p>栈结构的实现</p><p>1、基于数组实现</p><p>定义一个栈类<br><a href="https://codepen.io/treeu/pen/bGmqWZJ">https://codepen.io/treeu/pen/bGmqWZJ</a></p><p>2、基于链表实现</p><p>对数组进行包装</p><p>十进制转二进制</p><p>为什么？ 底层是二进制，最终都会转回二进制</p><h2 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列 Queue"></a>队列 Queue</h2><p>受限的线性结构 -&gt; 有序数据元素的集合</p><p>分为前端和后端</p><p>前端 删除元素</p><p>后端 允许在后端添加元素</p><p>先进先出 first in first out FIFO</p><p>生活中 -&gt; 排队</p><p>打印队列：依次打印<br>线程队列：并行允许任务，开启多线程，线程队列，先放进去 等前一个结束再执行后面的</p><p>实现：<br>1、基于数组<br>2、基于链表 链表的效率更高</p><p>题目：击鼓传花 程序规则 参数：人和指定的数字 轮流数数 数到 5 淘汰一个人 再重新数到 5 再淘汰一个人 最后留下来的人是谁 数组下标值</p><p><a href="https://codepen.io/treeu/pen/mdzWoLo?editors=0012">https://codepen.io/treeu/pen/mdzWoLo?editors=0012</a></p><h2 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h2><p>优先级队列主要考虑的问题：</p><ul><li>每个元素不再只是一个数据，而且包含数据的优先级</li><li>在添加方式中，根据优先级放入正确的位置</li></ul><p>生活中的应用场景</p><p>登机的顺序 老年人优先之类</p><p><a href="https://codepen.io/treeu/pen/gOBXLbJ?editors=0012">https://codepen.io/treeu/pen/gOBXLbJ?editors=0012</a></p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表和数组一样 可以用于存储一系列的元素，但是链表和数组的实现机制完全不同</p><p>不同于数组，链表中的元素在内存中不必要是连续的空间</p><p>链表中的每个元素由一个存储元素本身的节点和指向下一个元素的引用（有些语言称为指针或者连接）组成</p><h3 id="相对于数组的优势"><a href="#相对于数组的优势" class="headerlink" title="相对于数组的优势"></a>相对于数组的优势</h3><ul><li>内存空间不需要是连续的，可以充分利用计算机的内存，实现灵活的内存动态管理</li><li>链表不必在创建时就确定大小，并且大小可以无限的延伸下去</li><li>链表在插入和删除数据时，时间复杂度可以达到 O(1).相对数组的效率高很多</li></ul><p>时间复杂度是什么？O 大 O 表示法<br>时间复杂度是一个函数 （哎呀 没看懂）</p><p><a href="https://blog.csdn.net/m1195900241/article/details/118443745">https://blog.csdn.net/m1195900241/article/details/118443745</a></p><h3 id="链表的缺点"><a href="#链表的缺点" class="headerlink" title="链表的缺点"></a>链表的缺点</h3><ul><li><p>链表访问任何一个元素时，都需要从头开始访问，无法跳过第一个元素访问任何一个元素，需要从头一个一个访问</p></li><li><p>无法通过下标访问元素，还是需要一个个访问</p></li></ul><h2 id="如何选择数组还是链表"><a href="#如何选择数组还是链表" class="headerlink" title="如何选择数组还是链表"></a>如何选择数组还是链表</h2><p>需要通过下标获取数据多 使用数组</p><p>需要频繁的删除插入元素 使用链表</p><h3 id="链表是什么呢"><a href="#链表是什么呢" class="headerlink" title="链表是什么呢"></a>链表是什么呢</h3><p>链表有点像火车<br>火车头会连接一个节点 节点上有乘客（数据）并且这个节点会连接着下一个节点</p><h2 id="封装一个链表"><a href="#封装一个链表" class="headerlink" title="封装一个链表"></a>封装一个链表</h2><p><a href="https://codepen.io/treeu/pen/gOBXEww">https://codepen.io/treeu/pen/gOBXEww</a></p><h2 id="认识双向链表"><a href="#认识双向链表" class="headerlink" title="认识双向链表"></a>认识双向链表</h2><p>双向链表的特点</p><ul><li>可以使用一个 head 和一个 tail 分别指向头部和尾部的节点</li><li>每个节点都由三部分组成：前一个节点的指针（prev）&#x2F;数据&#x2F;下一个节点的指针（next）</li><li>双向链表的第一个节点 prev 是 null</li><li>双向链表的最后一个节点 next 是 null</li></ul><h3 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h3><p>只能从头遍历到尾或者从尾遍历到头（一般从头到尾）<br>也就是链表相连的过程是单向的<br>实现的原理是上一个链表中有一个指向下一个的引用</p><h3 id="单向链表的缺点"><a href="#单向链表的缺点" class="headerlink" title="单向链表的缺点"></a>单向链表的缺点</h3><p>可以很轻松的到达下一个节点，但是回到前一个节点是比较困难的</p><p>例子：其实就是你拿到下一个节点只需要 next，但是如果你想找上一个节点，只能重头开始依次查找</p><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>既可以从头遍历到尾 又可以从尾遍历到头<br>也就是一个节点既有向前链接的引用也有向后连接的引用</p><h3 id="双向链表的缺点"><a href="#双向链表的缺点" class="headerlink" title="双向链表的缺点"></a>双向链表的缺点</h3><p>插入和删除操作的时候，需要考虑的是四个引用（单向只考虑两个），实现起来会困难一些</p><p>相对于单项链表，占用的空间要更大一些</p><p>（缺点微不足道 使用上会更方便）</p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>哈希表通常是基于数组进行实现的，但相对于数组，它也有很多优势</p><ul><li>可以提供非常快递的插入-删除-查找操作</li><li>无论多少数据，插入和删除的值，都接近 O(1)的时间级，实际上只需要几个机器指令即可完成</li><li>哈希表的速度比树还快，基本可以瞬间查找到想要的元素</li><li>哈希表相对于树来说编码要容易很多</li></ul><p>哈希表相对于数组的不足</p><ul><li>哈希表中的数据是没有顺序的，所以不能以一种固定的方式（比如从小到大）来遍历其中的元素</li><li>通常情况下，哈希表中的 key 是不允许重复的，不能放置相同的 key，用于保存不用的元素</li></ul><h1 id="哈希表是什么"><a href="#哈希表是什么" class="headerlink" title="哈希表是什么"></a>哈希表是什么</h1><p>数组 一个连续的内存空间</p><p>哈希表的结构就是数组，但它神奇的地方在于对下标值的一种变换，这种变换我们可以称之为哈希函数，通过哈希函数可以获取到 HashCode</p><h2 id="为什么需要哈希表这种结构"><a href="#为什么需要哈希表这种结构" class="headerlink" title="为什么需要哈希表这种结构"></a>为什么需要哈希表这种结构</h2><p>案例一：公司使用一种数据来保存所有员工</p><p>方案一：数组 线性查找（一个一个找）效率比较低</p><p>案例二：联系人跟电话的存储</p><p>案例三： 单词信息的储存</p><p>对应关系</p><p>比如：根据 python 找到 下标值 从数组中找到对应元素</p><p>方案目标：字符串转下标值</p><p>编码系统 比如 ASCII 编码：a &#x3D; 97 b&#x3D;98</p><p>方案一： 把单词每个字符编码求和<br>比如 Cats 3+1+20+19 &#x3D; 43<br>那么 43 就作为 cats 单词的下标存在数组中</p><p>但是这种情况的问题<br>就是可能很多单词的数组下标都是 43<br>比如 was<br>那么就会出现数据的覆盖<br>所以这种情况是不合理的</p><p>其实也就是找一种特殊的编码方式<br>让数组的下标值不能重复 值和下标值唯一对应</p><p>方案二：幂的连乘<br>比如一个数字 7654 &#x3D; 7<em>10^3 + 6</em>10^2+5^10+4<br>那么单词也可以使用这种方案来表示</p><p>cats&#x3D;3<em>27^3 + 1</em>27^2 + 20^27 + 17 &#x3D; 60337</p><p>这样得到的数字可以基本保证它的唯一性</p><p>这个方案的问题：数组的下标会很大，没几个数据，但是会申请一个很大的空间</p><h3 id="哈希化"><a href="#哈希化" class="headerlink" title="哈希化"></a>哈希化</h3><p>现在需要一种压缩方法，把幂的连乘方案中得到的巨大整数范围压缩到可接受的数组范围中</p><p>对于 50000 个数据，在实际情况中往往需要更大的空间来存储这些单词，因为我们不能保证单词会映射到每一个位置</p><p>比如两倍的大小：1000000</p><p>取余操作：</p><p>假设把从 0-199 的数字（largeNumber）代表<br>压缩到 0-9 的数字，比如使用 SmallRange 代表</p><p>下标值的结果 index &#x3D; largeNumer % smallRange</p><p>当一个数被 10 整除时，余树一定在 0-9 之间</p><p>13 % 10 &#x3D; 3</p><p>157 % 10 &#x3D; 7</p><p>当然这中间可能还是有重复<br>不过重复的值明显变少了<br>因为我们数组的范围比较大</p><p>如果要将 700000000 压缩到 100000 以内</p><p>我们可以做取余操作</p><ul><li><p>哈希化：将大数字转换为数组范围内下标的过程，我们称之为哈希化</p></li><li><p>哈希函数：通常我们会将单词转成大数字，大数字在进行哈希化的代码实现放在一个函数中，这个函数就是哈希函数，也就是映射的一个过程封装成一个函数</p></li><li><p>最终将数据插入到这个数组，对整个结构的封装，我们就称之为是一个哈希表</p></li></ul><p>还有未解决的问题</p><p>如果哈希化后还存在重复 怎么处理</p><h3 id="冲突处理"><a href="#冲突处理" class="headerlink" title="冲突处理"></a>冲突处理</h3><ul><li>链地址法</li></ul><p>索引相同的数据 存储的不再是单个数据 而是一个链条</p><p>这个链条使用什么数据结构呢，常见的是数组和链表</p><p>查询的时候先通过哈希化的数组下标找到对应的位置，取出链表，然后通过线性查找，依次查找找到对应的数据</p><p>那到底是使用数组还是链表？</p><p>都是线性查找 效率也差不多</p><p>其实差不多，根据业务场景来选择</p><p>新插入数据多的情况下选择链表</p><p>开放因子 （还没讲）</p><p>java 链表的长度 大于 9 就换成红黑树</p><h3 id="开放地址法"><a href="#开放地址法" class="headerlink" title="开放地址法"></a>开放地址法</h3><p>主要工作方式是寻找空白的单元格来添加重复的数据 （使用很少）</p><p>开放因子 大于 0.75 就会开始扩容</p><p>探索这个位置的方式：</p><p>删除操作 不可以将这个位置的下标设置为 null 设置为 null 可能会影响我们之后的查询其他操作，所以通常删除一个位置的数据时，我们可以将它进行特殊处置 比如设置为-1</p><ul><li><p>线性探测<br>步长为 1 的探测 就是每次下标值都+1 - 插入 一个个加 一个个查看 直到找到 - 查询也是 先找到哈希化之后的 index，然后一个个加去查找直到数值相同，查询过程有一个约定，如果查询到空位置就停止，因为不可能跳过空位置 - 存在的问题：聚集，我们把一连串的单元格都存在填充元素就叫做聚集，聚集会影响哈希表的性能，无论是插入&#x2F;查询&#x2F;删除都存在这个问题，比如我们插入 32 然后发现临近的单元格都被放满了，这个时候线性查找就要查找很多元素，才能找到</p></li><li><p>二次探测<br>修改了步长，比如下标值 X 那么下一个就是 X+1^1 X+2^2<br>这样就可以一次探测比较长的距离，避免聚集带来的影响</p><ul><li>存在的问题： 还是会聚集 只是步长不一致的聚集 因为步长的规律是一致的</li></ul></li><li><p>再哈希法<br>哈希 通过某种算法得到数字<br>产生不同的步长</p><ul><li>stepSize &#x3D; constant - （key % constant）</li><li>其中 constant 是质数 且小于数组的容量 质数 除 1 和它本身不再有其他因数</li><li>例如： 5 - （key % 5）</li></ul></li></ul><h3 id="哈希化的效率"><a href="#哈希化的效率" class="headerlink" title="哈希化的效率"></a>哈希化的效率</h3><p>哈希表中执行插入和搜索的操作效率是非常高的</p><p>如果没有发生冲突 那么效率就会更高</p><p>如果发生冲突 存取时间就依赖后来的探测长度</p><p>平均探测长度及平均存取时间，取决于 <strong>填装因子</strong> ，填装因子变大，探测长度也会越来越大，效率就会下降， 开发地址法比链地址法更严重，我们要对比他们的效率</p><h3 id="装填因子-（填装因子）"><a href="#装填因子-（填装因子）" class="headerlink" title="装填因子 （填装因子）"></a>装填因子 （填装因子）</h3><ul><li>装填因子表示当前哈希表中已经包含的数据项和整个哈希表长度的比值</li><li>装填因子 &#x3D; 总数据项（已经存放的数据量）&#x2F; 哈希表长度</li></ul><p>开放地址的装填因子 最大为 1</p><p>链地址法： 可以大于 1</p><p>链地址法的效率更高 一般采用链地址法</p><h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>哈希表的主要优点是它的速度<br>（牺牲空间换时间）</p><p>好的哈希函数应该尽可能让计算的过程变得简单，提高计算的效率</p><p>提高速度的一个办法就是让哈希函数中尽量少的有乘法和除法，因为它们的性能是比较低的</p><p>好的哈希函数</p><ul><li>快速的计算<br>快速获取到对应的 hashCode<ul><li>多项式的优化 霍纳法则（秦九韶算法）</li><li>其实就是提取公因数 减少乘法的次数</li></ul></li><li>均匀的分布</li><li>无论是链地址法还是开放地址法，当多个元素映射到同一个位置时，都会影响效率</li><li>优秀的哈希函数应该尽可能的将元素映射到不同的位置，让元素在哈希表中均匀的分布</li><li>使用质数</li><li>哈希表的长度</li><li>N 次幂的底数</li></ul><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="树的特点"><a href="#树的特点" class="headerlink" title="树的特点"></a>树的特点</h2><h2 id="生活中的树"><a href="#生活中的树" class="headerlink" title="生活中的树"></a>生活中的树</h2><p>公司组织架构 倒过来的树</p><h2 id="树的术语"><a href="#树的术语" class="headerlink" title="树的术语"></a>树的术语</h2><ul><li><p>树(tree): n(n&gt;&#x3D;0) 个节点构成的有限集合<br>当 n&#x3D;0 时，称为空树</p></li><li><p>对于一个非空树，树中有一个称为根’root’的节点表示</p></li><li><p>其余节点可以分为 m(m &gt; 0)个互不相交的有限集 T，其中每个节点也可以称作一棵树，称为原来树的<strong>子树</strong> subTree</p></li><li><p>节点的度（degree） 节点的子树个数</p></li><li><p>树的度 树的所有节点中最大的度数</p></li><li><p>叶节点（leaf） 度为 0 没有子节点的节点 也称为叶子节点</p></li><li><p>父节点（parent）</p></li><li><p>子节点（Child）</p></li><li><p>兄弟节点 (sibling) 同一个父节点</p></li><li><p>路径和路径长度 路径长度是边边</p></li><li><p>节点的层次（level）规定根节点在 1 层，其它任一节点的层数是其父节点的层数+1</p></li><li><p>树的深度（Depth）：树中所有节点的最大层次上这棵树的深度</p></li></ul><h2 id="树的表示方式"><a href="#树的表示方式" class="headerlink" title="树的表示方式"></a>树的表示方式</h2><p>儿子-兄弟表示法 旋转 45 度 从上往下看 能发现这是一颗二叉树</p><h2 id="二叉树的概念"><a href="#二叉树的概念" class="headerlink" title="二叉树的概念"></a>二叉树的概念</h2><p>如果树中每个节点最多只能有两个子节点，这个树就是二叉树</p><p>所有的树本质上都可以使用二叉树模拟出来</p><h2 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h2><p>二叉树可以为空 也就是没有节点</p><p>若不为空，则它上由根节点和其称为左子节点 TL 和右子树 TR 的两个不相交的二叉树组成</p><p>二叉树有五种形态</p><ul><li>空</li><li>只有一个根节点</li><li>只有一个左子节点</li><li>只有一个右子节点</li><li>有左子节点和右子节点</li></ul><h2 id="二叉树的特性"><a href="#二叉树的特性" class="headerlink" title="二叉树的特性"></a>二叉树的特性</h2><p>一个二叉树第 i 层的最大节点数为： 2^(i-1), i &gt;&#x3D; 1;</p><p>深度为 K 的二叉树有最大节点总数为：2^k - 1, k &gt;&#x3D; 1;</p><p>对任何非空二叉树 T，若 n0 表述叶节点的个数，n2 是度为 2 度非叶子节点个数，那么两者满足关系 n0&#x3D;n2+1</p><h2 id="完美二叉树"><a href="#完美二叉树" class="headerlink" title="完美二叉树"></a>完美二叉树</h2><p>除了最下面一层的叶节点外，每层节点都有两个子节点，就构成了满二叉树</p><h2 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h2><ul><li>除了最后一层 其他各层的节点数都达到最大个数</li><li>且最后一层从左向右的叶节点要连续存在，只缺右侧若干节点</li><li>完美二叉树是特殊的完全二叉树</li></ul><h2 id="二叉树的存储"><a href="#二叉树的存储" class="headerlink" title="二叉树的存储"></a>二叉树的存储</h2><p>常见的方式树树组和链表</p><p>数组针对完全二叉树好处理，非完全二叉树不太好处理，不知道这个索引怎么拿</p><p>二叉树最常见的方式还是使用链表存储</p><ul><li>每个节点封装成一个 node，node 中包含存储的数据，左节点的引用，右节点的引用</li></ul><h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p>可以为空</p><p>不为空的情况下，满足以下性质：</p><ul><li>非空左子树的所有键值小于其根节点的键值</li><li>非空右子树的所有键值大于其根节点的键值</li><li>左、右子树本身也是二叉搜索树</li></ul><p>简单来说就是 左边的值都要小于根节点 右边的值都要大于根节点</p><h3 id="二叉搜索树的特点"><a href="#二叉搜索树的特点" class="headerlink" title="二叉搜索树的特点"></a>二叉搜索树的特点</h3><p>相对较小的值总是保存在左节点，相对较大的值总是保存在右节点上</p><p>利用这个特点</p><p>查找效率会非常高</p><p>比如 我们的根节点是 9 那么 10 一定是在右边节点中查找</p><p>这就是二分查找的思想</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webgpu</title>
    <link href="/2023/04/03/webgpu/"/>
    <url>/2023/04/03/webgpu/</url>
    
    <content type="html"><![CDATA[<p>s</p><h1 id="webGPU"><a href="#webGPU" class="headerlink" title="webGPU"></a>webGPU</h1><p>有异步函数尽量用异步函数处理</p><p>什么可怕的语言啊 真的要死哦</p><h1 id="bindGroup-相关"><a href="#bindGroup-相关" class="headerlink" title="bindGroup 相关"></a>bindGroup 相关</h1><h2 id="着色器和绑定组布局"><a href="#着色器和绑定组布局" class="headerlink" title="着色器和绑定组布局"></a>着色器和绑定组布局</h2><p>在 sharder 中全局变量的值（公共值）都会绑定一个<br>@group 和@bingding</p><p>多个@bingding 可以共享同一个 group</p><p>在给定的@group 中必须具有唯一的但是不一定是连续的@bingding 值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">@<span class="hljs-title function_">group</span>(<span class="hljs-number">0</span>) @<span class="hljs-title function_">binding</span>(<span class="hljs-number">0</span>) <span class="hljs-keyword">var</span>&lt;uniform&gt;<span class="hljs-attr">camera</span>:<span class="hljs-title class_">Camera</span><br></code></pre></td></tr></table></figure><p>在关联的应用程序代码中，需要定义一个 GPUBingGroupLayout,包含来自着色器给定的@group 中的每个@binging<br>以上述为例子</p><p>也就是 bindGroupLayout 是确认每个 group 中有多少个 bingding，对应的是同一个 group</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> bindGroupLayout = gpuDevice.<span class="hljs-title function_">createBindGroupLayout</span>(&#123;<br><span class="hljs-attr">entries</span>: [<br>&#123;<br><span class="hljs-attr">bingding</span>: <span class="hljs-number">0</span>,<br><span class="hljs-attr">visibility</span>: <span class="hljs-title class_">GPUshaderStage</span>.<span class="hljs-property">VERTEX</span>, <span class="hljs-comment">// FRAGMENT 用在哪个sharder中 可以用在多个</span><br><span class="hljs-attr">buffer</span>: &#123;&#125;, <span class="hljs-comment">// 以下包括它都是绑定类型，里面还可以进行一些配置，至少要设置一个空对象，不能不写，例如这里的缓冲区类型，是storage 还是 uniform</span><br><span class="hljs-attr">texture</span>: &#123;&#125;, <span class="hljs-comment">// 纹理</span><br><span class="hljs-attr">sampler</span>: &#123;&#125;, <span class="hljs-comment">// 采样器</span><br>&#125;,<br>],<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="管线和管线布局"><a href="#管线和管线布局" class="headerlink" title="管线和管线布局"></a>管线和管线布局</h2><p>绑定组布局（也就是上面的）通过 GPUPipelineLayout 传入</p><p>管线布局是管线使用 GPUBindGroupLayouts 的列表，也就是绑定几个 group（每个 group 的具体内容如上），如果只有一个，就只写一个， 案例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> piplelineLayout = gpuDevice.<span class="hljs-title function_">createPipelineLayout</span>(&#123;<br><span class="hljs-attr">bindGroupLayouts</span>: [<br>bindGroupLayout, <span class="hljs-comment">// 和上面的同名</span><br>],<br>&#125;);<br><span class="hljs-comment">// 这里还有一个auto布局是给简单管道使用的，也就是其实隐式的给你创建了group，里面所有的值都是默认值，大多情况下我们最好自己设定布局方式</span><br><span class="hljs-keyword">const</span> pipelineA = gpuDevice.<span class="hljs-title function_">createRenderPipeline</span>(&#123;<br><span class="hljs-attr">layout</span>: piplelineLayout, <span class="hljs-comment">// layout就是绑定多少个group</span><br><span class="hljs-attr">vertex</span>: &#123;<br><span class="hljs-attr">module</span>: vertexModuleA, <span class="hljs-comment">// 是哪个shader</span><br><span class="hljs-attr">entryPoint</span>: <span class="hljs-string">&#x27;vertexMain&#x27;</span>, <span class="hljs-comment">// 使用的入口函数是哪个</span><br>&#125;,<br><span class="hljs-attr">fragment</span>: &#123;<br><span class="hljs-comment">//  同上</span><br>&#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="资源和绑定组"><a href="#资源和绑定组" class="headerlink" title="资源和绑定组"></a>资源和绑定组</h2><p>做完以上操作，我们就可以给资源进行绑定了，其实 auto 就是用默认配置，我们自己写 layout 就是有些我们需要自行进行配置</p><p>这里的 GPUBindGroup，指向的是将暴露给着色器的实际数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 只是创建，数据还未绑定上</span><br><span class="hljs-keyword">const</span> cameraBuffer = gpuDevice.<span class="hljs-title function_">createBuffer</span>(&#123;<br><span class="hljs-attr">size</span>: <span class="hljs-number">144</span>, <span class="hljs-comment">// 两个4*4矩阵和一个vec3向量 这里不太清楚 vec3向量 不是 4*3吗</span><br><span class="hljs-attr">usage</span>: <span class="hljs-title class_">GPUBufferUsage</span>.<span class="hljs-property">COPY_DST</span> | <span class="hljs-title class_">GPUBufferUsage</span>.<span class="hljs-property">UNIFORM</span>,<br>&#125;);<br><span class="hljs-comment">// 其他的</span><br><span class="hljs-comment">// gpuDevice.createTexture  创建纹理</span><br><span class="hljs-comment">// gpuDevice.createSampler  创建取样器</span><br><span class="hljs-comment">// 创建完之后我们要做什么 创建完当然是要绑定 绑定的时候我们还是对应上述的layout，如果我们自己进行了设定</span><br><span class="hljs-comment">// 这里其实是做一个指向 具体数据是可以还在后面才能知道，以及更新资源其实都与这里无关</span><br><span class="hljs-keyword">const</span> bindGroup = gpuDevice.<span class="hljs-title function_">createBindGroup</span>(&#123;<br><span class="hljs-attr">layout</span>: bindGroupLayout,<br><span class="hljs-attr">entries</span>: [<br>&#123;<br><span class="hljs-attr">binding</span>: <span class="hljs-number">0</span>,<br><span class="hljs-attr">resource</span>: &#123; <span class="hljs-attr">buffer</span>: cameraBuffer &#125;, <span class="hljs-comment">//只有buffer需要这样</span><br>&#125;,<br><span class="hljs-comment">// 纹理</span><br>&#123;<br><span class="hljs-attr">binding</span>: <span class="hljs-number">1</span>,<br><span class="hljs-attr">resource</span>: baseColorTexture.<span class="hljs-title function_">createView</span>(),<br>&#125;,<br>&#123;<br><span class="hljs-attr">binding</span>: <span class="hljs-number">2</span>,<br><span class="hljs-attr">resource</span>: <span class="hljs-comment">// 采样器</span><br>&#125;,<br>],<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="设置绑定组和管道"><a href="#设置绑定组和管道" class="headerlink" title="设置绑定组和管道"></a>设置绑定组和管道</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 设置数据 数据设置的是ArrayBuffer</span><br><span class="hljs-keyword">const</span> cameraArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Float32Array</span>(<span class="hljs-number">36</span>);<br>cameraArray.<span class="hljs-title function_">set</span>(viewMatrix, <span class="hljs-number">16</span>);<br><span class="hljs-comment">// 写入数据</span><br>device.<span class="hljs-property">queue</span>.<span class="hljs-title function_">writeBuffer</span>(cameraBuffer, <span class="hljs-number">0</span>, cameraArray);<br><span class="hljs-comment">// 进行渲染</span><br><span class="hljs-keyword">const</span> commandEncoder = device.<span class="hljs-title function_">createCommandEncoder</span>();<br><span class="hljs-keyword">const</span> passEncoder = commandEncoder.<span class="hljs-title function_">beginRenderPass</span>(&#123;<br><span class="hljs-comment">// 进行一些画布初始化的处理 设置颜色之类的</span><br>&#125;);<br>passEncoder.<span class="hljs-title function_">setPipeline</span>(pipelineA);<br>passEncoder.<span class="hljs-title function_">setBindGroup</span>(<span class="hljs-number">0</span>, bindGroup); <span class="hljs-comment">// 跟渲染器绑定 必须要进行设置</span><br>passEncoder.<span class="hljs-title function_">draw</span>(<span class="hljs-number">128</span>);<br>passEncoder.<span class="hljs-title function_">end</span>();<br>device.<span class="hljs-property">queue</span>.<span class="hljs-title function_">submit</span>([commandEncoder.<span class="hljs-title function_">finish</span>()]);<br></code></pre></td></tr></table></figure><h2 id="自动布局"><a href="#自动布局" class="headerlink" title="自动布局"></a>自动布局</h2><p><strong>谨慎使用</strong></p><p>如果在 createRenderPipeline 中写入的布局方式为 auto，此时管道将<strong>根据着色器中声明的绑定</strong>创建自己的内部管道布局，可以通过<code>getBindGroupLayout(index)</code>从管道中查询自动生成的布局</p><p>也就是自动生成布局了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> autoPipelineA = gpuDevice.<span class="hljs-title function_">createRenderPipeline</span>(&#123;<br><span class="hljs-attr">layout</span>: <span class="hljs-string">&#x27;auto&#x27;</span>, <span class="hljs-comment">//根据着色器的声明绑定自动生成</span><br><span class="hljs-attr">vetex</span>:.., <span class="hljs-comment">// 同上</span><br>&#125;);<br><span class="hljs-keyword">const</span> autoBindGroupA = gpuDevice.<span class="hljs-title function_">createBindGroup</span>(&#123;<br><span class="hljs-attr">layout</span>:autoPipelineA.<span class="hljs-title function_">getBindGroupLayout</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// @group(0)</span><br><span class="hljs-attr">entries</span>:[&#123;<br><span class="hljs-attr">binding</span>:<span class="hljs-number">0</span>,<br><span class="hljs-attr">resource</span>:&#123;<span class="hljs-attr">buffer</span>:cameraBuffer&#125;,<br>&#125;]<br>&#125;)<br></code></pre></td></tr></table></figure><p>此时我们看上去这个感觉更好，这不是更方便吗，为什么不建议使用呢</p><p>缺点奉上</p><ul><li><p>auto 布局是跟管线绑定的，是不能复用的，所以会出现即使是一模一样的绑定组，我们也需要创建多个 createBindGroup 进行多次绑定 增加了成本</p></li><li><p>使用 auto 生成的布局可能不是你所需要的，比如如果我们在 shader 中定义了，但是暂时没有使用，auto 布局中就不会给我们自动生成</p></li></ul><p>根据以上缺点 所以我们需要谨慎使用 auto</p><h2 id="绑定组的复用"><a href="#绑定组的复用" class="headerlink" title="绑定组的复用"></a>绑定组的复用</h2><p>可以只设置一次绑定组，让两个管道都使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">passEncoder.<span class="hljs-title function_">setBindGroup</span>(<span class="hljs-number">0</span>, bindGroup);<br>passEncoder.<span class="hljs-title function_">setPipeline</span>(pipeLineA);<br>passEncoder.<span class="hljs-title function_">draw</span>(<span class="hljs-number">128</span>);<br>passEncoder.<span class="hljs-title function_">setPipeline</span>(pipeLineA);<br>passEncoder.<span class="hljs-title function_">draw</span>(<span class="hljs-number">128</span>);<br></code></pre></td></tr></table></figure><h3 id="绑定组子集的复用"><a href="#绑定组子集的复用" class="headerlink" title="绑定组子集的复用"></a>绑定组子集的复用</h3><p>绑定组的布局怎么样 和实际使用怎么样是两回事<br>也就是说可以设置好布局 但是实际上并不使用</p><h2 id="使用多个绑定组"><a href="#使用多个绑定组" class="headerlink" title="使用多个绑定组"></a>使用多个绑定组</h2><p>那要使用多个绑定组，我们要做的事情首先就是创建多个绑定组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建多个绑定组布局</span><br><span class="hljs-keyword">const</span> layout1 = gpuDevice.<span class="hljs-title function_">createBindGroupLayout</span>(&#123;<br><span class="hljs-attr">entries</span>: [<br>&#123;<br><span class="hljs-attr">binding</span>: <span class="hljs-number">0</span>,<br><span class="hljs-attr">visibility</span>: <span class="hljs-title class_">GPUShaderStage</span>.<span class="hljs-property">VERTEX</span>,<br><span class="hljs-attr">buffer</span>: &#123;&#125;,<br>&#125;,<br>],<br>&#125;);<br><span class="hljs-keyword">const</span> layout2 = gpuDevice.<span class="hljs-title function_">createBindGroupLayout</span>(&#123;<br><span class="hljs-attr">entries</span>: [<br>&#123;<br><span class="hljs-attr">binding</span>: <span class="hljs-number">0</span>,<br><span class="hljs-attr">visibility</span>: <span class="hljs-title class_">GPUShaderStage</span>.<span class="hljs-property">VERTEX</span>,<br><span class="hljs-attr">buffer</span>: &#123;&#125;,<br>&#125;,<br>],<br>&#125;);<br><span class="hljs-comment">// 将绑定组布局与管道布局绑定</span><br><span class="hljs-keyword">const</span> pipelineLayout = gpuDevice.<span class="hljs-title function_">createPipelineLayout</span>(&#123;<br><span class="hljs-attr">bingGroupLayouts</span>: [layout1, layout2], <span class="hljs-comment">// 这里也就是 group(0),group(1)</span><br>&#125;);<br><span class="hljs-comment">// 绑定组与绑定组布局的指向绑定</span><br><span class="hljs-keyword">const</span> cameraGroup = gpuDevice.<span class="hljs-title function_">createBindGroup</span>(&#123;<br><span class="hljs-attr">layout</span>: layout1,<br><span class="hljs-attr">entries</span>: [<br>&#123;<br><span class="hljs-attr">binding</span>: <span class="hljs-number">0</span>,<br><span class="hljs-attr">resource</span>: &#123; <span class="hljs-attr">buffer</span>: cameraBuffer &#125;, <span class="hljs-comment">//这里前面应该要创建buffer，但是可以在后面再写入</span><br>&#125;,<br>],<br>&#125;);<br><span class="hljs-keyword">const</span> cameraGroup2 = gpuDevice.<span class="hljs-title function_">createBindGroup</span>(&#123;<br><span class="hljs-attr">layout</span>: layout1,<br><span class="hljs-attr">entries</span>: [<br>&#123;<br><span class="hljs-attr">binding</span>: <span class="hljs-number">0</span>,<br><span class="hljs-attr">resource</span>: &#123; <span class="hljs-attr">buffer</span>: cameraBuffer &#125;, <span class="hljs-comment">//这里前面应该要创建buffer，但是可以在后面再写入</span><br>&#125;,<br>],<br>&#125;);<br>passEncoder.<span class="hljs-title function_">setBindGroup</span>(<span class="hljs-number">0</span>, cameraGroup); <span class="hljs-comment">// group(0)</span><br>passEncoder.<span class="hljs-title function_">setBindGroup</span>(<span class="hljs-number">1</span>, cameraGroup2); <span class="hljs-comment">// group(1)</span><br></code></pre></td></tr></table></figure><h3 id="注意-一次能创建多少个绑定组和绑定组中一次最多能绑定几个资源-这些是要去查的"><a href="#注意-一次能创建多少个绑定组和绑定组中一次最多能绑定几个资源-这些是要去查的" class="headerlink" title="注意 一次能创建多少个绑定组和绑定组中一次最多能绑定几个资源 这些是要去查的"></a>注意 一次能创建多少个绑定组和绑定组中一次最多能绑定几个资源 这些是要去查的</h3><p><code>limits.maxBindGroups</code> 目前看是最多绘制 4 个组</p><h2 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h2><p>最佳性能，使用@group(0) 去绘制变化最少的值<br>后续的 group 去绘制变化频次相对高的数据</p><h2 id="使用上"><a href="#使用上" class="headerlink" title="使用上"></a>使用上</h2><p>不使用的部分可以在 shader 中直接不写，但是绑定的时候还是需要绑定</p><h1 id="图片纹理部分"><a href="#图片纹理部分" class="headerlink" title="图片纹理部分"></a>图片纹理部分</h1><p>尽可能的使用压缩格式</p><h2 id="格式之间的比较"><a href="#格式之间的比较" class="headerlink" title="格式之间的比较"></a>格式之间的比较</h2><p>大概只有以下几种</p><ul><li>webp 首选 体积小 无损&#x2F;有损 以及透明度支持 就是还不是广泛支持</li><li>png 有更大的文件大小 无损&#x2F;支持透明度</li><li>jpg 不支持透明度 大小跟 webp 差不多 最普遍的图像格式</li></ul><p>GIF 不行 质量差 一定要用到最好用视频格式</p><h2 id="从图像-URL-创建纹理"><a href="#从图像-URL-创建纹理" class="headerlink" title="从图像 URL 创建纹理"></a>从图像 URL 创建纹理</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">webGPUTextureFromImageBitmapOrcanvas</span>(<span class="hljs-params">gpuDevice, source</span>) &#123;<br><span class="hljs-keyword">const</span> textureDescriptor = &#123;<br><span class="hljs-attr">size</span>: &#123; <span class="hljs-attr">width</span>: source.<span class="hljs-property">width</span>, <span class="hljs-attr">height</span>: source.<span class="hljs-property">height</span> &#125;, <span class="hljs-comment">// 在创建纹理时就需要设置纹理的大小，所以必须要等待图像加载完成</span><br><span class="hljs-attr">format</span>: <span class="hljs-string">&#x27;rgba8unorm&#x27;</span>,<br><span class="hljs-attr">usage</span>: <span class="hljs-title class_">GPUTextureUsage</span>.<span class="hljs-property">TEXTURE_BINDING</span> | <span class="hljs-title class_">GPUTextureUsage</span>.<span class="hljs-property">COPY_DST</span>,<br>&#125;;<br><span class="hljs-keyword">const</span> texture = gpuDevice.<span class="hljs-title function_">createTexture</span>(textureDescriptor);<br>gpuDevice.<span class="hljs-property">queue</span>.<span class="hljs-title function_">copyExternalImageToTexture</span>(<br>&#123; source &#125;,<br>&#123; texture &#125;,<br>textureDescriptor.<span class="hljs-property">size</span><br>);<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">webGPUTextureFromImageUrl</span>(<span class="hljs-params">gpuDevice, url</span>) &#123;<br><span class="hljs-comment">// 重点就是fetch了</span><br><span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(url);<br><span class="hljs-keyword">const</span> blob = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">blob</span>();<br><span class="hljs-keyword">const</span> imgBitMap = <span class="hljs-keyword">await</span> <span class="hljs-title function_">createImageBitMap</span>(blob);<br><span class="hljs-keyword">return</span> <span class="hljs-title function_">webGPUTextureFromImageBitmapOrCanvas</span>(gpuDevcie, imgBitMap);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="从标签创建纹理"><a href="#从标签创建纹理" class="headerlink" title="从标签创建纹理"></a>从<img>标签创建纹理</h2><p><code>createImageBitmap()</code>是一定要保证图像加载完的<br>如果我们使用 dom 元素的情况下,要确保图片加载完</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">webGPUTextureFromImageElement</span>(<span class="hljs-params">gpuDevice, imgElement</span>) &#123;<br><span class="hljs-comment">// HTMLImageElement.complete 确认图片是否加载完成</span><br><span class="hljs-keyword">if</span> (imgElement.<span class="hljs-property">complete</span>) &#123;<br><span class="hljs-keyword">const</span> imgBitmap = <span class="hljs-keyword">await</span> <span class="hljs-title function_">createImageBitmap</span>(imgElement);<br><span class="hljs-keyword">return</span> <span class="hljs-title function_">webGPUTextureFromImageBitmapOrCanvas</span>(gpuDevcie, imgBitMap);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br><span class="hljs-comment">// load事件在图片加载完成时触发</span><br>imgElement.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;load&#x27;</span>, <span class="hljs-keyword">async</span> () =&gt; &#123;<br><span class="hljs-keyword">const</span> imgBitmap = <span class="hljs-keyword">await</span> <span class="hljs-title function_">createImageBitmap</span>(imgElement);<br><span class="hljs-keyword">return</span> <span class="hljs-title function_">webGPUTextureFromImageBitmapOrCanvas</span>(gpuDevcie, imgBitMap);<br>&#125;);<br><span class="hljs-comment">// 再监听一个加载失败的情况</span><br>imgElement.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;error&#x27;</span>, reject);<br>&#125;);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="应用-glTF"><a href="#应用-glTF" class="headerlink" title="应用 glTF"></a>应用 glTF</h2><p>一个 3d 模型结构 目前没有使用到 就简单看了一下</p><h2 id="从-canvas-创建纹理"><a href="#从-canvas-创建纹理" class="headerlink" title="从 canvas 创建纹理"></a>从 canvas 创建纹理</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 这里都不用异步哦 仅适用于具有web GPL或canvas2D上下文的画布</span><br><span class="hljs-keyword">const</span> canvas = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;canvas&#x27;</span>);<br><span class="hljs-keyword">const</span> texture = <span class="hljs-title function_">webGPUTextureFromImageBitmapOrCanvas</span>(gpuDevcie, canvas);<br></code></pre></td></tr></table></figure><h2 id="从-video-中创建纹理"><a href="#从-video-中创建纹理" class="headerlink" title="从 video 中创建纹理"></a>从 video 中创建纹理</h2><p>和 canvas 一样，可以将元素 video 传过去，并使用生成的 imageBitmap</p><p>视频的本质是会频繁更新，所以有点不一样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> texture = gpuDevice.importExternalTexture(&#123; <span class="hljs-attr">source</span>: video &#125;);<br></code></pre></td></tr></table></figure><p><strong>得注意一下生命周期</strong></p><h2 id="生成-Mipmap"><a href="#生成-Mipmap" class="headerlink" title="生成 Mipmap"></a>生成 Mipmap</h2><p>多级渐远纹理</p><p>这个不是很懂啊，纹理部分太薄弱了啊</p><p>仔细一想不是跟 buffer 一样的吗 反正都是传递到 shader 中使用的东西</p><h2 id="计算管线"><a href="#计算管线" class="headerlink" title="计算管线"></a>计算管线</h2><p>GPU 的并行计算效率更高</p><p>使用计算管线并不需要去配置 canvas 的相关信息</p><p>创建 pipeline <code>createComputepipelineAsync(descriptor)</code></p><p>描述器：descriptor 就是指定 layout 和 compute</p><p>webgpu 中有两种传递数据的方式</p><p>顶点插槽和 bindGroup</p><ul><li>顶点插槽 setVertexBuffer 绑定顶点数据的 传递的都是 gpuBuffer</li></ul><p>两者有什么区别呢？</p><p>方式问题吧 我们绘制图形肯定需要顶点信息 这个时候就使用顶点插槽<br>其他相关的辅助信息就丢到 bindgroup 里面去</p><p>顶点插槽获取到的数据就是 main 的参数@location(0)</p><p>bindGroup 我们一般作为全局变量</p>]]></content>
    
    
    
    <tags>
      
      <tag>webgpu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>car</title>
    <link href="/2023/03/13/car/"/>
    <url>/2023/03/13/car/</url>
    
    <content type="html"><![CDATA[<h2 id="东周科目三"><a href="#东周科目三" class="headerlink" title="东周科目三"></a>东周科目三</h2><p>这是我第二次考科目三了 又是在这种忙碌又有压力的日子 当作回忆录了</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>遇到任何突发情况，无法确定怎么处理的情况，踩离合踩刹车，停车，回空档挂一档重新起步，不要紧张不要着急</p><p>三档四档跑的时候，记得给油，油门要给到 1</p><p>红绿灯路口，绿灯直接过去记得点刹</p><p>绕车一周 左后角是第一个按钮 右后角第二个 （请验证指纹）</p><p>车门要关好</p><p>上车调整座椅（下面） 靠背（左边） 系好安全带 看看后视镜是否需要调整，内侧 1&#x2F;3，外侧 2&#x2F;3， 确认灯光的关闭情况，按指纹</p><p>变更车道，超车，返回原车道，自主变道，都要看看后方是否有来车</p><p>灯光一定要记住</p><ul><li>夜间通过无信号灯的路口 闪灯 3 次</li></ul><h3 id="三号线"><a href="#三号线" class="headerlink" title="三号线"></a>三号线</h3><p>首先回忆一下路线图</p><p>起步上四档</p><p>三档加速到 1.8 踩离合 反手拉上四档 慢慢松开离合 数 7 秒 （看路况是否需要踩离合 退回三档）记得给油</p><h4 id="前方路口请右转"><a href="#前方路口请右转" class="headerlink" title="前方路口请右转"></a>前方路口请右转</h4><p>语音播报：前方路口请右转 （路牌前就可以开始注意准备停车了，避免开快了，跑到实线那边了 ）此时需要变更车道到最右侧车道，变更车道要注意看后方是否有车，变更车道后记得上个二档，避免一档超距离；</p><h4 id="前方路口请右转-1"><a href="#前方路口请右转-1" class="headerlink" title="前方路口请右转"></a>前方路口请右转</h4><p>语音再次播报：前方路口请右转 ，此时踩离合踩刹车，打右灯，（灯方一针想一想）；不用预留车位，盖箭头停车，重新挂一档，注意观察行人，等绿灯亮了再走，这里右转是走<strong>中间车道</strong></p><h4 id="前方直行通过路口"><a href="#前方直行通过路口" class="headerlink" title="前方直行通过路口"></a>前方直行通过路口</h4><p>语音播报：前方直行通过路口，注意交通信号灯，直行通过路口，可以预留一个车位，灯方一针，重新挂一档</p><h4 id="请完成超车动作"><a href="#请完成超车动作" class="headerlink" title="请完成超车动作"></a>请完成超车动作</h4><p>语音播报：请完成超车动作，超车都是从左边超车，灯方一针</p><h4 id="请返回原车道"><a href="#请返回原车道" class="headerlink" title="请返回原车道"></a>请返回原车道</h4><p>语音播报：请返回原车道，灯方一针，（如果觉得可能会超 1 档距离，可以停下来一下）</p><h4 id="超车项目完成"><a href="#超车项目完成" class="headerlink" title="超车项目完成"></a>超车项目完成</h4><p>语音播报：超车项目完成；这里需要自主变更车道到最左侧，因为前方需要掉头；</p><h4 id="前方请选择合适地点掉头"><a href="#前方请选择合适地点掉头" class="headerlink" title="前方请选择合适地点掉头"></a>前方请选择合适地点掉头</h4><p>语音播报：前方请选择合适地点掉头，靠最左边车道走</p><h4 id="请掉头"><a href="#请掉头" class="headerlink" title="请掉头"></a>请掉头</h4><p>语音播报：请掉头，盖箭头停车，灯方一针，此时前面会有红绿灯，需要观察路况，看是否能进行掉头，或是继续等待，肩膀到斑马线上，方向盘左打死，进最左边车道，摆正加速上个二档</p><h4 id="掉头结束"><a href="#掉头结束" class="headerlink" title="掉头结束"></a>掉头结束</h4><p>语音播报：掉头结束</p><p><strong>三号线掉头之后全程二档</strong> 这里有公交站台点刹项目，直线行驶项目</p><p><strong>公交站台前面有个路口</strong>，左边应该也有个白色油漆树，在这里点刹三下</p><h4 id="请保持直线行驶"><a href="#请保持直线行驶" class="headerlink" title="请保持直线行驶"></a>请保持直线行驶</h4><p>语音播报：请保持直线行驶</p><h4 id="直线行驶结束"><a href="#直线行驶结束" class="headerlink" title="直线行驶结束"></a>直线行驶结束</h4><p>语音播报：直线行驶结束</p><h4 id="前方直行通过路口-1"><a href="#前方直行通过路口-1" class="headerlink" title="前方直行通过路口"></a>前方直行通过路口</h4><p>语音播报：前方直行通过路口 进入从左至右第二个车道，停车，等待红绿灯，灯方一针</p><p>这部分没项目，可以补个四档</p><h4 id="前方路口请左转"><a href="#前方路口请左转" class="headerlink" title="前方路口请左转"></a>前方路口请左转</h4><p>语音播报：前方路口请左转</p><h4 id="前方路口请左转-1"><a href="#前方路口请左转-1" class="headerlink" title="前方路口请左转"></a>前方路口请左转</h4><p>语音再次播报：前方路口请左转，灯方一针，左转预留一个车位，因为要上二档，左转到最左边车道，红绿灯</p><h4 id="请会车"><a href="#请会车" class="headerlink" title="请会车"></a>请会车</h4><p>语音播报：请会车，点刹一下</p><h4 id="请变更车道"><a href="#请变更车道" class="headerlink" title="请变更车道"></a>请变更车道</h4><p>语音播报：请变更车道，到右边去，灯方一针，注意后方有没有车，变更车道后上二档</p><h4 id="前方终点区域"><a href="#前方终点区域" class="headerlink" title="前方终点区域"></a>前方终点区域</h4><p>语音播报：前方终点区域，注意不要在网格线停车，停车，打右灯，灯方一针<br>有车多等一下，避免影响靠边停车</p><h4 id="靠边停车"><a href="#靠边停车" class="headerlink" title="靠边停车"></a>靠边停车</h4><p>靠边停车：右灯数五秒，雨刮器对点，闭上左眼（靠窗），超过黄线之后回 45 度，再去压线，超过之后立刻停车，空档手刹</p><h2 id="六号线"><a href="#六号线" class="headerlink" title="六号线"></a>六号线</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>webGL</title>
    <link href="/2023/03/11/webGL/"/>
    <url>/2023/03/11/webGL/</url>
    
    <content type="html"><![CDATA[<h2 id="webGpu"><a href="#webGpu" class="headerlink" title="webGpu"></a>webGpu</h2><p>下载最新的 Chrome Canary</p><p>打开：chrome:&#x2F;&#x2F;flags&#x2F;#enable-unsafe-webgpu</p><p>重启后生效</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-comment">// 判断条件</span><br>navigator.<span class="hljs-property">gpu</span>;<br></code></pre></td></tr></table></figure><h2 id="webgl"><a href="#webgl" class="headerlink" title="webgl"></a>webgl</h2><p>webGL 使用正交右手坐标系，每个方向都有可使用的值的区间，超过该矩形区间的图像不会被绘制</p><p>目前我们看到的是 2D 绘图环境，也就是窗口的坐标系，原点为左上角，x 的正方向向右，y 轴的正方形向下，canvas 中的坐标单位都是 px</p><h3 id="渲染管线-按以下顺序逐级处理数据"><a href="#渲染管线-按以下顺序逐级处理数据" class="headerlink" title="渲染管线 按以下顺序逐级处理数据"></a>渲染管线 按以下顺序逐级处理数据</h3><ul><li>顶点缓冲区： 缓冲区 代加工数组<ul><li>数据</li></ul></li><li>顶点着色器 - 可编程的功能单元</li><li>图元装配：做什么</li><li>光栅器</li><li>片元着色器 - 可编程的功能单元</li><li>数据</li><li>纹理缓冲区</li><li>归属测试</li><li>模版测试</li><li>深度测试<ul><li>深度缓冲区</li></ul></li><li>融合</li><li>抖动</li><li>颜色缓冲区</li></ul><h3 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h3><p>用像素画出来</p><p>webGL 在电脑的 GPU 上运行，需要能在 GPU 上能够使用的代码</p><h3 id="成对运行"><a href="#成对运行" class="headerlink" title="成对运行"></a>成对运行</h3><ul><li>顶点着色器<ul><li>计算顶点的位置</li></ul></li><li>片段着色器<ul><li>计算出当前绘制图元的每一个像素值</li></ul></li></ul><p>配对使用 组合起来称为一个着色程序</p><p>通过<code>gl.drawArrays</code>或者<code>gl.drawElement</code>运行一个着色方法对</p><p><del><strong>这对方法对所需要的任何数据都需要发送到 GPU</strong></del></p><h3 id="着色器获取数据的四种方法"><a href="#着色器获取数据的四种方法" class="headerlink" title="着色器获取数据的四种方法"></a>着色器获取数据的四种方法</h3><ul><li>属性（attributes）和缓冲<ul><li>缓存是发送到 GPU 的一些二进制序列</li><li>属性用于指明怎么从缓存中获取数据，并把数据提供给顶点着色器</li><li>目前感觉像是 key:data 属性是 key 缓冲是 data</li></ul></li><li>全局变量（uniforms）<ul><li>全局变量在着色器运行之前赋值，在运行过程中全局有效</li></ul></li><li>纹理（Textures）<ul><li>数据序列 大多数情况下存放的是图像数据</li></ul></li><li>可变量（varyings）<ul><li>顶点着色器给片段着色器传值的方式，根据渲染的图元是点、线、还是三角形，顶点着色器中设置的可变量会在片段着色器中获取不同的插值</li></ul></li></ul><h3 id="webGL-只关心两件事"><a href="#webGL-只关心两件事" class="headerlink" title="webGL 只关心两件事"></a>webGL 只关心两件事</h3><ul><li>裁剪空间的坐标值——顶点着色器提供</li><li>裁剪空间的颜色值——片段着色器提供</li></ul><p><strong>裁剪空间的范围永远是 -1 到 1</strong></p><h2 id="webGL-画布尺寸"><a href="#webGL-画布尺寸" class="headerlink" title="webGL 画布尺寸"></a>webGL 画布尺寸</h2><p>每个画布都有两个尺寸<br><code>drawingbuffer</code> 表示画布中有多少个像素<br>设置的 css 决定画布显示的尺寸</p><p>如果想让画布填充窗口</p><ul><li>设置 css <code>width:100vw</code></li><li>将<code>drawingbuffer</code>的尺寸设置为浏览器拉伸后的画布尺寸<ul><li>clientWidth clinetHeight 获取元素显示的尺寸</li><li><code>canvas.width = canvas.clinetHeight</code></li></ul></li><li>调用 gl.viewport 设置可视区域<ul><li><code>gl.viewport(0,0,gl.canvas.width,gl.canvas.height)</code></li></ul></li></ul><h2 id="webGL-在-GPU-上究竟做了什么"><a href="#webGL-在-GPU-上究竟做了什么" class="headerlink" title="webGL 在 GPU 上究竟做了什么"></a>webGL 在 GPU 上究竟做了什么</h2><ul><li>1、将顶点（或数据流）转换到裁剪空间坐标</li><li>2、基于第一部分的结果绘制像素点</li></ul><h3 id="varying"><a href="#varying" class="headerlink" title="varying"></a>varying</h3><p>在顶点着色器中定一个 varying 来给片段着色器传值<br><code>varying vec4 v_color</code><br>在片段着色器中定义同名的 varying 变量<br>webGL 会将同名的可变量从顶点着色器输入到片段着色器中</p><h2 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h2><p><a href="https://juejin.cn/post/6857032330863706120">https://juejin.cn/post/6857032330863706120</a></p><p>顶点着色器是唯一可以从缓存中读取值的地方，可以通过 varying 修饰同名变量，将值传递给片元着色器</p><p>缓冲区是驻存于内存中的 javascript 对象</p><p>缓冲区是一个对列，着色器每处理完一个顶点（或和顶点对应的其他 attribute 对象），缓冲区就提供下一个顶点给着色器处理</p><p>缓冲操作是在 GPU 上获取顶点和其他顶点数据的方式</p><ul><li><code>gl.createBuffer</code> 创建一个缓冲</li><li><code>gl.bindBuffer</code> 设置缓存为当前使用缓存</li><li><code>gl.bufferData</code> 将数据拷贝到缓冲</li></ul><p>webGL 如何从缓冲中提取数据传给顶点着色器属性？</p><ul><li>获取 webGL 给属性分配的地址<br><code>var postionLocation = gl.getAttribLocation(program,&#39;a_position&#39;)</code></li></ul><p>以上一般在初始化完成</p><p>知道了属性的地址，绘制前还需要发出的三个命令</p><ul><li><p>告诉 webGL 我们想从缓冲中提取数据<br><code>gl.enableVertextAttribArray(postionLocation(属性地址))</code></p></li><li><p>将缓冲绑定到 ARRAY_BUFFER 绑定点, 第一个参数，存储缓存区的目标类型，第二个参数为自己创建的缓存区的对象</p><ul><li><p><code>gl.ARRAY_BUFFER</code> 缓存区中包含了顶点对象</p></li><li><p><code>gl.ELEMENT_ARRAY_BUFFER</code> 缓存区内包含了顶点数据的索引值</p><p><code>gl.bindBuffer(gl.ARRAY_BUFFER, somebuffer(createBuffer()我们创建的buffer名称) )</code></p></li></ul></li><li><p>告诉 webGL 从 ARRAY_BUFFER 绑定点当前绑定的缓存中获取数据</p><ul><li><p><code>gl.vertexAttribpointer(...)</code></p></li><li><p>传递的参数</p><ul><li>location attribute 变量的存储位置</li><li>numComponents 缓冲区中每个顶点的分量个数 范围为 1-4 size</li><li>typeofData 指定数据类型<ul><li>gl.BYTE 字节型 [-128, 127]</li><li>gl.SHORT 短整型 [-32768, 32767]</li><li>gl.UNSIGNED_BYTE 无符号字节型 [0, 255]</li><li>gl.UNSIGNED_SHORT 无符号短整型 [0, 65535]</li><li>gl.FLOAT 浮点型(default)</li></ul></li><li>normalizeFlag<br><strong>是否将非浮点型的数据归一化到[0,1]或[-1,1]</strong><br>标准化标记，适用于所有非浮点型数据，传递 false 就解读原数据类型 [false|true]<br>如果标准化标记设为 true，BYTE 数据的值(-128 to 127)将会转换到 -1.0 到 +1.0 之间， UNSIGNED_BYTE (0 to 255) 变为 0.0 到 +1.0 之间，SHORT 也是转换到 -1.0 到 +1.0 之间， 但比 BYTE 精确度高。<br>最常用的是标准化颜色数据。大多数情况颜色值范围为 0.0 到 +1.0。 使用 4 个浮点型数据存储红，绿，蓝和阿尔法通道数据时，每个顶点的颜色将会占用 16 字节空间， 如果你有复杂的几何体将会占用很多内存。代替的做法是将颜色数据转换为四个 UNSIGNED_BYTE ， 其中 0 表示 0.0，255 表示 1.0。现在每个顶点只需要四个字节存储颜色值，省了 75% 空间<br><code>var type = gl.UNSIGNED_BYTE;</code><br><code>var normalize = true;  </code></li><li>strideToNextPieceOfData 从一个数据到下一个数据要跳过多少位 指定相邻的两个顶点间的字节数，[0-255]</li><li>offsetIntoBuffer 0 从缓冲起始位置开始读 指定缓冲区对象的偏移量，即 attribute 变量从缓冲区中的何处开始储存（从 0 开始）</li></ul></li></ul></li></ul><h2 id="着色器和-GLSL"><a href="#着色器和-GLSL" class="headerlink" title="着色器和 GLSL"></a>着色器和 GLSL</h2><h3 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h3><p>生成裁剪空间坐标值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 每个顶点调用一次顶点着色器，每次调用都需要设置一个特殊的全局变量</span><br>  <span class="hljs-comment">// 该值为裁剪空间的坐标值</span><br>  gl_position = xxx<br>&#125;<br></code></pre></td></tr></table></figure><p>顶点着色器需要的数据，可以通过以下三种方式获得</p><ul><li>attributes 属性（从缓冲中获取的数据）<ul><li>属性可以用 float, vec2, vec3, vec4, mat2, mat3 和 mat4 数据类型。</li><li>todo：了解数据类型</li></ul></li><li>Uniforms 全局变量（在一次绘制中对所有顶点保持一致）<ul><li>全局变量属于单个着色程序</li><li>全局变量有很多种类型</li></ul></li><li>Textures 纹理（从像素或纹理元素中获取数据）</li></ul><h3 id="片段着色器"><a href="#片段着色器" class="headerlink" title="片段着色器"></a>片段着色器</h3><p>片段着色器的作用数为当前光栅化档像素提供颜色值</p><p>每个像素都会调用一次片段着色器，每次调用都会从特殊全局变量 gl_FragColor 中获取颜色信息</p><p>片段着色器所需数据，可以通过以下三种方式获取</p><ul><li>Uniforms 全局变量</li><li>Textures 纹理</li><li>Varyings 可变量</li></ul><h2 id="GLSL-Graphics-Library-Shader-Language"><a href="#GLSL-Graphics-Library-Shader-Language" class="headerlink" title="GLSL Graphics Library Shader Language"></a>GLSL Graphics Library Shader Language</h2><p>着色器使用的语言，目的是为栅格化图像提供常用的计算功能<br>内建的数据类型</p><p>是强类型语言，不能随意赋值</p><ul><li>vec2 vec3 两个值，三个值，和四个值</li><li>mat2 mat3 mat4 2*2 矩阵<br>可以处理矩阵乘法以及矢量和矩阵的乘法</li></ul><h2 id="webGL-开启只绘制正面或者反面三角形"><a href="#webGL-开启只绘制正面或者反面三角形" class="headerlink" title="webGL 开启只绘制正面或者反面三角形"></a>webGL 开启只绘制正面或者反面三角形</h2><p>webGL 的三角形有正反面的 正面三角形顺时针 反面三角形<br>默认值为剔除反面的三角形<br><code>gl.enable(gl.CULL_FACE)</code></p><h2 id="深度缓冲"><a href="#深度缓冲" class="headerlink" title="深度缓冲"></a>深度缓冲</h2><p><code>gl.enable(gl.DEPTH_TEST)</code><br>开始绘制前需要清除深度缓冲<br><code>gl.clear(gl.COLOR_BUFFR_BIT ｜ gl.DEPTH_BUFFER_BIT)</code></p><h2 id="正射投影"><a href="#正射投影" class="headerlink" title="正射投影"></a>正射投影</h2><h2 id="GPU"><a href="#GPU" class="headerlink" title="GPU"></a>GPU</h2><h2 id="buffer"><a href="#buffer" class="headerlink" title="buffer"></a>buffer</h2><h3 id="什么是-buffer"><a href="#什么是-buffer" class="headerlink" title="什么是 buffer"></a>什么是 buffer</h3><p>参考文章：<a href="https://zhuanlan.zhihu.com/p/457799836">https://zhuanlan.zhihu.com/p/457799836</a></p><p>缓冲区对象是 webgl 系统中的一块内存区域<br>缓冲区对象，一次可以向着色器传入多个顶点数据（充分发挥 GPU 的并行渲染能力）</p><h3 id="gl-drawArrays-mode-first-count"><a href="#gl-drawArrays-mode-first-count" class="headerlink" title="gl.drawArrays(mode,first,count)"></a>gl.drawArrays(mode,first,count)</h3><p>三个参数：</p><ul><li>mode webgl 的绘制方式</li><li>first 指定从哪个顶点开始绘制</li><li>count 当前绘制需要用到几个顶点</li></ul><h2 id="如何使用缓冲区"><a href="#如何使用缓冲区" class="headerlink" title="如何使用缓冲区"></a>如何使用缓冲区</h2><h3 id="创建缓冲区对象-gl-createBuffer"><a href="#创建缓冲区对象-gl-createBuffer" class="headerlink" title="创建缓冲区对象 gl.createBuffer()"></a>创建缓冲区对象 <code>gl.createBuffer()</code></h3><p>在内存中分配一块缓冲区对象</p><p><code>const buffer = gl.createBuffer();</code></p><p>有创建就有删除 <code>gl.deleteBuffer()</code></p><h3 id="绑定缓冲区对象-gl-bindBuffer"><a href="#绑定缓冲区对象-gl-bindBuffer" class="headerlink" title="绑定缓冲区对象 gl.bindBuffer()"></a>绑定缓冲区对象 <code>gl.bindBuffer()</code></h3><p>buffer 存在不同的类型，所以需要指定<br><code>gl.ARRAY_BUFFER</code> 包含顶点属性档 buffer，如顶点坐标，纹理坐标数据或顶点颜色数据<br>…<br><code>gl.ELEMENT_ARRAY_BUFFER</code> 用于元素索引的 Buffer。<br>…<br>webgl2 还有一些其他的<br><code>gl.bindBuffer(gl.ARRAY_BUFFER ,buffer)</code></p><h3 id="将数据写入缓冲区对象-gl-bufferData"><a href="#将数据写入缓冲区对象-gl-bufferData" class="headerlink" title="将数据写入缓冲区对象 gl.bufferData()"></a>将数据写入缓冲区对象 <code>gl.bufferData()</code></h3><p>为了优化性能，webGL 需要同时处理大量相同类型的数据，事先知道数组档类型，处理起来会更高效<br>所以定义顶点数据的时候加上类型</p><p><code>const vertices = new Float32Array([0.0,0.5,-0.5,-0.5,0.5,-0.5])</code>;</p><p><code>gl.bufferData(gl.ARRAY_BUFFER,vertices,gl.STATIC_DRAW)</code></p><p>第三个参数，指定数据存储区的使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebGLRenderingContext/bufferData">https://developer.mozilla.org/zh-CN/docs/Web/API/WebGLRenderingContext/bufferData</a></p><p>gl.STATIC_DRAW: 缓冲区的内容可能经常使用，而不会经常更改。内容被写入缓冲区，但不被读取。<br>gl.DYNAMIC_DRAW: 缓冲区的内容可能经常被使用，并且经常更改。内容被写入缓冲区，但不被读取。<br>gl.STREAM_DRAW: 缓冲区的内容可能不会经常使用。内容被写入缓冲区，但不被读取。</p><h3 id="将缓冲区对象分配给一个-attribute-对象-gl-vertexAttribPointer"><a href="#将缓冲区对象分配给一个-attribute-对象-gl-vertexAttribPointer" class="headerlink" title="将缓冲区对象分配给一个 attribute 对象 gl.vertexAttribPointer()"></a>将缓冲区对象分配给一个 attribute 对象 <code>gl.vertexAttribPointer()</code></h3><p>找到对应 attribute 变量的位置，<br><code>const a_Position =  gl.getAttribLocation(gl.program, &#39;a_position&#39;)</code></p><h3 id="开启-attribute-对象gl-enableVertexAttribArray-a-Position"><a href="#开启-attribute-对象gl-enableVertexAttribArray-a-Position" class="headerlink" title="开启 attribute 对象gl.enableVertexAttribArray(a_Position)"></a>开启 attribute 对象<code>gl.enableVertexAttribArray(a_Position)</code></h3><p>将缓冲区对象跟 attribute 变量连接起来</p><h2 id="空间坐标"><a href="#空间坐标" class="headerlink" title="空间坐标"></a>空间坐标</h2><p><a href="https://learnopengl-cn.github.io/01%20Getting%20started/08%20Coordinate%20Systems/#_1">https://learnopengl-cn.github.io/01%20Getting%20started/08%20Coordinate%20Systems/#_1</a></p><p>观察空间 -&gt; 裁剪空间<br>canvas 的坐标与裁剪空间坐标的转换<br><a href="https://juejin.cn/post/7130571019940544520">https://juejin.cn/post/7130571019940544520</a></p><p><a href="https://blog.csdn.net/u011332271/article/details/110477155">https://blog.csdn.net/u011332271/article/details/110477155</a></p><p><a href="https://segmentfault.com/a/1190000042256231">https://segmentfault.com/a/1190000042256231</a></p><p>投影：正射投影和透视投影</p><p>glOrtho 函数只是负责使用什么样的视景体来截取图像，并不负责使用某种规则把图像呈现在屏幕上。<br>glViewport 主要完成这样的功能。它负责把视景体截取的图像按照怎样的高和宽显示到屏幕上。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>matrix</title>
    <link href="/2023/03/05/matrixClass/"/>
    <url>/2023/03/05/matrixClass/</url>
    
    <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Matrix</span> &#123;<br><span class="hljs-title function_">constructor</span>(<span class="hljs-params">rows, cols, data = []</span>) &#123;<br><span class="hljs-comment">// 设置行</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">rows</span> = rows;<br><span class="hljs-comment">// 设置列</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">cols</span> = cols;<br><span class="hljs-comment">// 判断是否存在矩阵数据，</span><br><span class="hljs-keyword">if</span> (data.<span class="hljs-property">length</span>) &#123;<br><span class="hljs-comment">// 矩阵数据长度要与行和列匹配</span><br><span class="hljs-keyword">if</span> (data.<span class="hljs-property">length</span> &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">rows</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">cols</span>) &#123;<br><span class="hljs-comment">// 抛出错误</span><br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;矩阵数据长度与行、列不对应&#x27;</span>);<br>&#125;<br><span class="hljs-comment">// 设置数据</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> = data;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 没有则创建一个长度为rows*cols的全0数组，用于输出数据</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(rows * cols).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>);<br>&#125;<br>&#125;<br><span class="hljs-comment">// 获取row行col列的数据 例：1行2列 row：1 col：2</span><br><span class="hljs-title function_">get</span>(<span class="hljs-params">row, col</span>) &#123;<br><span class="hljs-comment">// 从数组中拿到数据 数组下标从0开始</span><br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>[(row - <span class="hljs-number">1</span>) * <span class="hljs-variable language_">this</span>.<span class="hljs-property">cols</span> + (col - <span class="hljs-number">1</span>)];<br>&#125;<br><span class="hljs-comment">// 设置row行col列的数据</span><br><span class="hljs-title function_">set</span>(<span class="hljs-params">row, col, value</span>) &#123;<br><span class="hljs-comment">// 0没有负数 在设置部分处理</span><br><span class="hljs-keyword">if</span> (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(value) === <span class="hljs-number">0</span>) &#123;<br>value = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 设置数组中的数组 数组下班从0开始</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>[(row - <span class="hljs-number">1</span>) * <span class="hljs-variable language_">this</span>.<span class="hljs-property">cols</span> + (col - <span class="hljs-number">1</span>)] = value;<br>&#125;<br><span class="hljs-comment">// 矩阵乘法 数学公式法</span><br><span class="hljs-title function_">multiply</span>(<span class="hljs-params">other</span>) &#123;<br><span class="hljs-comment">// 矩阵乘法条件 当A列=B行，AB可以相乘</span><br><span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">cols</span> !== other.<span class="hljs-property">rows</span>) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;第一个矩阵中的列数必须等于第二个矩阵中的行数&#x27;</span>);<br>&#125;<br><span class="hljs-comment">// 初始化一个全0矩阵 行为A的行 列为B的列</span><br><span class="hljs-keyword">const</span> result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Matrix</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">rows</span>, other.<span class="hljs-property">cols</span>);<br><span class="hljs-comment">// 进行遍历行和列，设置新的矩阵值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">rows</span>; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt;= other.<span class="hljs-property">cols</span>; j++) &#123;<br><span class="hljs-comment">// 求和</span><br><span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// C中的第i行j列 为A的第i行的值、B的j列的值 对应相乘再相加</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k = <span class="hljs-number">1</span>; k &lt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">cols</span>; k++) &#123;<br>sum += <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>(i, k) * other.<span class="hljs-title function_">get</span>(k, j);<br>&#125;<br><span class="hljs-comment">// 矩阵设置i行j列的值</span><br>result.<span class="hljs-title function_">set</span>(i, j, sum);<br>&#125;<br>&#125;<br><span class="hljs-comment">// 返回进行变换后的新数组</span><br><span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-comment">// 全排列</span><br><span class="hljs-title function_">fullPermutate</span>(<span class="hljs-params">nums</span>) &#123;<br><span class="hljs-comment">// 输入：[1,2,3]</span><br><span class="hljs-comment">// 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br><span class="hljs-keyword">let</span> result = [];<br><span class="hljs-comment">// 排列</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">permute</span>(<span class="hljs-params">pArr, selectedResult</span>) &#123;<br><span class="hljs-keyword">if</span> (selectedResult.<span class="hljs-property">length</span> === nums.<span class="hljs-property">length</span>) &#123;<br><span class="hljs-comment">// 已找到一组数组 结束当前递归</span><br>result.<span class="hljs-title function_">push</span>(selectedResult);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 遍历数组的每一项</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; pArr.<span class="hljs-property">length</span>; i += <span class="hljs-number">1</span>) &#123;<br><span class="hljs-comment">// 对上次已获取结果的拷贝</span><br><span class="hljs-keyword">let</span> selectedArr = selectedResult.<span class="hljs-title function_">concat</span>();<br><span class="hljs-comment">// 将这次的结果存入</span><br>selectedArr.<span class="hljs-title function_">push</span>(pArr[i]);<br><span class="hljs-comment">// 做一个克隆 避免相互影响</span><br><span class="hljs-keyword">let</span> newArr = pArr.<span class="hljs-title function_">concat</span>();<br><span class="hljs-comment">// 删掉数组中的当前项</span><br>newArr.<span class="hljs-title function_">splice</span>(i, <span class="hljs-number">1</span>);<br><span class="hljs-comment">// 递归 将数组继续进行全排序</span><br><span class="hljs-title function_">permute</span>(newArr, selectedArr);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 执行排列</span><br><span class="hljs-title function_">permute</span>(nums, []);<br><span class="hljs-comment">// 返回全排列数组</span><br><span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-comment">// 逆序数 前面的数字比后面数字大的数对数量</span><br><span class="hljs-title function_">reverseNumber</span>(<span class="hljs-params">nums</span>) &#123;<br><span class="hljs-comment">// 输入：[3,2,1]</span><br><span class="hljs-comment">// 输出：3</span><br><span class="hljs-comment">// 默认为0</span><br><span class="hljs-keyword">let</span> reverseNum = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 进行遍历</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-property">length</span>; i += <span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; i; j += <span class="hljs-number">1</span>) &#123;<br><span class="hljs-comment">// 前面的数字比后面数字大 逆序数值+1</span><br><span class="hljs-keyword">if</span> (nums[j] &gt; nums[i]) &#123;<br>reverseNum += <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 返回逆序数</span><br><span class="hljs-keyword">return</span> reverseNum;<br>&#125;<br><span class="hljs-comment">//矩阵行列式 运用全排序和逆序数</span><br><span class="hljs-title function_">det</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-comment">// 先判断是否为方阵 非方针没有行列式</span><br><span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">rows</span> !== <span class="hljs-variable language_">this</span>.<span class="hljs-property">cols</span>) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;矩阵必须是方阵&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">let</span> result = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 需要进行全排序的一组数据</span><br><span class="hljs-keyword">let</span> permuteNums = [];<br><span class="hljs-comment">// 根据行数来确定需要进行全排序的数组</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">rows</span>; i += <span class="hljs-number">1</span>) &#123;<br>permuteNums.<span class="hljs-title function_">push</span>(i);<br>&#125;<br><span class="hljs-comment">// 获取全排列数组</span><br><span class="hljs-keyword">const</span> fullPermutate = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">fullPermutate</span>(permuteNums);<br><span class="hljs-comment">// 遍历全排序数组</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k = <span class="hljs-number">0</span>; k &lt; fullPermutate.<span class="hljs-property">length</span>; k += <span class="hljs-number">1</span>) &#123;<br><span class="hljs-comment">// 逆序数 用于确定正负号</span><br><span class="hljs-keyword">const</span> reverseNumber = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">reverseNumber</span>(fullPermutate[k]);<br><span class="hljs-comment">// 矩阵的项相乘所得到的值</span><br><span class="hljs-keyword">let</span> val = <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 遍历行</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> n = <span class="hljs-number">1</span>; n &lt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">rows</span>; n += <span class="hljs-number">1</span>) &#123;<br><span class="hljs-comment">// 例：a11*a22*a33 a12*a22*a23 固定行，列为全排序数组项 矩阵列从1开始，数组数据从0开始</span><br>val = val * <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>(n, fullPermutate[k][n - <span class="hljs-number">1</span>]);<br>&#125;<br><span class="hljs-comment">// 正负号由-1的逆序数次幂来确定</span><br>result += val * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(-<span class="hljs-number">1</span>, reverseNumber);<br>&#125;<br><span class="hljs-comment">// 返回行列式的值</span><br><span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-comment">// 转置矩阵 将Aij替换为Aji</span><br><span class="hljs-title function_">transpose</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-comment">// 转置矩阵 形式上说 m*n的矩阵A的转置是n*m矩阵</span><br><span class="hljs-keyword">let</span> result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Matrix</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">cols</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">rows</span>);<br><span class="hljs-comment">// 遍历行和列</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">cols</span>; i += <span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">rows</span>; j += <span class="hljs-number">1</span>) &#123;<br><span class="hljs-comment">// 判断是否存在对应值</span><br><span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>(j, i) !== <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-comment">// 将Aij 替换为Aij</span><br>result.<span class="hljs-title function_">set</span>(i, j, <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>(j, i));<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 返回一个转置矩阵</span><br><span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-comment">// 余子式 除去Aij所在行和列剩余的矩阵的行列式</span><br><span class="hljs-title function_">surplus</span>(<span class="hljs-params">delRow, delCol</span>) &#123;<br><span class="hljs-comment">// 新的矩阵的data值</span><br><span class="hljs-keyword">let</span> newData = [];<br><span class="hljs-comment">// 遍历行和列</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">rows</span>; i += <span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">cols</span>; j += <span class="hljs-number">1</span>) &#123;<br><span class="hljs-comment">// i和j不等于需要被删除的行和列，就把数据push进新的data值</span><br><span class="hljs-keyword">if</span> (j !== delCol &amp;&amp; i !== delRow) &#123;<br>newData.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>(i, j));<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 设置surplusMatrix矩阵 行列被删除1</span><br><span class="hljs-keyword">const</span> surplusMatrix = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Matrix</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">rows</span> - <span class="hljs-number">1</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">cols</span> - <span class="hljs-number">1</span>, newData);<br><span class="hljs-comment">// 返回余子式</span><br><span class="hljs-keyword">return</span> surplusMatrix.<span class="hljs-title function_">det</span>();<br>&#125;<br><span class="hljs-comment">// 伴随矩阵 矩阵中每个元素对应的代数余子式所构成矩阵的转置矩阵</span><br><span class="hljs-title function_">adjoint</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-comment">// 创建一个0矩阵</span><br><span class="hljs-keyword">let</span> result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Matrix</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">rows</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">cols</span>);<br><span class="hljs-comment">// 遍历行和列</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">rows</span>; i += <span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">cols</span>; j += <span class="hljs-number">1</span>) &#123;<br><span class="hljs-comment">// val 为Aij 的代数余子式</span><br><span class="hljs-keyword">let</span> val = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(-<span class="hljs-number">1</span>, i + j) * <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">surplus</span>(i, j);<br><span class="hljs-comment">// 设置矩阵内的每个元素</span><br>result.<span class="hljs-title function_">set</span>(i, j, val);<br>&#125;<br>&#125;<br><span class="hljs-comment">// 将矩阵进行转置</span><br><span class="hljs-keyword">return</span> result.<span class="hljs-title function_">transpose</span>();<br>&#125;<br><span class="hljs-comment">// 矩阵求逆 使用伴随矩阵求逆矩阵 A逆 = 1/｜A｜ * A*</span><br><span class="hljs-title function_">inverse</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-comment">// 判断行列式是否为0 充分且必要条件</span><br><span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">det</span>() === <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;该矩阵的行列式为0，不存在逆矩阵 &#x27;</span>);<br>&#125;<br><span class="hljs-comment">// 1/｜A｜</span><br><span class="hljs-keyword">const</span> detVal = <span class="hljs-number">1</span> / <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">det</span>();<br><span class="hljs-comment">// 得到伴随矩阵</span><br><span class="hljs-keyword">let</span> result = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">adjoint</span>();<br><span class="hljs-comment">// 进行遍历行和列</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= result.<span class="hljs-property">rows</span>; i += <span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt;= result.<span class="hljs-property">cols</span>; j += <span class="hljs-number">1</span>) &#123;<br><span class="hljs-comment">// 重新设置矩阵的值 矩阵每项*常数</span><br>result.<span class="hljs-title function_">set</span>(i, j, detVal * result.<span class="hljs-title function_">get</span>(i, j));<br>&#125;<br>&#125;<br><span class="hljs-comment">// 返回一个逆矩阵</span><br><span class="hljs-keyword">return</span> result;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 测试</span><br><span class="hljs-keyword">const</span> A = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Matrix</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]);<br><span class="hljs-keyword">const</span> B = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Matrix</span>(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>]);<br><span class="hljs-keyword">const</span> C = A.<span class="hljs-title function_">multiply</span>(B);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(C.<span class="hljs-property">data</span>); <span class="hljs-comment">//输出：[58, 64, 139, 154]</span><br><br><span class="hljs-keyword">const</span> D = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Matrix</span>(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>]);<br><span class="hljs-keyword">const</span> E = D.<span class="hljs-title function_">inverse</span>();<br><span class="hljs-keyword">const</span> F = D.<span class="hljs-title function_">multiply</span>(E);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(E.<span class="hljs-property">data</span>); <span class="hljs-comment">//输出：[1, 0, 0, 0, 0, 0.3333333333333333, 0, 0, 0, 0, 0.25, 0, 0, 0, 0, 0.5]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(F.<span class="hljs-property">data</span>); <span class="hljs-comment">//输出：[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]</span><br><br><span class="hljs-keyword">const</span> G = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Matrix</span>(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, [<span class="hljs-number">1</span>, -<span class="hljs-number">4</span>, -<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">5</span>, -<span class="hljs-number">3</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>]);<br><span class="hljs-keyword">const</span> H = G.<span class="hljs-title function_">inverse</span>();<br><span class="hljs-keyword">const</span> I = G.<span class="hljs-title function_">multiply</span>(H);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(H.<span class="hljs-property">data</span>); <span class="hljs-comment">//输出：[2, 2, 3, 1, -1, 0, -1, 2, 1]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(I.<span class="hljs-property">data</span>); <span class="hljs-comment">//输出：[1, 0, 0, 0, 1, 0, 0, 0, 1]</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>矩阵相关知识点</title>
    <link href="/2023/02/26/matrix/"/>
    <url>/2023/02/26/matrix/</url>
    
    <content type="html"><![CDATA[<h2 id="单位矩阵"><a href="#单位矩阵" class="headerlink" title="单位矩阵"></a>单位矩阵</h2><p>对角线都是 1，其余元素都为 0 的矩阵，如同乘法中的 1</p><h2 id="秩"><a href="#秩" class="headerlink" title="秩"></a>秩</h2><p>图像经过矩阵变换之后的空间的维度</p><h2 id="线性无关"><a href="#线性无关" class="headerlink" title="线性无关"></a>线性无关</h2><p>两个向量不在一条直线上，我们称为线性无关</p><h3 id="列向量"><a href="#列向量" class="headerlink" title="列向量"></a>列向量</h3><p>$$<br>\begin{bmatrix}<br>3 &amp; 2 \<br>1 &amp; 1<br>\end{bmatrix}<br>$$</p><p>列向量[3,1] [2,1]</p><h3 id="列空间"><a href="#列空间" class="headerlink" title="列空间"></a>列空间</h3><p>列向量所列向量所能张成的空间<br>列空间的维度就是秩</p><p>列空间是二维的，秩就是 2</p><p>如果用秩为 1 的矩阵对二维矩阵进行线性变换 实际上是一个二维空间到一维空间的变化</p><h3 id="3-2-的矩阵"><a href="#3-2-的矩阵" class="headerlink" title="3*2 的矩阵"></a>3*2 的矩阵</h3><p>是指 3 行两列的矩阵</p><p>$$<br>\begin{bmatrix}<br>3 &amp; 2 \<br>1 &amp; 1 \<br>6 &amp; 7<br>\end{bmatrix}<br>$$</p><p>秩 &#x3D; 列秩 &#x3D; 行秩</p><h2 id="如何判断是否为满秩"><a href="#如何判断是否为满秩" class="headerlink" title="如何判断是否为满秩"></a>如何判断是否为满秩</h2><p>参考链接：<a href="https://www.zhihu.com/question/21605094">https://www.zhihu.com/question/21605094</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>矩阵</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>又学会了</title>
    <link href="/2023/02/09/logs/"/>
    <url>/2023/02/09/logs/</url>
    
    <content type="html"><![CDATA[<h2 id="typeof-和-Instanceof-的区别"><a href="#typeof-和-Instanceof-的区别" class="headerlink" title="typeof 和 Instanceof 的区别"></a>typeof 和 Instanceof 的区别</h2><p>一般来说</p><ul><li>原始类型的值使用 typeof 进行检测<br><code>typeof str3 === &#39;string&#39;</code></li><li>对象值则用 instanceof 来进行检测<br><code>values instanceof Array</code></li></ul><p><a href="https://github.com/febobo/web-interview/issues/65">https://github.com/febobo/web-interview/issues/65</a></p><p><a href="https://stackoverflow.com/questions/45489249/object-prototype-tostring-call-javascript">https://stackoverflow.com/questions/45489249/object-prototype-tostring-call-javascript</a></p><p><a href="https://blog.csdn.net/weixin_42349568/article/details/109006143">https://blog.csdn.net/weixin_42349568/article/details/109006143</a></p><h2 id="控制台-performance-的使用"><a href="#控制台-performance-的使用" class="headerlink" title="控制台 performance 的使用"></a>控制台 performance 的使用</h2><p>感谢大佬同事今天给我的讲解 贴两张一看就懂的图 关于 self Time 和 total Time<br>一开始我不太理解<br>其实总时间就是 &#x3D; 当前函数执行的时间 + 函数处理其他子任务执行的时间<br>这里当前函数执行的时间 就是不包含子任务执行的时间</p><p><img src="/2023/02/09/logs/2023-10-30-23-34-21.png"></p><p><img src="/2023/02/09/logs/2023-10-30-23-37-09.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>零散</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>fragmentaryRecord</title>
    <link href="/2023/02/08/fragmentaryRecord/"/>
    <url>/2023/02/08/fragmentaryRecord/</url>
    
    <content type="html"><![CDATA[<h2 id="Mac-homedrew-安装"><a href="#Mac-homedrew-安装" class="headerlink" title="Mac homedrew 安装"></a>Mac homedrew 安装</h2><p>使用大佬写的一键安装脚本</p><p><code>/bin/zsh -c &quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot; </code></p><p>地址：<a href="https://zhuanlan.zhihu.com/p/111014448">https://zhuanlan.zhihu.com/p/111014448</a></p><h2 id="encodeURI-与-encodeURIComponent"><a href="#encodeURI-与-encodeURIComponent" class="headerlink" title="encodeURI() 与 encodeURIComponent()"></a>encodeURI() 与 encodeURIComponent()</h2><ul><li>元字符<br><code>; , / ? : @ &amp; = + $ # </code></li><li>语义字符<br><code>a-z A-Z 0-9 - _ . ! ~ * &#39; ()</code></li></ul><h3 id="encodeURI"><a href="#encodeURI" class="headerlink" title="encodeURI()"></a>encodeURI()</h3><p>使用：用于转码整个 URL<br>不会对 URL 的元字符和语义字符进行转义</p><h3 id="encodeURIComponent"><a href="#encodeURIComponent" class="headerlink" title="encodeURIComponent()"></a>encodeURIComponent()</h3><p>使用：通常指用于转码 URL 组成部分，比如‘？’后面的部分<br>会转码除语义字符串以外所有的字符，即元字符也会被转义</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>无特殊参数的链接，都可以使用 encodeURI()进行转码<br>特殊参数，比如链接里面还有一个回调地址</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 原URL：https://treeu.github.io/?returnURL=“https://treeu.github.io/111”</span><br><br><span class="hljs-string">`https://treeu.github.io/?returnURL=<span class="hljs-subst">$&#123;<span class="hljs-built_in">encodeURIComponent</span>(</span></span><br><span class="hljs-subst"><span class="hljs-string"><span class="hljs-string">&#x27;https://treeu.github.io/111&#x27;</span></span></span><br><span class="hljs-subst"><span class="hljs-string">)&#125;</span>`</span>;<br><br><span class="hljs-comment">// 输出：&quot;https://treeu.github.io/?returnURL=https%3A%2F%2Ftreeu.github.io%2F111&quot;</span><br></code></pre></td></tr></table></figure><p>例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">encodeURI</span>(<span class="hljs-string">&#x27;https://treeu.github.io/啊啊啊&#x27;</span>);<br><br><span class="hljs-comment">// &quot;https://treeu.github.io/%E5%95%8A%E5%95%8A%E5%95%8A 仅转义了中文部分&quot;</span><br><br><span class="hljs-built_in">encodeURIComponent</span>(<span class="hljs-string">&#x27;https://treeu.github.io/啊啊啊&#x27;</span>);<br><br><span class="hljs-comment">// &quot;https%3A%2F%2Ftreeu.github.io%2F%E5%95%8A%E5%95%8A%E5%95%8A 中文和斜杠都被转义了&quot;</span><br></code></pre></td></tr></table></figure><h2 id="打开-ssh-的地址"><a href="#打开-ssh-的地址" class="headerlink" title="打开 ssh 的地址"></a>打开 ssh 的地址</h2><p><code>open ~/.ssh</code></p><h2 id="链接远程地址"><a href="#链接远程地址" class="headerlink" title="链接远程地址"></a>链接远程地址</h2><p><code>git add .</code></p><p><code>git commit -m &#39;xxx&#39;</code></p><p><code>git remote add origin git@github.com:TREEU/xxx.git</code></p>]]></content>
    
    
    
    <tags>
      
      <tag>零碎收集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阅读错误处理与调试</title>
    <link href="/2023/02/08/try-catch/"/>
    <url>/2023/02/08/try-catch/</url>
    
    <content type="html"><![CDATA[<h2 id="阅读：错误处理与调试"><a href="#阅读：错误处理与调试" class="headerlink" title="阅读：错误处理与调试"></a>阅读：错误处理与调试</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 可能出错的代码</span><br>&#125; <span class="hljs-keyword">catch</span>(error) &#123;<br>    <span class="hljs-comment">// 出错之后要做什么</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error.<span class="hljs-property">message</span>);<br>    <span class="hljs-comment">// 最好只依赖message</span><br>    <span class="hljs-comment">// 因为只有message是唯一一个所有浏览器中都有的属性 保证跨平台性</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-comment">// 无论如何都要执行的代码，即使是上面的模块存在return;</span><br>    <span class="hljs-comment">// 存在finally块则catch为可选块</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="错误类型"><a href="#错误类型" class="headerlink" title="错误类型"></a>错误类型</h3><h4 id="Error-基类型"><a href="#Error-基类型" class="headerlink" title="Error 基类型"></a>Error 基类型</h4><p>其他错误类继承该类型，所有的类型都共享相同的属性，该类型主要用于开发者抛出的自定义错误</p><h4 id="InternalError"><a href="#InternalError" class="headerlink" title="InternalError"></a>InternalError</h4><p>底层 javascript 引擎抛出异常时由浏览器抛出<br>例如：递归过多导致了栈溢出</p><h4 id="EvalError"><a href="#EvalError" class="headerlink" title="EvalError"></a>EvalError</h4><p>eval()函数发生异常时候抛出，基本上用不到</p><h4 id="RangeError"><a href="#RangeError" class="headerlink" title="RangeError"></a>RangeError</h4><p>数值越界的时候抛出，<br>例如：<code>let items2 = new Array(Number.MAX_VALUE)</code></p><h4 id="ReferenceError"><a href="#ReferenceError" class="headerlink" title="ReferenceError"></a>ReferenceError</h4><p>会在找不到对象时候发生<br>例如：<code>let obj = x</code></p><h4 id="TypeError-（常见）"><a href="#TypeError-（常见）" class="headerlink" title="TypeError （常见）"></a>TypeError （常见）</h4><p>变量不是预期类型，访问不存在的方法，等等<br>例如：let o &#x3D; new 10</p><h4 id="URIError"><a href="#URIError" class="headerlink" title="URIError"></a>URIError</h4><p>encodeURI()（URL 转码） 或者 decodeURI() 传入了错误的 URI 结构</p><p>可以使用 instanceof 来确定错误的类型，来进行对应的处理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//dosomething</span><br>&#125; <span class="hljs-keyword">catch</span> (error) &#123;<br><span class="hljs-keyword">if</span> (error <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">TypeError</span>) &#123;<br><span class="hljs-comment">// dosomething</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用-try-catch-捕获错误"><a href="#使用-try-catch-捕获错误" class="headerlink" title="使用 try&#x2F;catch 捕获错误"></a>使用 try&#x2F;catch 捕获错误</h3><p>在所有可能发生错误的地方使用 try&#x2F;catch</p><h3 id="抛出错误"><a href="#抛出错误" class="headerlink" title="抛出错误"></a>抛出错误</h3><p><code>thorw new TypeError(&quot;error&quot;)</code></p><p>一般来说，错误应该要在应用程序的底层抛出，目的是为错误提供有关其发生原因的说明，在已知函数无法正确执行的情况下抛出错误</p><h3 id="创建一个自定义类型的错误"><a href="#创建一个自定义类型的错误" class="headerlink" title="创建一个自定义类型的错误"></a>创建一个自定义类型的错误</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">customError</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Error</span> &#123;<br><span class="hljs-title function_">constructor</span>(<span class="hljs-params">message</span>) &#123;<br><span class="hljs-variable language_">super</span>(message);<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;CustomError&#x27;</span>;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span> = message;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">customError</span>(<span class="hljs-string">&#x27;111&#x27;</span>);<br><span class="hljs-comment">// Uncaught CustomError: 11</span><br></code></pre></td></tr></table></figure><h3 id="window-onerror"><a href="#window-onerror" class="headerlink" title="window.onerror"></a>window.onerror</h3><p>任何没有被 try&#x2F;catch 语句处理的错误都会在 window 对象上触发 error 事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-property">onerror</span> = <span class="hljs-function">(<span class="hljs-params">message, url, line</span>) =&gt;</span> &#123;<br>consolog.<span class="hljs-title function_">log</span>(message);<br><span class="hljs-keyword">return</span> falss; <span class="hljs-comment">// 阻止浏览器默认报告错误的行为</span><br>&#125;;<br><br><span class="hljs-literal">null</span> == <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// true</span><br><span class="hljs-literal">null</span> === <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>错误处理与调试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数在前端的应用</title>
    <link href="/2023/02/06/vector/"/>
    <url>/2023/02/06/vector/</url>
    
    <content type="html"><![CDATA[<h2 id="向量是什么"><a href="#向量是什么" class="headerlink" title="向量是什么"></a>向量是什么</h2><ul><li>物理：空间中的箭头，长度&#x2F;方向</li><li>计算机：有序的数字列表</li><li>数学：任何东西 只要相加 or 相乘是有意义的</li></ul><p>经常以原点作为起点</p><p>一个向量的坐标由一对数组成</p><p>$$<br>\begin{bmatrix}<br>-2 \<br>3<br>\end{bmatrix} \tag{x,y}<br>$$</p><p>这组数指导你如何从原点（向量起点）出发到达他的尖端（向量终点）</p><p>三维空间</p><p>$$<br>\begin{bmatrix}<br>-2 \<br>3   \<br>1<br>\end{bmatrix} \tag{x,y,z}<br>$$</p><h2 id="向量加法和数乘"><a href="#向量加法和数乘" class="headerlink" title="向量加法和数乘"></a>向量加法和数乘</h2><h3 id="向量的加法"><a href="#向量的加法" class="headerlink" title="向量的加法"></a>向量的加法</h3><p>将第二个向量的起点移动到第一个向量的终点<br>再画一个向量，从第一个向量的起点出发，指向第二个向量的终点</p><p>此处加法可以抽象为一种运动<br>沿着第一个向量运动，再沿着第二个的方向运动，和直接运动到第三个向量的方向的结果无异</p><p>$$<br>\begin{bmatrix}<br> x1\<br> y1<br>\end{bmatrix}<br>+<br>\begin{bmatrix}<br> x2\<br> y2<br>\end{bmatrix} &#x3D; \begin{bmatrix}<br> x1+x2\<br> x2+y2<br>\end{bmatrix}<br>$$</p><h3 id="向量的数乘"><a href="#向量的数乘" class="headerlink" title="向量的数乘"></a>向量的数乘</h3><p>$$<br>2 * \begin{bmatrix}<br> x1\<br> y1<br>\end{bmatrix} &#x3D; \begin{bmatrix}<br> 2x1\<br> 2y1<br>\end{bmatrix}<br>$$</p><h2 id="基向量"><a href="#基向量" class="headerlink" title="基向量"></a>基向量</h2><p>当我们把一个坐标看作是标量，基向量就是这些标量缩放的对象<br>标量 -&gt; 数字</p><p>选择不同的基向量</p><p>每当我们用数字描述向量时，它都依赖于我们正在使用的基</p><h3 id="线性组合"><a href="#线性组合" class="headerlink" title="线性组合"></a>线性组合</h3><p>两个数乘向量的和被称为这两个向量的线性组合</p><p>$$<br>a\overrightarrow{A} + b\overrightarrow{B}<br>$$</p><h3 id="张成的空间"><a href="#张成的空间" class="headerlink" title="张成的空间"></a>张成的空间</h3><p>所有可以表示为给定向量线性组合的向量的集合</p><p>张成的空间 &#x3D; $$a\overrightarrow{A} + b\overrightarrow{B}$$</p><p>（a 与 b 在实数范围内变动）</p><p><strong>线性代数紧紧围绕加法和数乘</strong></p><p>仅仅通过向量的加法与向量的数乘，你能获得的所有的集合是什么</p><p>二维空间的整个平面<br>共线则是一条直线</p><p>三维向量</p><h3 id="线性相关"><a href="#线性相关" class="headerlink" title="线性相关"></a>线性相关</h3><p>其中一个向量可以表示为其他向量的线性组合 （共线的情况）<br>$$\overrightarrow{w} &#x3D; a\overrightarrow{v}$$<br>(a 取所有值)</p><h2 id="线性无关"><a href="#线性无关" class="headerlink" title="线性无关"></a>线性无关</h2><p>$$\overrightarrow{w} ≠ a\overrightarrow{v}$$<br>(a 取所有值)</p><p>向量如何看作一个点 通常用向量的终点代表一个向量</p><p>考虑一个向量时，看作箭头，考虑多个向量时，看作点</p><h2 id="基的定义"><a href="#基的定义" class="headerlink" title="基的定义"></a>基的定义</h2><p>严格定义： 向量空间的一组基是张成该空间的一个线性无关的向量集</p><p>个人理解：不能共线，应该为不同的方向，如果为同一方向，线性组合就只能代表某条直线或是某个平面内的向量了</p><p>将向量看作每个向量的终点</p><h2 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a>线性变换</h2><ul><li>网格线保持平行且等距分布，并且保持原点不动</li></ul><p>假设现在有一个向量</p><p>$$<br>\begin{bmatrix}<br>-1 \<br>2<br>\end{bmatrix}<br>$$</p><p>基向量</p><p>$$<br>\overrightarrow{i} &#x3D; \begin{bmatrix}<br>1 \<br>0<br>\end{bmatrix}<br>$$</p><p>$$<br>\overrightarrow{j} &#x3D; \begin{bmatrix}<br>0 \<br>1<br>\end{bmatrix}<br>$$</p><p>那么这个向量用基向量表示就是</p><p>$$<br>    \overrightarrow{v} &#x3D; -1 \overrightarrow{i} + 2\overrightarrow{j}<br>$$</p><p>我们现在进行一些变化</p><p>线性变化的重要推论</p><p>$$<br>    transformed\overrightarrow{v} &#x3D; -1 transforamed\overrightarrow{i} + 2transforamed\overrightarrow{j}<br>$$</p><p>只根据变换后的 i 和 j 就能推导出变化后的 v</p><p>我们可以把 i 和 j 这样看</p><p>$$<br>\begin{bmatrix}<br>    1 &amp; 0\<br>    0 &amp; 1<br>\end{bmatrix}<br>$$</p><p>竖着看， x 的坐标，y 的坐标</p><p>那么 线性变换对[5,7]这个向量的变化可以看作</p><p>$$<br>\begin{bmatrix}<br>1 &amp; 0\<br>0 &amp; 1<br>\end{bmatrix}<br>\begin{bmatrix}<br>5\<br>7<br>\end{bmatrix}<br>&#x3D;5\begin{bmatrix}<br>1\<br>0<br>\end{bmatrix}<br>+<br>7\begin{bmatrix}<br>0\<br>1<br>\end{bmatrix}<br>$$</p><p>公式</p><p>$$<br>\begin{bmatrix}<br>a &amp; b\<br>c &amp; d<br>\end{bmatrix}<br>\begin{bmatrix}<br>x\<br>y<br>\end{bmatrix}<br>&#x3D; x \begin{bmatrix}<br>a\<br>c\end{bmatrix} +y\begin{bmatrix}<br>b\<br>d\end{bmatrix}<br>&#x3D; \begin{bmatrix}<br>ax + cx\<br>by+dy\end{bmatrix}<br>$$</p><h4 id="逆时针旋转-90-度"><a href="#逆时针旋转-90-度" class="headerlink" title="逆时针旋转 90 度"></a>逆时针旋转 90 度</h4><p>$$<br>\begin{bmatrix}<br>0 &amp; -1\<br>1 &amp; 0<br>\end{bmatrix}<br>$$</p><h4 id="剪切-（i-不变-j-顺时针旋转-45-度）"><a href="#剪切-（i-不变-j-顺时针旋转-45-度）" class="headerlink" title="剪切 （i 不变 j 顺时针旋转 45 度）"></a>剪切 （i 不变 j 顺时针旋转 45 度）</h4><p>$$<br>\begin{bmatrix}<br>0 &amp; 1\<br>1 &amp; 1<br>\end{bmatrix}<br>$$</p><p><strong>将矩阵看为空间变化</strong></p><p>矩阵和向量相乘，就是将线性变化作用于那个向量</p><p>$$<br>\begin{bmatrix}<br>0 &amp; 1\<br>1 &amp; 1<br>\end{bmatrix}<br>\begin{bmatrix}<br>0 &amp; -1\<br>1 &amp; 0\end{bmatrix}<br>&#x3D;\begin{bmatrix}<br>1 &amp; -1\<br>1 &amp; 0<br>\end{bmatrix}<br>$$</p><p>这里我们从右往左来解读这个变换 也就是先旋转然后再剪切</p><h3 id="2-2-矩阵的乘法"><a href="#2-2-矩阵的乘法" class="headerlink" title="2*2 矩阵的乘法"></a>2*2 矩阵的乘法</h3><p>复合变化，从右向左应用</p><p>例：i 帽的变化首先在[1,1],将新的线性变换（左侧）作用于 i 帽，得到变化后的值</p><p>$$<br>\begin{bmatrix}<br>0 &amp; 2\<br>1 &amp; 0<br>\end{bmatrix}<br>\begin{bmatrix}<br>1 &amp; -2\<br>1 &amp; 0<br>\end{bmatrix}<br>$$</p><p>可以拆成</p><p>$$<br>\begin{bmatrix}<br>0 &amp; 2\<br>1 &amp; 0<br>\end{bmatrix}<br>\begin{bmatrix}<br>1\<br>1<br>\end{bmatrix} &#x3D; 1\begin{bmatrix}<br>0\<br>1<br>\end{bmatrix}+1\begin{bmatrix}<br>2\<br>0<br>\end{bmatrix} &#x3D;<br>\begin{bmatrix}<br>2\<br>1<br>\end{bmatrix}<br>$$</p><p>$$<br>\begin{bmatrix}<br>0 &amp; 2\<br>1 &amp; 0<br>\end{bmatrix}<br>\begin{bmatrix}<br>-2\<br>0<br>\end{bmatrix}&#x3D;<br>-2 \begin{bmatrix}<br>0\<br>1<br>\end{bmatrix}+<br>0 \begin{bmatrix}<br>2\<br>0<br>\end{bmatrix}&#x3D;<br>\begin{bmatrix}<br>0\<br>-2<br>\end{bmatrix}<br>$$</p><p>最终我们可以得到结果</p><p>$$<br>\begin{bmatrix}<br>0 &amp; 2\<br>1 &amp; 0<br>\end{bmatrix}<br>\begin{bmatrix}<br>1 &amp; -2\<br>1 &amp; 0<br>\end{bmatrix}&#x3D;\begin{bmatrix}<br>2 &amp; 0\<br>1 &amp; -2<br>\end{bmatrix}<br>$$</p><p>两个矩阵乘积的结果与的顺序相关联</p><p>90 度 剪切 45 度<br>(AB)C &#x3D; A(BC)</p><h3 id="三维空间中的线性变换跟二维类似"><a href="#三维空间中的线性变换跟二维类似" class="headerlink" title="三维空间中的线性变换跟二维类似"></a>三维空间中的线性变换跟二维类似</h3><p>变换的顺序是从右到左 第一个变化&#x2F;第二个变化&#x2F;增加一个竖直空间上的 k 帽<br>也是依次拆开</p><h3 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h3><p>线性变化改变面积的比例<br>det(</p><p>$$<br>\begin{bmatrix}<br>3 &amp; 2\<br>0 &amp; 2<br>\end{bmatrix}<br>$$</p><p>) &#x3D; 6 将这个区域内的面积放大六倍</p><p>行列式为 1&#x2F;2 将这个区域的面积缩小一半</p><p>二维向量 行列式为 0 说明将整个空间压缩在一条直线或者一个点上</p><p>行列式可以为负值</p><p>将一个行列式缩放负数倍意味着什么？</p><p>空间的定向发生了改变 绝对值依然是空间面积变化比例</p><p>比如 一张纸 翻面了</p><p>三位空间中的行列式是体积的缩放比例</p><p>为 0 则意味着体积为 0 也就是一个平面与或者一条直线甚至可能是一个点</p><h2 id="行列式的计算"><a href="#行列式的计算" class="headerlink" title="行列式的计算"></a>行列式的计算</h2><p>det(</p><p>$$<br>\begin{bmatrix}<br>3 &amp; 2\<br>0 &amp; 2<br>\end{bmatrix}<br>$$</p><p>) &#x3D; ad - bc</p><h2 id="行列式的乘积"><a href="#行列式的乘积" class="headerlink" title="行列式的乘积"></a>行列式的乘积</h2><p>det(M1M2) &#x3D; det(M1)det(M2)</p><h2 id="方程组"><a href="#方程组" class="headerlink" title="方程组"></a>方程组</h2><p>$$<br>2x + 5y + 3z &#x3D; -3\<br>4x + 0y + 8z &#x3D; 0 \<br>1x + 3y + 0z &#x3D; 2<br>$$</p><p>-&gt;</p><p>$$<br>\begin{bmatrix}<br>2 &amp; 5 &amp; 3\<br>4 &amp; 0 &amp; 8\<br>1 &amp; 3 &amp; 0\<br>\end{bmatrix}<br>\begin{bmatrix}<br>x \<br>y \<br>z<br>\end{bmatrix}&#x3D; \begin{bmatrix}<br>-3 \<br>0 \<br>2<br>\end{bmatrix}<br>$$</p><p>也就是</p><p>$$<br>A\overrightarrow{x} &#x3D; \overrightarrow{v}<br>$$</p><p>A 可以看作是线性变换，也就是向量 x 在进行某种线性变换 A 后可以变为向量</p><p>A 是逆时针旋转 90 度的变换</p><p>$$<br>\begin{bmatrix}<br>0 &amp; -1\<br>1 &amp; 0<br>\end{bmatrix}<br>$$</p><p>$$A^{(-1)}$$逆则是顺时针旋转 90 度的变换</p><p>$$<br>\begin{bmatrix}<br>0 &amp; 1\<br>-1 &amp; 0<br>\end{bmatrix}<br>$$</p><p>两个变化的相继作用在矩阵中称为矩阵的乘法</p><p>$$A^{(-1)}A$$ 是一个“什么都不做”的变化 恒等不变</p><p>$$<br>\begin{bmatrix}<br>1 &amp; 0\<br>0 &amp; 1<br>\end{bmatrix}<br>$$</p><p>$$A^{(-1)}A\overrightarrow{x} &#x3D; A^{(-1)}\overrightarrow{V}$$</p><h2 id="逆矩阵"><a href="#逆矩阵" class="headerlink" title="逆矩阵"></a>逆矩阵</h2><h2 id="秩"><a href="#秩" class="headerlink" title="秩"></a>秩</h2><p>秩代表变化后空间的维度 - 列空间的维度</p><p>当变化的结果为一条直线时，也就是说结果为一维的，秩为 1<br>当变化的结果落在二维平面上，秩为 2</p><h2 id="列空间"><a href="#列空间" class="headerlink" title="列空间"></a>列空间</h2><p>不管是一条直线、还是一个平面还是一个三维空间，所有可能的变换结果的集合都被称为矩阵的列空间</p><p>矩阵的列告诉你基向量变化后的位置<br>变化后的基向量张成的空间就是所有可能的变化结果</p><p>矩阵的列张成的空间</p><p>0 向量一定在列空间中</p><p>变换后落在原点的向量的集合 被称作矩阵的“零空间”或者“核”</p><h2 id="非方阵-在不同维度空间之间的线性变换"><a href="#非方阵-在不同维度空间之间的线性变换" class="headerlink" title="非方阵 在不同维度空间之间的线性变换"></a>非方阵 在不同维度空间之间的线性变换</h2><p>比如一个二维向量到三位向量的变换</p><p>$$<br>\begin{bmatrix}<br>2\<br>7<br>\end{bmatrix}<br>$$</p><p>$$\overrightarrow{v}-&gt;$$</p><p>$$<br>\begin{bmatrix}<br>1\<br>8\<br>2\<br>\end{bmatrix}<br>$$</p><p>解读</p><p>$$<br>\begin{bmatrix}<br>3 &amp; 1\<br>4 &amp; 1\<br>5 &amp; 9\<br>\end{bmatrix}<br>$$</p><p>矩阵有两列代表输入空间有两个基向量<br>有三行表明每一个基向量在变换后都用三个独立的坐标来描述</p><p>$$<br>\begin{bmatrix}<br>3 &amp; 1 &amp; 5\<br>4 &amp; 1 &amp; 9\<br>\end{bmatrix}<br>$$</p><p>矩阵有三列表示元史空间中有三个基向量<br>每个变换后的基向量用两个坐标描述</p><p>所以他们会落在二维空间中</p><p>是一个三维空间到二维空间的变换</p><h2 id="点积"><a href="#点积" class="headerlink" title="点积"></a>点积</h2><p>$$<br>\begin{bmatrix}<br>3 \<br>4<br>\end{bmatrix}<br>*<br>\begin{bmatrix}<br>1 \<br>2<br>\end{bmatrix}&#x3D;3<em>1+4</em>2&#x3D;11<br>$$</p><p>$$<br>\overrightarrow{v}<em>\overleftrightarrow{w} &#x3D; \overleftrightarrow{w}在v向量上投影长度</em>\overrightarrow{v}<br>$$</p><p>方向相同 点积为正<br>方向垂直 点积为 0<br>方向相反 点积为负</p><p>点积与顺序无关 也就是不管是 v 向量投影到 w，还是 w 投影到 v 都一样</p><p>点积 -〉 矩阵被投影为一维空间<br>为什么和投影有关系？</p><h2 id="对偶性-？"><a href="#对偶性-？" class="headerlink" title="对偶性 ？"></a>对偶性 ？</h2><h2 id="叉积"><a href="#叉积" class="headerlink" title="叉积"></a>叉积</h2><p>两个向量 copy 两个向量的副本 围成的四边形的面积称为叉积</p><p>顺序对叉积有影响</p><p>叉积得到的结果是一个向量，这个向量的长度是行列式（面积），方向垂直于平行四边行</p><p>（这个叉积就可以看作是高）</p><h2 id="基向量-1"><a href="#基向量-1" class="headerlink" title="基向量"></a>基向量</h2><p>空间内存两个坐标系，有两个不同的基向量<br>我们的基向量</p><p>$$<br>\begin{bmatrix}<br>1 &amp; 0 \<br>0 &amp; 1<br>\end{bmatrix}<br>$$</p><p>其他人的基向量</p><p>$$<br>A&#x3D;\begin{bmatrix}<br>2 &amp; -1 \<br>1 &amp; 1<br>\end{bmatrix}<br>$$</p><p>将某个向量在我们的坐标系中进行旋转 90 度，在其他人的坐标系中的结果是怎样的？</p><p>将其他人的用我们的基向量进行线性变换来描述</p><p>$$<br>A^{(-1)} \begin{bmatrix}<br>0 &amp; -1 \<br>1 &amp; 0<br>\end{bmatrix}A\begin{bmatrix}<br>x  \<br>y<br>\end{bmatrix}<br>$$</p><p>进行操作之后再用逆矩阵还原回来</p><h2 id="特征向量和特征值"><a href="#特征向量和特征值" class="headerlink" title="特征向量和特征值"></a>特征向量和特征值</h2><p>将矩阵看为线性变化</p><p>变化之后还留在他张成的空间里</p><h3 id="特征值"><a href="#特征值" class="headerlink" title="特征值"></a>特征值</h3><p>$$<br>A\overrightarrow{v} &#x3D; n\overrightarrow{v}<br>$$</p><p>A 为变化的矩阵<br>n 为特征值<br>$\overrightarrow{v}$ 为特征向量</p><p>将 n 转换为对应的矩阵</p><p>$$<br>\begin{bmatrix}<br>n &amp; 0 &amp; 0  \<br>0 &amp; n &amp; 0  \<br>0 &amp; 0 &amp; n \<br>\end{bmatrix}<br>$$</p><p>提出因子 n</p><p>$$<br>n\begin{bmatrix}<br>1 &amp; 0 &amp; 0  \<br>0 &amp; 1 &amp; 0  \<br>0 &amp; 0 &amp; 1 \<br>\end{bmatrix}<br>$$</p><p>&#x2F;&#x2F; 单位矩阵</p><p>$$<br>I&#x3D; \begin{bmatrix}<br>1 &amp; 0 &amp; 0 \<br>0 &amp; 1 &amp; 0 \<br>0 &amp; 0 &amp; 1 \<br>\end{bmatrix}<br>$$</p><p>$$<br>(A - nI)\overrightarrow{v} &#x3D; \overrightarrow{0}<br>$$</p><p>(A - nI)的矩阵</p><p>$$<br>\begin{bmatrix}<br>2-n &amp; 0 &amp; 0 \<br>0 &amp; 3-n &amp; 0 \<br>1 &amp; 0 &amp; 4-n \<br>\end{bmatrix}<br>$$</p><p>找到一个 n 使这个行列式为 0 这个值就是特征值<br>det(A -nI) &#x3D; 0</p><p>? 3*3 或者其他类型的行列式怎么计算</p><h3 id="特征向量"><a href="#特征向量" class="headerlink" title="特征向量"></a>特征向量</h3><p>特征值 n&#x3D;2</p><p>$$<br>\begin{bmatrix}<br>3- n &amp; 1 \<br>0 &amp; 2-n \<br>\end{bmatrix}<br>\begin{bmatrix}<br>x  \<br>y \<br>\end{bmatrix}<br>&#x3D; \begin{bmatrix}<br>0  \<br>0 \<br>\end{bmatrix}<br>$$</p><p>计算得出 x+y &#x3D; 0</p><p>所得到的解全都在由（-1，1）张成的对角线上</p><p>二维线性变换不一定有特征向量<br>比如旋转 90 度</p><p>可能存在只有一个特征值，但是特征向量不止在一条直线上</p><p>比如同时放大两倍</p><p>$$<br>\begin{bmatrix}<br>2&amp; 0 \<br>0 &amp; 2 \<br>\end{bmatrix}<br>$$</p><h3 id="特征基"><a href="#特征基" class="headerlink" title="特征基"></a>特征基</h3><p>如果基向量都是特征向量会发生什么？</p><p>对角矩阵</p><p>$$<br>\begin{bmatrix}<br>2 &amp; 0 &amp; 0 \<br>0 &amp; 3 &amp; 0\<br>0 &amp; 0 &amp; 4 \<br>\end{bmatrix}<br>$$</p><p>所有的基向量都是特征向量<br>矩阵的对角元是它们所属的特征值</p><p>一组基向量（同样是特征向量）构成的集合被称为一组特征基</p><p>如果要计算这个矩阵的 100 次幂<br>先变换到特征基，再那个坐标系中计算 100 次幂</p><p>（也就是说先变化到标准的[0,1][1,0]那个坐标，变换后再用逆变换变回来，这样计算会更容易）</p><p>能张成全空间的特征向量</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://cloud.tencent.com/developer/article/1005103">https://cloud.tencent.com/developer/article/1005103</a></p><p><a href="https://blog.csdn.net/from_the_star/article/details/106427423">https://blog.csdn.net/from_the_star/article/details/106427423</a></p><p><a href="https://zhuanlan.zhihu.com/p/391746508">https://zhuanlan.zhihu.com/p/391746508</a></p><h3 id="逆矩阵的计算"><a href="#逆矩阵的计算" class="headerlink" title="逆矩阵的计算"></a>逆矩阵的计算</h3><p><a href="https://www.shuxuele.com/algebra/matrix-inverse.html">https://www.shuxuele.com/algebra/matrix-inverse.html</a></p><p><a href="https://www.zhihu.com/question/345971704/answer/1624930445">https://www.zhihu.com/question/345971704/answer/1624930445</a></p><h3 id="逆矩阵计算器"><a href="#逆矩阵计算器" class="headerlink" title="逆矩阵计算器"></a>逆矩阵计算器</h3><p><a href="https://matrix.reshish.com/zh/inverse.php">https://matrix.reshish.com/zh/inverse.php</a></p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="为什么在向量变换中要使用-4-4-矩阵"><a href="#为什么在向量变换中要使用-4-4-矩阵" class="headerlink" title="为什么在向量变换中要使用 4*4 矩阵"></a>为什么在向量变换中要使用 4*4 矩阵</h3><p>缩放<br>旋转<br>平移 不能用 3*3 矩阵来表示</p><p>$$<br>$$</p>]]></content>
    
    
    
    <tags>
      
      <tag>’线性代数‘</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>requestAnimationFrame</title>
    <link href="/2023/02/04/requestAnimationFrame/"/>
    <url>/2023/02/04/requestAnimationFrame/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>浏览器的一个请求动画的API，告诉浏览器你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行</p><h2 id="早期动画形式"><a href="#早期动画形式" class="headerlink" title="早期动画形式"></a>早期动画形式</h2><p>早期我们使用setTimeout或是setInterval()设置一个间隔时间，来不断的改变图像的位置，来达到一个动画的效果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javacript">function() &#123;<br>    function updateAnimations() &#123;<br>        doAnimation1();<br>        doAnimation2();<br>    &#125;<br>    setInterval(updateAnimation,100)<br>&#125;()<br><br></code></pre></td></tr></table></figure><ul><li><p>不能保证时间精度<br>  第二个延时参数，这里设置的毫秒延时并不能保证这个代码在什么时候会执行，只是会把回调加到任务队列，加到任务队列后，主线程如果还在被其他任务占用，比如还在处理用户操作，那么回调不会立即执行</p></li><li><p>时间间隔问题<br>  不同设备的屏幕刷新率不同（目前的一般浏览器的刷新屏幕为60Hz，也就是每秒重绘60次，实现平滑动画的最佳时间间隔为1000&#x2F;60，大约17毫秒）浏览器的自身计时器的精度也不一致，浏览器还会切换到后台和不活跃的标签中的计数器进行限流，所以我们设置固定的时间间隔无法达到一个最优效果</p></li></ul><h2 id="requestAnimationFrame"><a href="#requestAnimationFrame" class="headerlink" title="requestAnimationFrame"></a>requestAnimationFrame</h2><p>requesAnimatonFrame()方法由浏览器来计算正确的时间间隔 </p><p>例如：如果屏幕的刷新率为60Hz，那么时间间隔为1000&#x2F;60，如果屏幕刷新率为70Hz，那么时间间隔则为1000&#x2F;70，</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> progress = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateProgress</span>(<span class="hljs-params"></span>) &#123;<br>   progress += <span class="hljs-number">1</span>;<br>   <span class="hljs-keyword">if</span> (progress &lt; <span class="hljs-number">100</span>) &#123;<br>       <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">requestAnimationFrame</span>(updateProgress);<br>   &#125;<br>&#125;<br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">requestAnimationFrame</span>(updateProgress)<br></code></pre></td></tr></table></figure><h2 id="callback"><a href="#callback" class="headerlink" title="callback"></a>callback</h2><p>回调函数会被传入一个DOMHighResTimeStamp（doble 类型，双精度,储存毫秒级的时间值）参数，该参数与performance.now()的返回值相同，它表示requestAnimationFrame() 开始去执行回调函数的时刻，（表示下次重绘的时间）</p><p>(拓展：1.JS的数据类型 2.为什么0.1+0.2 !&#x3D;&#x3D; 0.3 3.performance相关接口)</p><h2 id="cancelAnimationFrame"><a href="#cancelAnimationFrame" class="headerlink" title="cancelAnimationFrame"></a>cancelAnimationFrame</h2><pre><code class="hljs">requestAnimationFrame()返回一个请求Id可以用cancelAnimationFrame() 来取消重绘任务<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> requestId = <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">requestAnimationFrame</span>(<span class="hljs-function">()=&gt;</span> &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;11&#x27;</span>);<br>&#125;)<br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">cancelAnimationFrame</span>(requestId);<br></code></pre></td></tr></table></figure></code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>javacript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mac科学上网</title>
    <link href="/2023/01/27/science-online/"/>
    <url>/2023/01/27/science-online/</url>
    
    <content type="html"><![CDATA[<h2 id="下载-Clash"><a href="#下载-Clash" class="headerlink" title="下载 Clash"></a>下载 Clash</h2><p><strong>链接地址：</strong> <a href="https://github.com/Fndroid/clash_for_windows_pkg/releases">clash 下载地址</a></p><p>选择图中标注进行下载</p><p><img src="/2023/01/27/science-online/2023-01-27-22-06-40.png" alt="scence-online"></p><h2 id="安装程序"><a href="#安装程序" class="headerlink" title="安装程序"></a>安装程序</h2><p>安装时候会提示</p><p><img src="/2023/01/27/science-online/2023-01-27-21-17-33.png"></p><p>打开系统设置<br><img src="/2023/01/27/science-online/2023-01-27-21-21-35.png"></p><p>在这个地方会有“仍要打开“字样 点击仍要打开 程序就可以正常使用</p><h2 id="机场选择-（科学上网节点服务商）"><a href="#机场选择-（科学上网节点服务商）" class="headerlink" title="机场选择 （科学上网节点服务商）"></a>机场选择 （科学上网节点服务商）</h2><p>这边我选择的是一元机场（便宜，刚使用，目前正常）</p><p><strong>一元机场链接：</strong> <a href="https://一元机场.com/">一元机场</a></p><p><img src="/2023/01/27/science-online/2023-01-27-21-57-50.png"></p><h2 id="clash-配置"><a href="#clash-配置" class="headerlink" title="clash 配置"></a>clash 配置</h2><p>选择一元机场</p><p><img src="/2023/01/27/science-online/2023-01-27-22-02-13.png"></p><p>配置代理 选择一个节点</p><p><img src="/2023/01/27/science-online/2023-01-27-22-05-19.png"></p><p>开启服务</p><p><img src="/2023/01/27/science-online/2023-01-27-22-06-40.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
